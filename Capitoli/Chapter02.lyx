#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass classicthesis
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package babel
\inputencoding default
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter courier
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "breaklines=true,frame=tb,captionpos=t,frameround=f,showlines=true,numbers=left,stepnumber=1,numbersep=10pt,numberstyle={\small\color{gray}\ttfamily\scriptsize},tabsize=2,language=Ruby,alsolanguage=HTML,basicstyle={\ttfamily\scriptsize}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Ruby On Rails
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:rubyonrails"

\end_inset


\end_layout

\begin_layout Section
Introduzione a RoR
\end_layout

\begin_layout Enumerate
Perchè Rails, rimando ad articolo
\end_layout

\begin_layout Subsection
Ruby
\end_layout

\begin_layout Standard
Ruby è un linguaggio di programmazione open-source, general-purpose e orientato
 agli oggetti ideato da Yukihiro Matsumoto.
 La prima pubblicazione del linguaggio risale al 1995 ed attualmente è alla
 versione 2.1.
 Ruby è fortemente orientato alla produttività, permette di scrivere codice
 essenziale, con un netto risparmio di linee di codice rispetto a linguaggi
 tipati staticamente come Java o C# e offre una sintassi ricca e versatile.
 
\end_layout

\begin_layout Standard
La comunità di Ruby è estremamente attiva e dinamica e contribuisce in maniera
 attiva all'individuazione di bug e al miglioramento continuo del linguaggio.
 Non è l'obbietto di questa tesi addentrarsi nelle particolarità sintattiche
 e semantiche di Ruby, ma ritengo sia utile fornire qualche riferimento
 per l'apprendimento del linguaggio.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\emph on
«Se intraprendete lo studio di un kōan e vi ci dedicate senza interrompervi,
 scompariranno i vostri pensieri e svaniranno i bisogni dell'io.
 » 
\emph default
(Hakuin, Orategama)
\emph on

\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
I Ruby Koans
\begin_inset Foot
status open

\begin_layout Plain Layout
I Koans sono disponibili su 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://rubykoans.com/
\end_layout

\end_inset

.
\end_layout

\end_inset

, 
\begin_inset Quotes eld
\end_inset

koan
\begin_inset Quotes erd
\end_inset

 è la pronuncia giapponese dei caratteri cinesi, sono una collezione di
 esercizi su Ruby e permettono lo studio del linguaggio comprendendo la
 maggior parte strutture sintattiche, degli elementi semantici e delle strutture
 dato.
 L'utente è guidato tramite nell'apprendimento in puro stile TDD, in maniera
 semplice, leggera ed irriverente; terminato il corso si acquisisce una
 buona consapevolezza del linguaggio e confidenza con lo stile di Ruby.
\end_layout

\begin_layout Standard
Sempre nello stile tracciato da i koan, tenuti in massima considerazione
 all'interno della comunità di utenti di Ruby, ho approfondito la conoscenza
 del linguaggio e di RoR tramite il portale Ruby Monk
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rubymonk.com/
\end_layout

\end_inset


\end_layout

\end_inset

 che fornisce numerosi tutorial interattivi ed esercizi riassuntivi per
 ogni argomento; ogni lezione è completabile attraverso il proprio browser
 internet e fornisce numerosi consigli e indicazioni allo studente.
\end_layout

\begin_layout Subsection
Don't Repeat Yourself
\end_layout

\begin_layout Standard
Il principio di mantenere il proprio senza ripetizioni e ben fattorizzato
 è un'ottima pratica di programmazione.
 Un progetto DRY permette agli sviluppatori di modificare il codice più
 semplicemente; una funzionalità descritta in un numero ridotto di unità
 di compilazioni e ben fattorizzata è facilmente individuabile, correggibile
 e modificabile senza incorrere in modifiche involontarie ad altre parti
 del sistema.
\end_layout

\begin_layout Standard
RoR fornisce differenti funzionalità, quali librerie, helpers e viste parziali,
 per aiutare lo sviluppatore a definire applicazioni DRY.
\begin_inset Newline newline
\end_inset

Nell'implementazione delle viste è comune che alcuni elementi siano presenti
 più volte all'interno della stessa applicazione o anche all'interno della
 stessa pagina.
 In RoR, è possibile definire delle viste parziali per poter fattorizzare
 al meglio queste porzioni di codice.
 Per rendere ancora più efficace questo meccanismo di fattorizzazione e
 definire dei comportamenti dinamici, è possibile passare al metodo 
\begin_inset Quotes eld
\end_inset

render
\begin_inset Quotes erd
\end_inset

, che si occupa di visualizzare file con estensione 'erb', dei parametri
 in maniera opzionale.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= render 
\end_layout

\begin_layout Plain Layout

	:partial => 'posts/logged_user_post_actions',
\end_layout

\begin_layout Plain Layout

	:locals => {
\end_layout

\begin_layout Plain Layout

		:current_user => current_user,
\end_layout

\begin_layout Plain Layout

		:post => post
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

%>
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualizzazione di un vista parziale.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<% if current_user %>
\end_layout

\begin_layout Plain Layout

	<div class='post_actions'>
\end_layout

\begin_layout Plain Layout

		<%= edit_post_image_link post %>
\end_layout

\begin_layout Plain Layout

		<%= remove_post_image_link post %>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

<% end %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Vista parziale.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre, data una vista parziale che visualizza un singolo elemento, è anche
 possibile passare al metodo render una collezione di oggetti sulla quale
 iterare, fornendo opzionalmente anche un separatore.
\begin_inset Foot
status open

\begin_layout Plain Layout
I metodi e le librerie in RoR tipicamente si prestano ad una grande varietà
 di usi e comportamenti, per una descrizione più precisa è possibile consultare
 la documentazione online.
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://api.rubyonrails.org/classes/ActionView/PartialRenderer.html
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La piattaforma RoR fornisce anche numerosi Helper.
 Un Helper è descritto da un insieme di funzionalità, definite all'interno
 di un modulo, utili per gestire problematiche classiche dello sviluppo
 di applicazioni web.
 La gestione di file, formattazione di date, gestione di form e generazione
 del relativo codice sono solo alcuni dei problemi risolvibili tramite gli
 helper definiti nell'API di RoR.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= truncate(post.body, :length => 500, :separator => ' ', :omission => '...')
 %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Il metodo 'truncate', appartenente al modulo TextHelper.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come già osservato durante l'uso delle viste parziali, le librerie offerte
 sono ricche di parametri opzionali, permettono l'uso di blocchi definiti
 dall'utente e sono ben documentate: ogni metodo presente è ampiamente descritto
 e offre diversi esempi per semplificarne l'uso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= form_for(@post) do |f| %>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	<div id="title_field">
\end_layout

\begin_layout Plain Layout

	<%= f.label :title, 'Titolo' %>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	<%= f.text_field :title, :size => 50 %>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

<% end %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Un esempio dell'uso delle funzionalità di FormHelper.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' altrettanto semplice definire i propri Helper: per ogni Controller definito
 dall'utente è incluso di default il relativo Helper, ad esempio in RBlog
 la classe PostsController include il modulo personalizzato PostsHelper
 in maniera automatica, senza necessità di configurarne l'uso e la visibilità
 all'interno del progetto.
\end_layout

\begin_layout Subsection
Convention Over Configuration
\end_layout

\begin_layout Standard
RoR definisce un insieme di convenzioni per semplificare l'uso e la configurazio
ne della piattaforma da parte dello sviluppatore.
 Per minimizzare il tempo richiesto per la messa a punto di un nuovo progetto,
 è utile seguire le convenzioni proposte, ordinando il codice in cartelle
 secondo le diverse funzionalità, aderendo alle convenzioni di denominazione
 dei file e degli attributi presenti nel modello.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ovviamente non è possibile prescindere completamente dall'uso di alcuni
 file di configurazione, ma RoR facilita ulteriormente la definizione di
 questi file codificandoli con YAML
\begin_inset Foot
status open

\begin_layout Plain Layout
Per informazioni si rimanda al sito ufficiale.
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.yaml.org/
\end_layout

\end_inset


\end_layout

\end_inset

, un formato di serializzazione facilmente leggibile e scrivibile, e Ruby
 stesso.
 Lo sviluppatore inoltre può anche sfruttare i numerosi tool a linea di
 comando per la prima generazione delle risorse, utili anche per avere una
 traccia contenente le impostazioni più plausibili per una nuova applicazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

default: &default
\end_layout

\begin_layout Plain Layout

adapter: postgresql
\end_layout

\begin_layout Plain Layout

encoding: unicode
\end_layout

\begin_layout Plain Layout

host: localhost
\end_layout

\begin_layout Plain Layout

pool: 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

development:
\end_layout

\begin_layout Plain Layout

<<: *default
\end_layout

\begin_layout Plain Layout

database: rblog_development
\end_layout

\begin_layout Plain Layout

username: xblog
\end_layout

\begin_layout Plain Layout

password: ...
\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento in YAML relativo alla configurazione del modello.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
L'interpretazione di RoR del pattern MVC
\end_layout

\begin_layout Subsubsection
Il modello
\end_layout

\begin_layout Standard
L'interpretazione di RoR del modello dell'architettura MCV prende spunto
 dal patter Active Record introdotto da Martin Fowler.
 I record attivi introducono un livello di astrazione fra gli strumenti
 di persistenza ed i controlli che gestiscono e manipolano il dominio; i
 dati sono astratti a oggetti aventi sia le informazioni che li caratterizzano,
 ad esempio i diversi attributi e le relazioni con altri tipi di dato presenti
 nel dominio, sia che le funzionalità che ne descrivono il comportamento
 attraverso i metodi d'istanza.
\end_layout

\begin_layout Standard
Il database, ed in generale qualunque sistema garantisca la persistenza
 della nostra applicazione, non è acceduto direttamente ma tramite il processo
 ORM.
 Questa tecnica minimizza, se non addirittura elimina, la necessita di eseguire
 codice nativo, come query SQL, per manipolare il dominio.
 L'uso del pattern Active Record permette a RoR delineare in maniera netta
 la separazione fra modello e controlli.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre a rappresentare i dati, è possibile sfruttare Ruby per individuare
 relazioni di ereditarietà fra i tipi esistenti, validare i dati attraverso
 l'invocazione di metodi e definire le proprie interrogazioni attraverso
 un apposita libreria.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@posts = Post
\end_layout

\begin_layout Plain Layout

			.where('title like ?', "#{params[:search]}%")
\end_layout

\begin_layout Plain Layout

			.order('created_at DESC')
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Esecuzione di una semplice query in Ruby.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
I controlli
\end_layout

\begin_layout Standard
Essendo i controlli gli elementi di interconnessione fra il modello e le
 viste è difficile per lo sviluppatore mantenerne l'implementazione semplice.
 Proprio per semplificare la definizione ed il mantenimento sono presenti
 alcuni accorgimenti in RoR.
\end_layout

\begin_layout Standard
La configurazione delle richieste instradabili è specificata in file separato
 
\begin_inset Quotes eld
\end_inset


\emph on
routes.rb
\emph default

\begin_inset Quotes erd
\end_inset

, all'interno del quale è possibile configurare le richieste HTTP soddisfabili
 e definire una gerarchia delle entità manipolate dall'applicazione secondo
 i principi di un'architettura REST.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources :posts do
\end_layout

\begin_layout Plain Layout

	get :autocomplete_title, :on => :collection
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

resources :sessions, :only => [:new, :create, :destroy]
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del file 
\begin_inset Quotes eld
\end_inset

routes.rb
\begin_inset Quotes erd
\end_inset

 relativo ai controlli di post e sessioni.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un altro accorgimento apprezzato durante lo sviluppo è la possibilità di
 definire dei filtri per i controlli.
 Per ogni controllo sono previsti alcuni stati a cui è possibili attribuire
 eventi, i filtri per l'appunto.
 Sfruttando questa semplice tecnica è possibile fattorizzare alcuni comportament
i comuni all'interno dei controlli di una stessa entità, come ad esempio
 la verifica delle autorizzazione per alcune operazioni sensibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

before_action
\end_layout

\begin_layout Plain Layout

	:require_login,
\end_layout

\begin_layout Plain Layout

	only: [:new, :create, :edit, :update, :destroy]
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
L'uso dei filtri in RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Le viste
\end_layout

\begin_layout Standard
Le viste in RoR sono definibili introducendo nei file HTML elementi dinamici
 contenenti espressioni scritte in Ruby.
 ERB, acronimo per Embedded Ruby, permette l'inserimento di codice da processare
 all'interno del server web prima di fornire la risposta al client.
\end_layout

\begin_layout Standard
La definizione di viste dinamiche risulta immediata, conoscendo sia Ruby
 che HTML tramite solo tre tipi di delimitatori, che variano esclusivamente
 nel tipo di output generato.
\begin_inset Foot
status open

\begin_layout Plain Layout
Per maggiori informazioni relative alle viste e alla definizione di pagine
 dinamiche tramite ERB si rimanda alla seguente guida: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/layouts_and_rendering.html
\end_layout

\end_inset


\end_layout

\end_inset

 Le viste scritte tramite ERB sono facilmente leggibili grazie alla caratteristi
che di Ruby
\begin_inset Marginal
status open

\begin_layout Plain Layout
Ogni espressione ha un valore.
 Il valore di ritorno delle funzioni e dei metodi è dato dall'ultima espressione
 eseguita.
 Le parentesi sono opzionali ed anche i parametri possono esserlo.
\end_layout

\end_inset

, alla sintassi minima e alle numerose funzionalità presente negli Helper
 e librerie del linguaggio.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class='post'>
\end_layout

\begin_layout Plain Layout

	<p class='post_title'>
\end_layout

\begin_layout Plain Layout

		<%= link_to @post.title, @post %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

	<p class='post_detail'>
\end_layout

\begin_layout Plain Layout

		<%= author_detail(@post) %>
\end_layout

\begin_layout Plain Layout

		</br>
\end_layout

\begin_layout Plain Layout

		<% post_details(@post).each do |detail| %>
\end_layout

\begin_layout Plain Layout

			<%= detail %>
\end_layout

\begin_layout Plain Layout

		<% end %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

    <p class='post_content'>
\end_layout

\begin_layout Plain Layout

		<%= @post.body %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

	<%= render 
\end_layout

\begin_layout Plain Layout

		:partial => 'logged_user_post_actions',  
\end_layout

\begin_layout Plain Layout

		:locals => {:current_user => current_user, :post => @post}
\end_layout

\begin_layout Plain Layout

	%>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento di vista relativo alla visualizzazione di un singolo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Il testing
\end_layout

\begin_layout Standard
La propensione alla verifica dell'applicazione non è un elemento proprio
 dell'architettura MVC, ma influisce comunque notevolmente sul processo
 di sviluppo.
\end_layout

\begin_layout Standard
Tramite RoR è possibile gestire l'intero stack di un'applicazione web, test
 inclusi.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html
\end_layout

\end_inset


\end_layout

\end_inset

 Sfruttando RSpec, strumento eletto a standard de-facto, è possibile testare
 il modello attraverso i record attivi ed anche verificare i propri controller,
 definendo i parametri HTTP e dati.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Da Ruby 1.9 è incluso la libreria MiniTest, che fornisce le funzionalità
 per arricchire i propri test con delle callback da applicare a differenti
 stati dell'esecuzione della libreria di test, introduce oggetti 
\begin_inset Quotes eld
\end_inset


\emph on
mock
\emph default

\begin_inset Quotes erd
\end_inset

, consente di effettuare misurazioni delle prestazioni e molto altro.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/seattlerb/minitest
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Paragonabili alla annotazioni 
\emph on
@After
\emph default
, 
\emph on
@Before
\emph default
, 
\emph on
@AfterClass
\emph default
 e 
\emph on
@BeforeClass
\emph default
 in JUnit 4.x.
\end_layout

\end_inset

 Esistono numerose gemme sviluppate da terze parti per aggiungere funzionalità
 e semplificare il processo di testing, ad esempio per la pulizia dei database
 utilizzati DatabaseCleaner è molto diffusa, al pari di Factory Girl
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/DatabaseCleaner/database_cleaner
\end_layout

\end_inset


\end_layout

\end_inset

 per la popolazione del modello.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/thoughtbot/factory_girl
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
E' anche previsto che il modello sia presente in tre versioni, -test, sviluppo
 e produzione- al fine di concedere allo sviluppatore la libertà di eseguire
 test sulle nuove funzionalità senza dover effettuare continui backup dei
 dati ed assumere altre precauzioni.
\begin_inset Newline newline
\end_inset

Rail fornisce inoltre il comando Rake per poter gestire al meglio l'esecuzione
 selettiva delle proprie librerie di test.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html##rake-tasks-for-running-your-tests
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
L'obbiettivo di questa tesi non è l'uso approfondito di RoR e delle sue
 funzionalità, ma durante l'implementazione del blog sono state notate alcune
 peculiarità del framework e del suo 
\begin_inset Quotes eld
\end_inset


\emph on
ecosistema
\emph default

\begin_inset Quotes erd
\end_inset

 che hanno contribuito che lo sviluppo si svolgesse in maniera lineare permetten
do di scrivere codice in maniera produttiva e concentrando la propria attenzioni
 all'indagine sui test di accettazione piuttosto che a problematiche di
 contorno.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A differenza di altre piattaforme, in cui sono presenti strumenti esterni
 per supportare la compilazione e la risoluzione delle dipendenze come Maven
 e Gradle, Ruby sfrutta un proprio meccanismo, definendo delle gemme.
 Ogni gemma rappresenta una libreria, ha un nome, versione ed architettura
 di riferimento.
 
\end_layout

\begin_layout Standard
Ogni applicazione è caratterizzata da una risorsa chiamata Gemfile, un semplice
 script in Ruby, che rappresenta l'insieme delle dipendenze e delle gemme
 da includere nel proprio progetto.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rubygems.org/
\end_layout

\end_inset

 è il servizio di hosting di riferimento.
\end_layout

\end_inset

 E' possibile indicare quali librerie includere in funzione del tipo di
 compilazione adottata, rilascio, sviluppo o test, e delegando la verifica
 di aggiornamenti per librerie di terze parti al sistema.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

source 'https://rubygems.org'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

group :development, :test do
\end_layout

\begin_layout Plain Layout

	gem 'cucumber-rails', :require => false 	gem 'rspec-rails'
\end_layout

\begin_layout Plain Layout

	gem 'capybara'
\end_layout

\begin_layout Plain Layout

	gem 'poltergeist'
\end_layout

\begin_layout Plain Layout

	gem 'database_cleaner'
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del Gemfile di RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fra le gemme utilizzate, la più preziosa
\begin_inset Marginal
status open

\begin_layout Plain Layout
:)
\end_layout

\end_inset

 è Spring.
 La libreria permette di caricare in anticipo le modifiche fatte al codice
 sorgente dell'applicazione in maniera che sia sempre in esecuzione la versione
 più recente, evitando all'utente di dover riavviare l'esecuzione manualmente
 ad ogni cambiamento.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nel contesto di sviluppo di applicazioni MVC è facile introdurre delle discrepan
ze fra il modello e la rappresentazione delle entità all'interno dell'applicazio
ne, soprattutto sfruttando strumenti di versionamento che offrono operazioni
 equivalenti alla 
\begin_inset Quotes eld
\end_inset


\emph on
revert
\emph default

\begin_inset Quotes erd
\end_inset

 in Git.
 
\end_layout

\begin_layout Standard
In RoR è previsto il meccanismo delle migrazioni che fornisce uno strumento
 per mantenere lo schema del modello consistente durante il processo di
 sviluppo in maniera semplice e lineare.
 Ogni variazione alla struttura del modello è tradotto in una migrazione,
 che definisce l'insieme delle operazioni compiute a basso livello, l'aggiunta
 di colonne, la rimozione di un vincolo etc., ed attribuisce una versione
 all'operazione; le stesse informazioni sulle migrazioni sono mantenute
 nel modello e tengono traccia dei cambiamenti apportati e dello stato attuale
 dello schema, permettendo di mantenere tutte le componenti dell'architettura
 MVC consistenti fra loro.
\end_layout

\begin_layout Section
RubyMine
\end_layout

\begin_layout Standard
Per lo sviluppo di RBlog e la definizione dei test di accettazione è stato
 utilizzato RubyMine, alla versione 6.3.
 L'IDE prodotto da JetBrains, sviluppatori anche di IntelliJ IDEA, Android
 Studio, ReSharper per citare i più conosciuti, supporta le feature di Rails
 4.1 e Ruby 2.1, ovvero le versioni più recenti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'esperienza con RubyMine è stata ottima: durante lo sviluppo sono stati
 rilevati raramente problemi ed integra perfettamente tutte le funzionalità
 a riga di comando offerte da Rails; Ruby, HTML, JavaScript, JQuery, CoffeeScrip
t, SCSS sono solo alcuni dei linguaggi supportati nell'IDE e per tutti sono
 definite varie strategie di refactoring ed è possibile analizzarne le relative
 risorse tramite un potente tool di analisi del codice.
 
\end_layout

\begin_layout Standard
Nell'IDE sono presenti diversi plugin per l'integrazione con strumenti di
 terzi, come ad esempio Cucumber, Git
\begin_inset Foot
status open

\begin_layout Plain Layout
Sono inclusi diversi plugin per il supporto sistemi di versionamento: attualment
e sono disponibili CVS, Git, Subversion, Mercurial e Perforce.
\end_layout

\end_inset

 e SSH.
 RubyMine è un prodotto curato nei dettagli, professionale ed allo stesso
 tempo adatto anche agli utenti alle prime armi; ma soprattutto permette
 l'implementazione di un'applicazione in Rails praticamente senza abbandonare
 l'ambiente di sviluppo.
\end_layout

\begin_layout Section
Hello RBlog!
\end_layout

\begin_layout Standard
L'obbiettivo di questa prima funzionalità è minimo, è necessario che l'applicazi
one sia in esecuzione ed il sito web raggiungibile.
 Inoltre il blog deve consentire la navigazione verso alcune pagine statiche.
\end_layout

\begin_layout Subsection
Cucumber
\end_layout

\begin_layout Standard
Il primo tassello necessario per l'implementazione dei test di accettazione
 su un'applicazione web sviluppata in RoR è Cucumber.
\end_layout

\begin_layout Standard
Cucumber è un framework per il supporto al BDD, Behaviour Driven Development,
 che permette di scrivere i propri test in maniera leggibile, elegante e
 mantenibile.
 Il framework è disponibile anche in Java, .Net, Python, PHP e molti altri
 linguaggi e piattaforme.
\end_layout

\begin_layout Subsubsection
Le funzionalità
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:01x00 Hello RBlog!"

\end_inset

La prima feature di RBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo obbiettivo dei test di accettazione è di individuare le funzionalità
 da sviluppare, le caratteristiche e potenzialità che l'applicazione offre
 e i diversi scenari che le definiscono.
\end_layout

\begin_layout Standard
Le funzionalità in Cucumber sono elementi esclusivamente descrittivi, non
 sono utilizzate esplicitamente nell'implementazione dei test ma hanno lo
 scopo di far cogliere la giusta prospettiva al team di sviluppo e descrivere
 genericamente gli l'obbiettivo degli scenari.
 Sia il titolo che la descrizione possono essere in linguaggio naturale
 e non hanno alcun impatto nell'implementazione degli scenari, per lo sviluppo
 di RBlog sono state usate le user story secondo il formato 
\begin_inset Quotes eld
\end_inset


\emph on
Per
\emph default
 <beneficio>, 
\emph on
come
\emph default
 <ruolo>, 
\emph on
vorrei
\emph default
 <obbiettivo, desiderio>
\begin_inset Quotes erd
\end_inset

.
 Per facilitare lo sviluppo di test all'interno del proprio progetto è consiglia
to seguire la convenzione di inserire all'interno della cartella 
\begin_inset Quotes eld
\end_inset


\emph on
features
\emph default

\begin_inset Quotes erd
\end_inset

 i test di accettazione ed attribuire ai relativi file l'estenzione 
\begin_inset Quotes eld
\end_inset


\emph on
.feature
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nella listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x00 Hello RBlog!"

\end_inset

, oltre alla descrizione della funzionalità è presente un etichetta che
 permette di organizzare e categorizzare quanto sviluppato con Cucumber;
 
\begin_inset Quotes eld
\end_inset


\emph on
@cap1
\emph default

\begin_inset Quotes erd
\end_inset

 caratterizza sia la user-story sia gli scenari che la definiscono per ereditari
et.
 L'etichetta è stata introdotta per poter eseguire in maniera selettiva
 gli scenari della prima funzionalità.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cucumber --tags @cap1
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Comando per l'esecuzione degli scenari relativi alla feature 
\begin_inset Quotes eld
\end_inset

Hello RBlog!
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' possibile introdurre un numero arbitrario di etichette per ciascun elemento,
 sia funzionalità o scenario, e sfruttando l'opzione 
\begin_inset Quotes eld
\end_inset


\emph on
--tags
\emph default

\begin_inset Quotes erd
\end_inset

 definire il corretto insieme di test da eseguire, tramite gli operatori
 logici AND, OR e NOT.
\end_layout

\begin_layout Subsubsection
Gli scenari
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Visita alla pagina iniziale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Allora posso visitare la pagina dell'autore
\end_layout

\begin_layout Plain Layout

E posso visitare la pagina dell'abstract
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:01x01 Homepage"

\end_inset

Navigazione verso la pagina iniziale
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo scenario descrive la navigazione verso la homepage, relativo alla
 funzionalità 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x00 Hello RBlog!"

\end_inset

 ed introduce la sintassi di Cucumber.
 Gli scenario sono caratterizzati da un titolo, che riassume il comportamento
 e da un insieme di passi.
 Seguendo la logica del BDD, ogni passo può alternativamente di tipo 
\begin_inset Quotes eld
\end_inset


\emph on
Given
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
When
\emph default

\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\emph on
Then
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tramite i passi di tipo 
\begin_inset Quotes eld
\end_inset

Given
\begin_inset Quotes erd
\end_inset

 è possibile verificare che il sistema sia in uno stato prefissato e conosciuto
 all'utente, stato dal quale sarà possibile compiere le azioni descritte
 successivamente nel test.
 Rispetto ad uno use-case un passo 
\begin_inset Quotes eld
\end_inset

Given
\begin_inset Quotes erd
\end_inset

 è l'equivalente di una precondizione.
\end_layout

\begin_layout Standard
I passi 
\begin_inset Quotes eld
\end_inset

When
\begin_inset Quotes erd
\end_inset

 descrivono le azioni compiute dall'utente e permettono la transizione del
 sistema verso un nuovo stato, analogamente agli eventi di una macchina
 a stati.
\end_layout

\begin_layout Standard
Lo scopo dei passi 
\begin_inset Quotes eld
\end_inset

Then
\begin_inset Quotes erd
\end_inset

 è di osservare il risultato delle azioni compiute precedentemente.
 Le osservazioni dovrebbero essere consistenti con i benefici dichiarati
 per la funzionalità ed analizzare solo quanto è osservabile tramite l'interfacc
ia del sistema ed ottenuto come conseguenza alle azioni compiute.
 Ad esempio, non è compito dei test di accettazione su RBlog verificare
 lo stato della tabella Post nel modello.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La scelta del prefisso del passo non limita le potenzialità del passo stesso,
 ma ovviamente un uso corretto favorisce la leggibilità del test.
 E' anche possibile sfruttare i prefissi 
\begin_inset Quotes eld
\end_inset


\emph on
And
\emph default

\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\emph on
But
\emph default

\begin_inset Quotes erd
\end_inset

 per rendere i propri scenari più scorrevoli; alle congiunzioni è attribuito
 il tipo del passo precedente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Schema dello scenario: Visita alla pagina dell'autore e alla pagina dell'abstrac
t
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Quando navigo verso "<nome della pagina>"
\end_layout

\begin_layout Plain Layout

Allora la pagina è intitolata "<nome della pagina>"     
\end_layout

\begin_layout Plain Layout

E posso tornare alla pagina iniziale   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Esempi:
\end_layout

\begin_layout Plain Layout

| nome della pagina |
\end_layout

\begin_layout Plain Layout

| Autore            |
\end_layout

\begin_layout Plain Layout

| Abstract          |
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:01x02 Pagine statiche"

\end_inset

Navigazione verso le pagine statiche
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cucumber offre la possibilità di definire scenari parametrici.
 Sfruttando la sintassi 
\emph on

\begin_inset Quotes eld
\end_inset

Schema dello 
\emph default
scenario
\begin_inset Quotes erd
\end_inset

, la tabella 
\begin_inset Quotes eld
\end_inset


\emph on
Esempi
\emph default

\begin_inset Quotes erd
\end_inset

 e i delimitatori 
\begin_inset Quotes eld
\end_inset


\emph on
< >
\emph default

\begin_inset Quotes erd
\end_inset

 è possibile verificare tanti scenari quanti sono i parametri all'interno
 della tabella: lo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset

 è effettuato sia sulla pagina dell'autore che sulla pagina dell'abstract.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Visita alle pagine statiche: la pagina dell'autore e all'abstract
 della tesi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Quando navigo verso "Autore"
\end_layout

\begin_layout Plain Layout

Allora la pagina è intitolata "Autore"
\end_layout

\begin_layout Plain Layout

E posso tornare alla pagina iniziale
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Testo generato dallo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Business Readable DSL
\end_layout

\begin_layout Standard
Il linguaggio utilizzato per descrivere le funzionalità e gli scenari in
 Cucumber è Gherkin.
\begin_inset Foot
status open

\begin_layout Plain Layout
Maggiori informazioni relative alla sintassi sono reperibili alla pagina
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/cucumber/cucumber/wiki/Gherkin
\end_layout

\end_inset


\end_layout

\end_inset

 Gli autori, gli stessi di Cucumber, descrivono il linguaggio come Business
 Readable DSL, definizione introdotta da Martin Fowler nel 2008.
\begin_inset Foot
status open

\begin_layout Plain Layout
L'articolo completo di Fowler è consultabile sul suo blog 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://martinfowler.com/bliki/BusinessReadableDSL.html
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'obbiettivo principale di un Business Readable DSL è permettere la partecipazio
ne all'analisi e alla revisione del codice a figure non tecniche.
 Fowler sottolinea come sia più importante definire un linguaggio leggibile
 rispetto ad uno anche scrivibile, infatti il principale obbiettivo di Business
 Readable DSL è stabilire un canale di comunicazione arricchente fra le
 diverse parti che partecipano allo sviluppo.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsubsection
I18n
\end_layout

\begin_layout Standard
Cucumber supporta attualmente 40 lingue, numero in rapida crescita secondo
 gli sviluppatori.
\begin_inset Foot
status open

\begin_layout Plain Layout
Per ottenere la lista aggiornata delle lingue supportate è possibile eseguire
 il comando cucumber --i18n help o consultare la risorsa contenente il dizionari
o 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/cucumber/gherkin/blob/master/lib/gherkin/i18n.json
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Cucumber l'implementazione dei passi non è vincolata dal tipo definito,
 ad esempio è possibile sfruttare un'asserzione come invariante.
 Questa particolarità di Cucumber offre la possibilità di definire più librerie
 di test di accettazione in differenti lingue ed utilizzare lo stesso codice
 per l'implementazione dei passi.
 Una potenzialità simile può essere utile per documentare lo sviluppo di
 progetti che coinvolgono stake-holders di diverse nazionalità.
\end_layout

\begin_layout Subsubsection
Supporto a Cucumber in RubyMine
\end_layout

\begin_layout Standard
RubyMine, l'ambiente di sviluppo scelto per sviluppare tramite RoR, integra
 le funzionalità di Cucumber e assiste il programmatore nel corso dello
 sviluppo dei test: la sintassi di Gherkin è evidenziata, è presente l'auto-comp
letamento delle parole chiave del DSL, è possibile navigare dalla definizione
 all'implementazione del passo ed è fornita un'interfaccia grafica per l'esecuzi
one dei test, configurabile in funzione di tag, file delle funzionalità
 da includere ed altri parametri.
\end_layout

\begin_layout Subsection
Capybara
\end_layout

\begin_layout Standard
Capybara è una libreria in Ruby che permette la definizione di test di accettazi
one automatici per applicazioni web, non necessariamente scritte tramite
 RoR, simulando le azioni eseguibili via interfaccia grafica.
 
\end_layout

\begin_layout Standard
Capybara nasconde all'utente i dettagli tecnici della navigazione tramite
 primitive di funzioni semplici, intuitive e versatili.
 A differenza di Selenium, le cui primitive si interfacciano con aspetti
 a basso livello, le funzionalità di Capybara sono astratte e mantengono
 la stessa prospettiva di un test effettuato manualmente da un utente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La configurazione di Capybara è effettuata tramite un breve script in Ruby
 dove è necessario impostare le proprie preferenze.
 Innanzitutto è necessario scegliere quale browser web sarà utilizzato ed
 il relativo driver per Capybara importando la libreria nel file 
\begin_inset Quotes eld
\end_inset


\emph on
features/support/env.rb
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'cucumber/rails'
\end_layout

\begin_layout Plain Layout

require 'capybara'
\end_layout

\begin_layout Plain Layout

require 'capybara/cucumber'
\end_layout

\begin_layout Plain Layout

require 'capybara/rspec'
\end_layout

\begin_layout Plain Layout

require 'capybara/poltergeist'
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Dipendenze all'interno dello script di configurazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Infine, se necessario, è possibile configurare il driver scelto: la struttura
 di Capybara permette l'uso di diversi driver e browser, senza modificare
 le primitive offerte.
 Tutti i driver devono implementare le funzionalità obbligatorie indicate
 nella libreria, ma è consentito non fornire il resto delle operazioni ma
 essere comunque annoverati fra i driver esistenti per Capybara.
 Per RBlog è stato utilizzato Poltergeist.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Capybara.default_driver = :poltergeist
\end_layout

\begin_layout Plain Layout

Capybara.register_driver :poltergeist do |app|
\end_layout

\begin_layout Plain Layout

	options = { 			
\end_layout

\begin_layout Plain Layout

		:js_errors => true,
\end_layout

\begin_layout Plain Layout

		:timeout => 120,
\end_layout

\begin_layout Plain Layout

		:debug => true,
\end_layout

\begin_layout Plain Layout

		:phantomjs_options => ['--load-images=yes', '--disk-cache=false'],
\end_layout

\begin_layout Plain Layout

		:inspector => true,
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	Capybara::Poltergeist::Driver.new(app, options)
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
Configurazione di Poltergeist
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le opzioni più rilevanti per Poltergeist sono:
\end_layout

\begin_layout Itemize
:js_errors rileva ogni errore relativo alle esecuzione di codice JavaScript
 e genera un errore in Ruby;
\end_layout

\begin_layout Itemize
:inspector è un'opzione sperimentale che permette il debug dell'esecuzione
 tramite una terza applicazione, come ad esempio Chrome web inspector;
\end_layout

\begin_layout Itemize
:debug reindirizza l'output dell'esecuzione in modalità debug verso STDERR.
\end_layout

\begin_layout Subsection
PhantomJS
\end_layout

\begin_layout Standard
PhantomJS è un browser headless, ovvero supporta tutte le funzionalità di
 un browser web moderno ma senza possedere un'interfaccia grafica e si basa
 sul motore di rendering WebKit, lo stesso utilizzato da Chrome e Safari.
\end_layout

\begin_layout Standard
E' particolarmente adatto all'esecuzione automatica di applicazioni web
 in quanto non è necessario che il sistema sia dotato di un framework per
 la gestione di GUI, funzionalità spesso mancante sui server che effettuano
 l'integrazione continua.
\end_layout

\begin_layout Standard
Con PhantomJS è possibile far fallire i propri test in funzione di errori
 su codice JavaScript, funzionalità non presente su altri browser, grazie
 all'opzione :js_errors precedentemente descritta.
\begin_inset Foot
status open

\begin_layout Plain Layout
PhantomJS è installabile tramite i pacchetti d'installazione presenti sul
 sito ufficiale 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://phantomjs.org/download.html
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Poltergeist
\end_layout

\begin_layout Standard
Poltergeist è un driver per il browser PhantomJS ed implementa la totalità
 delle funzionalità obbligatorie e molte delle opzionali disponibili.
 Dopo aver configurato il driver nel file 
\begin_inset Quotes eld
\end_inset

env.rb
\begin_inset Quotes erd
\end_inset

 tutte le operazioni saranno gestite tramite la libreria di Capybara.
\end_layout

\begin_layout Standard
La combinazione Capybara - Poltergeist - PhantomJS è attualmente una delle
 più diffuse per lo sviluppo di test di accettazione automatici perché da
 ottimi risultati nella gestione di strumenti asincroni come AJAX, è estremament
e veloce e molto accurata nella gestione di falsi positivi, come ad esempio
 il click su eventi esistenti nel DOM di una pagina HTML ma non visibili.
\begin_inset Foot
status open

\begin_layout Plain Layout
L'installazione di Poltergeist è effettuata attraverso il gemfile e la gemma
 
\begin_inset Quotes eld
\end_inset

poltergeist
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Quando viene richiesto il click su un elemento, Poltergeist non genera un
 evento attraverso il DOM ma simula un evento reale, ad esempio scendendo
 lungo la pagina nel caso in cui l'elemento non dovesse essere visibile.
 Inoltre sono previste diverse casistiche di errori, come l'impossibilità
 di compiere azioni su un elemento coperto.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
La struttura dei passi in Capybara è definita a priori e non varia in funzione
 del tipo implementato.
 Per implementare un passo è necessario creare uno script Ruby, ad esempio
 
\begin_inset Quotes eld
\end_inset

features/steps_definition/constraints.rb
\begin_inset Quotes erd
\end_inset

, e definirne l'implementazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Given(/^apro RBlog$/) do
\end_layout

\begin_layout Plain Layout

	visit steps_helper.rblog_url
\end_layout

\begin_layout Plain Layout

	#...
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro RBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro RBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sfruttando il metodo Given di Cucumber, in generale lo schema è valido anche
 per gli altri tipi disponibili, è possibile specificare un'espressione
 regolare ed il comportamento associato.
 All'esecuzione dei test, Capybara verifica che sia presente un'implementazione
 per ogni passo definito tramite Cucumber ed applica le istruzioni associate.
 E' necessario che per ogni passo in linguaggio naturale esista un'unica
 espressione regolare corrispondente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^apro (.*)$/) do |site_name|
\end_layout

\begin_layout Plain Layout

	#...
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Ipotetica implementazione ulteriore.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'introduzione di un'ulteriore implementazione, anche se con tipo differente,
 genere un'ambiguità che secondo il comportamento standard di Cucumber non
 è risolta.
\begin_inset Foot
status open

\begin_layout Plain Layout
Sfruttando l'opzione --guess di Cucumber è possibile far variare il comportament
o per la scelta dell'implementazione da applicare.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
La struttura di Capybara
\end_layout

\begin_layout Standard
L'implementazione di passo è definibile all'interno di un blocco
\begin_inset Foot
status open

\begin_layout Plain Layout
In Ruby è possibile attribuire ad ogni metodo un blocco contenente del codice
 da eseguire durante l'esecuzione.
 I blocchi sono paragonabili ad espressioni lambda, ma non sono elementi
 di prim'ordine del linguaggio.
\end_layout

\end_inset

 e non esiste alcuna limitazione né controllo riguardo alla tipologia di
 espressioni che vengono eseguite durante il passo.
\end_layout

\begin_layout Standard
In Capybara esistono numerose funzionalità per la gestione degli elementi,
 indicati come nodi.
 La gerarchia dei nodi è la seguente:
\end_layout

\begin_layout Itemize
la classe più semplice è Capybara::Node::Simple e rappresenta gli elementi
 di una pagina web, tali oggetti possono essere individuati all'interno
 del documento e analizzati in funzione degli attributi, ma non sono utilizzabil
i per compiere azioni;
\end_layout

\begin_layout Itemize
la classe Capybara::Node::Base è la classe padre di Element e Document:
 gli oggetti delle classi figlie condividono gli stessi metodi sfruttando
 i metodi presenti nei moduli Finders, Matchers e Actions.
 A differenza dei nodi semplici è quindi possibile compiere azioni su di
 essi;
\end_layout

\begin_layout Itemize
la classe Element rappresenta un singolo elemento all'interno del DOM della
 pagina;
\end_layout

\begin_layout Itemize
la classe Document rappresenta i documenti HTML nella loro interezza.
\end_layout

\begin_layout Standard
Il modulo Finders contiene un insieme di funzionalità dedicate all'individuazion
e di nodi all'interno della pagina.
 I metodi sono suddivisi in funzione del tipo di elemento ricercato, come
 ad esempio find_button e find_link, e della cardinalità attesa, il metodo
 all restituisce tutti gli elementi che soddisfano la ricerca a differenza
 dei metodi find_* dai quali è atteso l'individuazione di esattamente un
 nodo.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il modulo Actions permette l'interazione con l'interfaccia della pagina:
 sono quindi previsti, ad esempio, metodi per la compilazione di form HTML
 ed la selezione di elementi.
 Le operazioni permettono anche di specificare delle opzioni per effettuare
 delle variazioni o verificare alcune proprietà prima di compiere l'evento.
\begin_inset Foot
status open

\begin_layout Plain Layout
Il metodo click_link permette di specificare un l'opzione :href per verificare
 l'uguaglianza del attributo href prima di effettuare il click sul collegamento.
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Infine il modulo Matchers verifica le proprietà di un nodo, sia esso un
 sotto elemento della pagina o il documento stesso.
 Ad esempio è possibile verificare che sia presente un selettore, indicando
 l'identificatore css o una query XPath, o la presenza di attributo per
 l'elemento che invoca il metodo.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La libreria di Capybara è ricca di funzionalità e si presta in maniera versatile
 a diversi usi e preferenze.
 Per la maggior parte dei metodi è prevista la possibilità di specificare
 delle opzioni ed influire, in funzione della natura dell'operazione, sul
 comportamento di default.
 Inoltre, soprattutto all'interno del modulo Matchers, esistono diversi
 modi per definire le istruzioni, facilitando la scrittura dei test.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

page.title
\end_layout

\begin_layout Plain Layout

page[:title]
\end_layout

\begin_layout Plain Layout

page.has_title? "xyz"
\end_layout

\begin_layout Plain Layout

page.has_no_title? "zyx"
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Istruzioni equivalenti per l'accesso all'attributo title di una pagina HTML.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Navigare all'interno del sito
\end_layout

\begin_layout Standard
Nel passo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Implementazione \"apro RBlog\""

\end_inset

 è utilizzato il metodo 
\begin_inset Quotes eld
\end_inset

visit
\begin_inset Quotes erd
\end_inset

 che permette la navigazione verso una certa pagina web.
 All'esecuzione del metodo coincide una richiesta HTTP in GET all'indirizzo
 indicato come parametro, che può essere sia relativo che assoluto.
\begin_inset Foot
status open

\begin_layout Plain Layout
Il metodo rblog_url dell'oggetto denominato steps_helper, appartiene alla
 classe StepsHelper, utilizzata per contenere alcuni metodi d'utilità sfruttati
 durante lo sviluppo dei test.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^navigo verso "([^"]*)"$/) do |page_name|
\end_layout

\begin_layout Plain Layout

	find_link(page_name).click
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:evento naviga verso"

\end_inset

Navigazione nel sito, sfruttando il testo visualizzato di un link.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo visit, utilizzato per aprire la pagina iniziale del blog, non
 verifica la presenza all'interno della pagina di un collegamento verso
 la destinazione, ma semplicemente effettua la richiesta all'indirizzo indicato.
\end_layout

\begin_layout Standard
Per verificare la presenza di link alle pagine statiche nell'homepage è
 stato utilizzato il metodo 
\begin_inset Quotes eld
\end_inset

find_link
\begin_inset Quotes erd
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
Una pagina web statica è una pagina web i cui contenuti sono formattati
 direttamente in HTML, e non subiscono modifiche in funzione dello stato
 attuale dell'applicazione.
 Al contrario le pagine dinamiche rappresentano lo stato di una o più entità
 presente all'interno del sito e possono variare nel tempo.
 In RBlog un esempio di pagina statica è la pagina che descrive l'abstract
 del progetto, mentre una pagina dinamica è la pagina che mostra un singolo
 post, ed ovviamente cambia nel contenuto in funzione dell'articolo scelto.
\end_layout

\end_inset

 Il metodo find_link ricerca un collegamento all'interno della pagina in
 funzione dell'identificatore degli elementi HMTL 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 o del testo visualizzato.
 Come per le altre varianti dei metodi find* in Finders, il metodo find_link
 lancia un eccezione nel caso in cui la ricerca non dovesse individuare
 esattamente un'elemento.
 Per completare l'evento, semplicemente si invoca il metodo 
\begin_inset Quotes eld
\end_inset

click
\begin_inset Quotes erd
\end_inset

 sul nodo restituito.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A differenza del passo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Implementazione \"apro RBlog\""

\end_inset

, dove il comportamento non varia in funzione di parametri, nel passo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:evento naviga verso"

\end_inset

 viene selezionato il collegamento che coincide con il valore di 
\begin_inset Quotes eld
\end_inset

page_name
\begin_inset Quotes erd
\end_inset

, tramite un blocco con un singolo parametro.
 Il plugin di Cucumber per RubyMine per ogni passo che contiene del testo
 fra virgolette, genera dei blocchi parametrici automaticamente.
 E' possibile applicare lo stesso procedimento manualmente, sostituendo
 all'interno dell'espressione del passo un proprio pattern e aggiungendo
 un parametro a cui attribuire il valore.
 I parametri all'interno dei passi hanno tipo stringa, ma è possibile definire
 delle trasformazioni per convertire il valore ad un nuovo tipo tramite
 il metodo Transform.
\begin_inset Foot
status open

\begin_layout Plain Layout
Per maggiori dettagli consultare la documentazione di Cucumber 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.relishapp.com/cucumber/cucumber/docs/transforms
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Definizione delle asserzioni con RSpec
\end_layout

\begin_layout Standard
RSpec è un framework per il testing scritto in Ruby, le cui funzionalità
 sono suddivise in quattro moduli:
\end_layout

\begin_layout Itemize
RSpec-Core fornisce la struttura per la definizione di funzionalità e scenari
 per il BDD;
\end_layout

\begin_layout Itemize
RSpec-Expectations è una libreria di metodi per definire asserzioni;
\end_layout

\begin_layout Itemize
RSpec-Mocks è un framework per l'implementazione di stub, oggetti mock,
 verifiche sull'invocazione dei metodi e dell'interazione fra oggetti;
\end_layout

\begin_layout Itemize
RSpec-Rails è un framework per la definizione di test sulle componenti che
 definiscono un'applicazione RoR, come il modello, i controlli e le viste
 ma anche gli aiutanti e l'instradamento delle richieste.
\end_layout

\begin_layout Standard
All'interno della libreria di Capybara non sono presenti le funzionalità
 per la verifica di asserzioni, è quindi necessario sfruttare librerie terze.
 Oltre a RSpec è possibile l'integrazione all'interno di unit-test, Test::Unit
\begin_inset Foot
status open

\begin_layout Plain Layout
Maggiori informazioni per la definizione di test in Rails sono disponibili
 alla pagina 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html
\end_layout

\end_inset

.
\end_layout

\end_inset

 in Rails, oppure con le asserzioni definite in MiniTest::Spec
\begin_inset Foot
status open

\begin_layout Plain Layout
Maggiori informazioni sono contenute alla pagina del progetto 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/metaskills/minitest-spec-rails
\end_layout

\end_inset

.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La struttura di un'asserzione in RSpec è definita da due elementi: l'oggetto
 da verificare ed uno o più matcher, concatenati da operatori logici.
\begin_inset Foot
status open

\begin_layout Plain Layout
La maggior parte dei matcher di RSpec prevedono la verifica di una singola
 proprietà, ma esistono anche matcher compositi con arietà variabile.
 La lista completa è consultabile sulla documentazione ufficiale 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.relishapp.com/rspec/rspec-expectations/v/3-1/docs/composing-matchers
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dalla versione 2.11 di RSpec, la versione corrente è la 3.1.0, è stata modificata
 la sintassi del metodo 
\begin_inset Quotes eld
\end_inset

expect
\begin_inset Quotes erd
\end_inset

 per renderla più leggibile e versatile.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

expect(obj).not_to <matcher>
\end_layout

\begin_layout Plain Layout

expect{ ...
 }.to <matcher>
\end_layout

\begin_layout Plain Layout

expect do
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

end.to <matcher>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Sintassi del metodo 
\begin_inset Quotes eld
\end_inset

expect
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo accetta un singolo parametro, sia esso un oggetto o un blocco,
 invocato durante l'esecuzione del metodo, che viene verificato dai matcher
 indicati.
\end_layout

\begin_layout Standard
Un matcher in RSpec è un metodo e fornisce un risultato booleano in funzione
 dell'operazione implementata.
 L'uso corretto dei matcher è come argomenti dei metodi 
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

not_to
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Then(/^posso visitare la pagina dell'autore$/) do 
\end_layout

\begin_layout Plain Layout

	expect(find_link('Autore').visible?).to be_truthy 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica la presenza del link
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset

 richiede la possibilità di navigare verso la pagina statica dell'autore.
 L'asserzione è stata implementata sfruttando le funzionalità di Capybara,
 per individuare il collegamento in funzione del testo mostrato e ottenere
 la visibilità del nodo, e RSpec con il matcher 
\begin_inset Quotes eld
\end_inset

be_truthy
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Then(/^la pagina è intitolata "([^"]*)"$/) do |title_value|
\end_layout

\begin_layout Plain Layout

	expect(page.title).to eq(title_value)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione di un'asserzione parametrica.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nello scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset

 è richiesto il confronto di un parametro, definito attraverso l'espressione
 regolare, ed il titolo della pagina.
\begin_inset Foot
status open

\begin_layout Plain Layout
Capybara::DSL::page è un getter e restituisce la sessione correntemente
 sotto test.
 Una sessione in Capybara rappresenta l'interazione dell'utente con il sistema,
 maggiori dettagli sono presenti nella relativa sezione.
\end_layout

\end_inset

 In RSpec esistono tre matcher per la verifica dell'uguaglianza.
 
\begin_inset Quotes eld
\end_inset

equal?
\begin_inset Quotes erd
\end_inset

 verifica se le variabili si riferiscono allo stesso oggetto, 
\begin_inset Quotes eld
\end_inset

eql?
\begin_inset Quotes erd
\end_inset

 effettua un confronto sullo stato dell'istanza mentre l'operatore 
\begin_inset Quotes eld
\end_inset

==
\begin_inset Quotes erd
\end_inset

 confronta sia il tipo degli oggetti che i relativi stati, sfruttando eventuali
 conversioni.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Given(/^apro RBlog$/) do
\end_layout

\begin_layout Plain Layout

	visit steps_helper.rblog_url
\end_layout

\begin_layout Plain Layout

	expect(page.status_code).to be == 200
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro RBlog\"-1"

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro RBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tramite il matcher 
\begin_inset Quotes eld
\end_inset

be
\begin_inset Quotes erd
\end_inset

 è possibile utilizzare gli operatori definiti in Ruby.
 Nel frammento di codice è verificato che lo stato HTTP sia equivalente
 a 200, che corrisponde alla corretta terminazione della richiesta.
\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
Obbiettivo
\end_layout

\begin_layout Standard
Sfruttare ATDD per verificare l'Accessibilità
\end_layout

\begin_layout Standard
Principi di accessibilità
\end_layout

\begin_layout Subsection
SCSS
\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Itemize
Tag per la pulizia piuttosto che sfruttare un una gemma come FactoryGirl
 o DatabaseCleaner - http://www.railsonmaui.com/tips/rails/capybara-phantomjs-polt
ergeist-rspec-rails-tips.html - http://robots.thoughtbot.com/how-we-test-rails-appl
ications
\end_layout

\begin_layout Standard
Nella definizione degli scenari è conveniente utilizzare uno stile che favorisca
 sia lo sviluppatore, che ha il compito di scrivere e mantenere i test di
 accettazione, sia per il product owner, che tramite gli scenari può seguire
 lo sviluppo del prodotto.
\end_layout

\begin_layout Standard
Gli scenari devono essere indipendenti fra loro, l'ordine di esecuzione
 non deve inficiare il risultato.
 Mantenere delle dipendenze funzionali all'interno nella libreria di testing
 può introdurre diverse problematiche all'aumentare della cardinalità e
 della complessità o alla variazione dello condizioni d'esecuzione, introducendo
 ad esempio l'esecuzione in parallelo di più scenari.
\end_layout

\begin_layout Standard
Per semplificare la lettura degli scenari ed il riuso dei passi è conveniente
 sfruttare il prefisso 
\begin_inset Quotes eld
\end_inset

And
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Definizione delle viste
\end_layout

\begin_layout Standard
find, find_link, find_content, xpath, contesto di ricerca
\end_layout

\begin_layout Standard
metodi sulla pagina
\end_layout

\begin_layout Section
Introduzione della funzionalità di ricerca
\end_layout

\begin_layout Standard
http://www.rubydoc.info/github/jnicklas/capybara/Capybara/Node/Finders#find-instan
ce_method
\end_layout

\begin_layout Standard
Asincronia in Capybara https://blog.codecentric.de/en/2013/08/cucumber-capybara-po
ltergeist/
\end_layout

\begin_layout Section
Introduzione dell'autenticazione
\end_layout

\begin_layout Section
Le sessioni in Capybara
\end_layout

\begin_layout Section
Mantenibilità degli Acceptance Tests
\end_layout

\begin_layout Standard
http://www.elabs.se/blog/15-you-re-cuking-it-wrong
\end_layout

\begin_layout Standard
http://eggsonbread.com/2010/09/06/my-cucumber-best-practices-and-tips/
\end_layout

\begin_layout Standard
https://blog.engineyard.com/2009/15-expert-tips-for-using-cucumber
\end_layout

\begin_layout Standard
http://blog.codeship.io/2013/05/21/testing-tuesday-6-top-5-cucumber-best-practices.
html
\end_layout

\begin_layout Standard
https://github.com/strongqa/howitzer/wiki/Cucumber-Best-Practices
\end_layout

\begin_layout Section
Conclusione
\end_layout

\end_body
\end_document
