#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass classicthesis
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package babel
\inputencoding default
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter courier
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "breaklines=true,frame=tb,captionpos=t,frameround=f,showlines=true,numbers=left,stepnumber=1,numbersep=10pt,numberstyle={\small\color{gray}\ttfamily\scriptsize},tabsize=2,language=Ruby,alsolanguage=HTML,basicstyle={\ttfamily\scriptsize}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Ruby On Rails
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:rubyonrails"

\end_inset


\end_layout

\begin_layout Section
Introduzione a RoR
\end_layout

\begin_layout Enumerate
Perchè Rails, rimando ad articolo
\end_layout

\begin_layout Subsection
Ruby
\end_layout

\begin_layout Standard
Ruby è un linguaggio di programmazione open-source, general-purpose e orientato
 agli oggetti ideato da Yukihiro Matsumoto.
 La prima pubblicazione del linguaggio risale al 1995 ed attualmente è alla
 versione 2.1.
 Ruby è fortemente orientato alla produttività, permette di scrivere codice
 essenziale, con un netto risparmio di linee di codice rispetto a linguaggi
 tipati staticamente come Java o C# e offre una sintassi ricca e versatile.
 
\end_layout

\begin_layout Standard
La comunità di Ruby è estremamente attiva e contribuisce in maniera attiva
 all'individuazione di bug e al miglioramento continuo del linguaggio.
 Non è l'obbietto di questa tesi approfondire le caratteristiche di Ruby,
 ma ritengo sia utile fornire qualche riferimento per l'apprendimento del
 linguaggio.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\emph on
«Se intraprendete lo studio di un kōan e vi ci dedicate senza interrompervi,
 scompariranno i vostri pensieri e svaniranno i bisogni dell'io.
 » 
\emph default
(Hakuin, Orategama)
\emph on

\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
I Ruby Koans
\begin_inset Foot
status open

\begin_layout Plain Layout
I Koans sono disponibili su 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://rubykoans.com/
\end_layout

\end_inset

.
\end_layout

\end_inset

, 
\begin_inset Quotes eld
\end_inset

koan
\begin_inset Quotes erd
\end_inset

 è la pronuncia giapponese dei caratteri cinesi, sono una raccolta di esercizi
 su Ruby e permettono lo studio del linguaggio comprendendo esempi guidati
 su costrutti sintattici, elementi semantici e strutture dato.
 L'utente avanza nell'apprendimento in puro stile TDD, in maniera semplice
 e graduale.
 Terminato il corso si acquisisce una buona consapevolezza del linguaggio
 e confidenza con lo stile di Ruby.
\end_layout

\begin_layout Standard
Sempre nello stile tracciato da i koan, tenuti in massima considerazione
 all'interno della comunità di Ruby, ho approfondito la conoscenza del linguaggi
o e di RoR tramite il portale Ruby Monk
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rubymonk.com/
\end_layout

\end_inset


\end_layout

\end_inset

 che fornisce numerosi tutorial interattivi ed esercizi riassuntivi per
 ogni argomento; ogni lezione è completabile attraverso il proprio browser
 internet e fornisce numerosi consigli e indicazioni allo studente.
\end_layout

\begin_layout Subsection
Don't Repeat Yourself
\end_layout

\begin_layout Standard
Il principio di mantenere il proprio senza ripetizioni e ben fattorizzato
 è un'ottima pratica di programmazione.
 Un progetto DRY permette agli sviluppatori di modificare il codice più
 semplicemente; una funzionalità descritta in un numero ridotto di unità
 di compilazioni e ben fattorizzata è facilmente individuabile, correggibile
 e modificabile senza incorrere in modifiche involontarie ad altre parti
 del sistema.
\end_layout

\begin_layout Standard
RoR fornisce differenti funzionalità, quali librerie, helpers e viste parziali,
 per aiutare lo sviluppatore a definire applicazioni DRY.
\begin_inset Newline newline
\end_inset

Nell'implementazione delle viste è comune che alcuni elementi siano presenti
 più volte all'interno della stessa applicazione o anche all'interno della
 stessa pagina.
 In RoR è possibile definire delle viste parziali per fattorizzare al meglio
 queste porzioni di codice.
 Per rendere ancora più efficace questo meccanismo di fattorizzazione e
 definire dei comportamenti dinamici, è possibile passare al metodo 
\begin_inset Quotes eld
\end_inset

render
\begin_inset Quotes erd
\end_inset

 dei parametri.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= render 
\end_layout

\begin_layout Plain Layout

	:partial => 'posts/logged_user_post_actions',
\end_layout

\begin_layout Plain Layout

	:locals => {
\end_layout

\begin_layout Plain Layout

		:current_user => current_user,
\end_layout

\begin_layout Plain Layout

		:post => post
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

%>
\begin_inset Caption Standard

\begin_layout Plain Layout
Utilizzo di una visita parziale con il metodo 
\begin_inset Quotes eld
\end_inset

render
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<% if current_user %>
\end_layout

\begin_layout Plain Layout

	<div class='post_actions'>
\end_layout

\begin_layout Plain Layout

		<%= edit_post_image_link post %>
\end_layout

\begin_layout Plain Layout

		<%= remove_post_image_link post %>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

<% end %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Vista parziale.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre, data una vista parziale che visualizza un singolo elemento, è anche
 possibile passare al metodo render una collezione di oggetti sulla quale
 iterare, fornendo opzionalmente anche un separatore.
\begin_inset Foot
status open

\begin_layout Plain Layout
I metodi e le librerie in RoR tipicamente si prestano ad una grande varietà
 di usi e comportamenti, per una descrizione più precisa è possibile consultare
 la documentazione online.
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://api.rubyonrails.org/classes/ActionView/PartialRenderer.html
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La piattaforma RoR fornisce anche numerosi Helper: elementi utilizzati per
 fattorizzare metodi di utilità all'interno di moduli.
 Gli aiutanti in RoR sono sfruttati da tutte le componenti dell'architettura
 MVC e sono utili per gestire problematiche classiche dello sviluppo di
 applicazioni web: la gestione di file, formattazione di date, gestione
 di form e generazione del relativo codice HTML sono solo alcuni dei problemi
 risolvibili tramite gli helper presenti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= truncate(post.body, :length => 500, :separator => ' ', :omission => '...')
 %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Il metodo 'truncate', appartenente al modulo TextHelper.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come già osservato durante l'uso delle viste parziali, le librerie di sistema
 sono ricche di parametri opzionali, spesso permettono l'uso di blocchi
 definiti dall'utente e sono ben documentate: ogni metodo presente è ampiamente
 descritto anche tramite esempi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= form_for(@post) do |f| %>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	<div id="title_field">
\end_layout

\begin_layout Plain Layout

	<%= f.label :title, 'Titolo' %>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	<%= f.text_field :title, :size => 50 %>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

<% end %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Un esempio dell'uso delle funzionalità di FormHelper.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' altrettanto semplice definire i propri Helper: per ogni Controller definito
 dall'utente è incluso di default il relativo Helper, ad esempio in RBlog
 la classe PostsController include il modulo personalizzato PostsHelper
 in maniera automatica, senza necessità di configurarne l'uso e la visibilità
 all'interno del progetto.
\end_layout

\begin_layout Subsection
Convention Over Configuration
\end_layout

\begin_layout Standard
RoR definisce un insieme di convenzioni per semplificare l'uso e la configurazio
ne della piattaforma da parte dello sviluppatore.
 Per minimizzare il tempo richiesto per la messa a punto di un nuovo progetto,
 è utile seguire le convenzioni proposte, ordinando il codice in cartelle
 secondo le diverse funzionalità, aderendo alle convenzioni di denominazione
 dei file e degli attributi presenti nel modello.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ovviamente non è possibile prescindere completamente dall'uso di alcuni
 file di configurazione, ma RoR facilita ulteriormente la definizione di
 questi file codificandoli con YAML
\begin_inset Foot
status open

\begin_layout Plain Layout
Per informazioni su YAML si rimanda al sito ufficiale.
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.yaml.org/
\end_layout

\end_inset


\end_layout

\end_inset

, un formato di serializzazione facilmente leggibile e scrivibile, e Ruby
 stesso.
 Lo sviluppatore inoltre può anche sfruttare i numerosi tool a linea di
 comando per la prima generazione delle risorse, utili anche per avere una
 traccia contenente le impostazioni più plausibili per una nuova applicazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

default: &default
\end_layout

\begin_layout Plain Layout

adapter: postgresql
\end_layout

\begin_layout Plain Layout

encoding: unicode
\end_layout

\begin_layout Plain Layout

host: localhost
\end_layout

\begin_layout Plain Layout

pool: 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

development:
\end_layout

\begin_layout Plain Layout

<<: *default
\end_layout

\begin_layout Plain Layout

database: rblog_development
\end_layout

\begin_layout Plain Layout

username: xblog
\end_layout

\begin_layout Plain Layout

password: ...
\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento in YAML relativo alla configurazione del modello.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
L'interpretazione di RoR del pattern MVC
\end_layout

\begin_layout Subsubsection
Il modello
\end_layout

\begin_layout Standard
L'interpretazione di RoR del modello dell'architettura MCV prende spunto
 dal patter Active Record introdotto da Martin Fowler.
 I record attivi introducono un livello di astrazione fra i dati mantenuti
 nel modello ed i controlli che gestiscono e manipolano il dominio; le tuple
 nei database sono astratte ad oggetti aventi sia le informazioni che li
 caratterizzano, ad esempio i diversi attributi e le relazioni con altri
 tipi di dato presenti nel dominio, sia i metodi d'istanza che ne descrivono
 il comportamento.
\end_layout

\begin_layout Standard
Il database, ed in generale qualunque sistema garantisca la persistenza
 della nostra applicazione, non è acceduto direttamente ma tramite il processo
 ORM, acronimo per Object-Relational Mapping.
 Questa tecnica minimizza, se non addirittura elimina, la necessita di eseguire
 codice nativo, come query SQL, per manipolare il dominio.
 L'uso del pattern Active Record permette a RoR delineare in maniera netta
 la separazione fra modello e controlli.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre alla rappresentazione dei dati, gli Active Record estendono le funzionalit
à del modello con relazioni di ereditarietà fra i tipi esistenti, permettono
 la validazione attraverso l'invocazione di metodi e la definizione interrogazio
ni attraverso una libreria di sistema.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@posts = Post
\end_layout

\begin_layout Plain Layout

			.where('title like ?', "#{params[:search]}%")
\end_layout

\begin_layout Plain Layout

			.order('created_at DESC')
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Esecuzione di una semplice query in Ruby.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
I controlli
\end_layout

\begin_layout Standard
Essendo i controlli gli elementi di interconnessione fra il modello e le
 viste è difficile per lo sviluppatore mantenerne l'implementazione semplice.
 Proprio per semplificare la definizione ed il mantenimento sono presenti
 alcuni accorgimenti in RoR.
\end_layout

\begin_layout Standard
La configurazione delle richieste instradabili è specificata in file separato
 
\begin_inset Quotes eld
\end_inset


\emph on
routes.rb
\emph default

\begin_inset Quotes erd
\end_inset

, all'interno del quale è possibile configurare le richieste HTTP soddisfabili
 e definire una gerarchia delle entità manipolate dall'applicazione secondo
 i principi delle architetture REST, acronimo per REpresentational State
 Transfer.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources :posts do
\end_layout

\begin_layout Plain Layout

	get :autocomplete_title, :on => :collection
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

resources :sessions, :only => [:new, :create, :destroy]
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del file 
\begin_inset Quotes eld
\end_inset

routes.rb
\begin_inset Quotes erd
\end_inset

 relativo ai controlli di post e sessioni.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un altro accorgimento apprezzato durante lo sviluppo è la possibilità di
 definire dei filtri per i controlli.
 Per ogni controllo sono previsti alcuni stati a cui è possibili attribuire
 eventi, i filtri per l'appunto.
 Sfruttando questa semplice tecnica è possibile fattorizzare alcuni comportament
i comuni all'interno dei controlli di una stessa entità, come ad esempio
 la verifica delle autorizzazioni per alcune operazioni sensibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

before_action
\end_layout

\begin_layout Plain Layout

	:require_login,
\end_layout

\begin_layout Plain Layout

	only: [:new, :create, :edit, :update, :destroy]
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
L'uso dei filtri in RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Le viste
\end_layout

\begin_layout Standard
Le viste in RoR sono definibili introducendo nei file HTML elementi dinamici
 contenenti espressioni scritte in Ruby.
 ERB, acronimo per Embedded Ruby, permette l'inserimento di codice da processare
 all'interno del server web prima di fornire la risposta al client.
\end_layout

\begin_layout Standard
La definizione di viste dinamiche risulta immediata, è necessario apprendere
 le funzionalità di pochi tag utilizzati, che variano esclusivamente nel
 tipo di output generato.
\begin_inset Foot
status open

\begin_layout Plain Layout
Per maggiori informazioni relative alle viste e alla definizione di pagine
 dinamiche tramite ERB si rimanda alla seguente guida: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/layouts_and_rendering.html
\end_layout

\end_inset


\end_layout

\end_inset

 Le viste scritte tramite ERB sono facilmente leggibili grazie alle caratteristi
che di Ruby
\begin_inset Foot
status open

\begin_layout Plain Layout
Ogni espressione ha un valore.
 Il valore di ritorno delle funzioni e dei metodi è dato dall'ultima espressione
 eseguita.
 Le parentesi sono opzionali ed anche i parametri possono esserlo.
\end_layout

\end_inset

 e alle numerose funzionalità presenti negli Helper e nelle librerie del
 linguaggio.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class='post'>
\end_layout

\begin_layout Plain Layout

	<p class='post_title'>
\end_layout

\begin_layout Plain Layout

		<%= link_to @post.title, @post %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

	<p class='post_detail'>
\end_layout

\begin_layout Plain Layout

		<%= author_detail(@post) %>
\end_layout

\begin_layout Plain Layout

		</br>
\end_layout

\begin_layout Plain Layout

		<% post_details(@post).each do |detail| %>
\end_layout

\begin_layout Plain Layout

			<%= detail %>
\end_layout

\begin_layout Plain Layout

		<% end %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

    <p class='post_content'>
\end_layout

\begin_layout Plain Layout

		<%= @post.body %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

	<%= render 
\end_layout

\begin_layout Plain Layout

		:partial => 'logged_user_post_actions',  
\end_layout

\begin_layout Plain Layout

		:locals => {:current_user => current_user, :post => @post}
\end_layout

\begin_layout Plain Layout

	%>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento di vista relativo alla visualizzazione di un singolo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Il testing
\end_layout

\begin_layout Standard
Tramite RoR è possibile gestire l'intero stack di un'applicazione web, test
 inclusi.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html
\end_layout

\end_inset


\end_layout

\end_inset

 Sfruttando il framework RSpec, standard de-facto in Ruby, è possibile testare
 il modello attraverso i record attivi ed anche verificare i propri controller,
 definendo i parametri HTTP e dati.
 RSpec fornisce molte funzionalità, un'analisi più approfondita è effettuata
 nelle sezioni relative all'implementazione dei test di accettazione.
\end_layout

\begin_layout Standard
Da Ruby 1.9 è anche incluso la libreria MiniTest, che fornisce le funzionalità
 per arricchire i propri test con delle callback da applicare a differenti
 stati dell'esecuzione della libreria di test, introduce oggetti 
\begin_inset Quotes eld
\end_inset


\emph on
mock
\emph default

\begin_inset Quotes erd
\end_inset

, consente di effettuare misurazioni delle prestazioni e molto altro.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/seattlerb/minitest
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Paragonabili alla annotazioni 
\emph on
@After
\emph default
, 
\emph on
@Before
\emph default
, 
\emph on
@AfterClass
\emph default
 e 
\emph on
@BeforeClass
\emph default
 in JUnit 4.x.
\end_layout

\end_inset

 Esistono numerose gemme sviluppate da terze parti per aggiungere funzionalità
 e semplificare il processo di testing, ad esempio per la pulizia dei database
 utilizzati DatabaseCleaner
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/DatabaseCleaner/database_cleaner
\end_layout

\end_inset


\end_layout

\end_inset

 è molto diffusa, al pari di Factory Girl
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/thoughtbot/factory_girl
\end_layout

\end_inset


\end_layout

\end_inset

 per la popolazione del modello.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
E' anche previsto che il modello sia presente in tre versioni, -test, sviluppo
 e produzione- al fine di concedere allo sviluppatore la libertà di eseguire
 test sulle nuove funzionalità senza dover effettuare continui backup dei
 dati ed assumere altre precauzioni.
\begin_inset Newline newline
\end_inset

Rail fornisce inoltre il comando Rake per poter gestire al meglio l'esecuzione
 selettiva delle proprie librerie di test.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html##rake-tasks-for-running-your-tests
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
L'obbiettivo di questa tesi non è l'uso approfondito di RoR e delle sue
 funzionalità, ma durante l'implementazione del blog sono state notate alcune
 peculiarità del framework e del suo 
\begin_inset Quotes eld
\end_inset


\emph on
ecosistema
\emph default

\begin_inset Quotes erd
\end_inset

 che hanno contribuito affinché lo sviluppo si svolgesse in maniera lineare,
 concentrando l'attenzione sui test di accettazione piuttosto che a problematich
e di contorno.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A differenza di altre piattaforme, in cui sono presenti strumenti esterni
 per supportare la compilazione e la risoluzione delle dipendenze come Maven
 e Gradle, Ruby introduce le gemme.
 Ogni gemma rappresenta una libreria ed è definita attraverso nome, versione
 ed architettura di riferimento.
 
\end_layout

\begin_layout Standard
Ogni applicazione in RoR è caratterizzata da un Gemfile, un semplice script
 in Ruby che rappresenta l'insieme delle dipendenze del progetto.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rubygems.org/
\end_layout

\end_inset

 è il servizio di hosting di riferimento.
\end_layout

\end_inset

 E' possibile indicare quali librerie includere in funzione del tipo di
 compilazione adottata, rilascio, sviluppo o test, e delegando la verifica
 di aggiornamenti per librerie di terze parti al sistema.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

source 'https://rubygems.org'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

group :development, :test do
\end_layout

\begin_layout Plain Layout

	gem 'cucumber-rails', :require => false
\end_layout

\begin_layout Plain Layout

	gem 'rspec-rails'
\end_layout

\begin_layout Plain Layout

	gem 'capybara'
\end_layout

\begin_layout Plain Layout

	gem 'poltergeist'
\end_layout

\begin_layout Plain Layout

	gem 'database_cleaner'
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del Gemfile di RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fra le gemme utilizzate, la più preziosa
\begin_inset Marginal
status open

\begin_layout Plain Layout
:)
\end_layout

\end_inset

 è Spring.
 La libreria permette di caricare in anticipo le modifiche fatte al codice
 sorgente dell'applicazione in maniera che sia sempre in esecuzione la versione
 più recente, evitando all'utente di dover riavviare l'esecuzione manualmente
 ad ogni cambiamento.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nel contesto di sviluppo di applicazioni MVC è facile introdurre delle discrepan
ze fra il modello e la rappresentazione delle entità all'interno dell'applicazio
ne, soprattutto sfruttando strumenti di versionamento che offrono operazioni
 equivalenti alla 
\begin_inset Quotes eld
\end_inset


\emph on
revert
\emph default

\begin_inset Quotes erd
\end_inset

 in Git.
 
\end_layout

\begin_layout Standard
In RoR è previsto il meccanismo delle migrazioni che fornisce un meccanismo
 per mantenere lo schema del modello consistente durante il processo di
 sviluppo.
 Ogni variazione alla struttura del modello è tradotto in una migrazione,
 un breve script in Ruby, in cui sono definite le operazioni compiute a
 basso livello, come l'aggiunta di colonne, la rimozione di un vincolo etc.;
 le informazioni sulle migrazioni sono mantenute nel modello e tengono traccia
 dei cambiamenti apportati e dello stato attuale dello schema, permettendo
 di mantenere tutte le componenti dell'architettura MVC consistenti fra
 loro.
\end_layout

\begin_layout Section
RubyMine
\end_layout

\begin_layout Standard
Per lo sviluppo di RBlog e la definizione dei test di accettazione è stato
 utilizzato RubyMine, alla versione 6.3.
 L'IDE prodotto da JetBrains, sviluppatori anche di IntelliJ IDEA, Android
 Studio, ReSharper per citare i più conosciuti, supporta le feature più
 recenti di Rails e Ruby, rispettivamente alla versione 4.1 e 2.1.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'esperienza con RubyMine è stata ottima: durante lo sviluppo sono stati
 rilevati raramente problemi, funzionalità a riga di comando offerte da
 Rails sono integrate integra perfettamente e sono supportati molti linguaggi,
 come HTML, JavaScript, JQuery, CoffeeScript, SCSS.
\end_layout

\begin_layout Standard
Nell'IDE sono presenti diversi plugin per l'integrazione con strumenti di
 terzi, come ad esempio Cucumber, Git
\begin_inset Foot
status open

\begin_layout Plain Layout
Sono inclusi diversi plugin per il supporto sistemi di versionamento: attualment
e sono disponibili CVS, Git, Subversion, Mercurial e Perforce.
\end_layout

\end_inset

 e SSH.
 RubyMine è un prodotto curato nei dettagli, professionale ed allo stesso
 tempo adatto anche agli utenti alle prime armi; permettendo l'implementazione
 di un'applicazione in Rails praticamente senza abbandonare l'ambiente di
 sviluppo.
\end_layout

\begin_layout Section
Hello RBlog!
\end_layout

\begin_layout Standard
L'obbiettivo di questa prima funzionalità è minimo, è necessario che l'applicazi
one sia in esecuzione ed il sito web raggiungibile.
 Inoltre il blog deve consentire la navigazione verso alcune pagine statiche.
\begin_inset Foot
status open

\begin_layout Plain Layout
Una pagina web statica è una pagina web i cui contenuti sono formattati
 direttamente in HTML, e non subiscono modifiche in funzione dello stato
 attuale dell'applicazione.
 Al contrario le pagine dinamiche rappresentano lo stato di una o più entità
 presente all'interno del sito e possono variare nel tempo.
 In RBlog un esempio di pagina statica è la pagina che descrive l'abstract
 del progetto, mentre una pagina dinamica è la pagina che mostra un singolo
 post, ed ovviamente cambia nel contenuto in funzione dell'articolo scelto.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cucumber
\end_layout

\begin_layout Standard
Il primo tassello necessario per l'implementazione dei test di accettazione
 su un'applicazione web sviluppata in RoR è Cucumber.
\end_layout

\begin_layout Standard
Cucumber è un framework per il supporto al BDD, Behaviour Driven Development,
 e la definizione di test di accettazione.
 Il framework è disponibile anche in Java, .Net, Python, PHP e molti altri
 linguaggi e piattaforme.
\end_layout

\begin_layout Subsubsection
Le funzionalità
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:01x00 Hello RBlog!"

\end_inset

La prima feature di RBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo obbiettivo dei test di accettazione è di individuare le funzionalità
 da sviluppare, le caratteristiche e potenzialità che l'applicazione offre
 e i diversi scenari che le definiscono.
\end_layout

\begin_layout Standard
Le funzionalità in Cucumber sono elementi esclusivamente descrittivi, non
 sono utilizzate esplicitamente nell'implementazione dei test ma hanno lo
 scopo di far cogliere la giusta prospettiva al team di sviluppo e descrivere
 genericamente gli l'obbiettivo degli scenari.
 Sia il titolo che la descrizione possono essere in linguaggio naturale
 e non hanno alcun impatto nell'implementazione degli scenari, per lo sviluppo
 di RBlog sono state usate le user story secondo il formato 
\begin_inset Quotes eld
\end_inset


\emph on
Per
\emph default
 <beneficio>, 
\emph on
come
\emph default
 <ruolo>, 
\emph on
vorrei
\emph default
 <obbiettivo, desiderio>
\begin_inset Quotes erd
\end_inset

.
 Per facilitare lo sviluppo di test all'interno del proprio progetto è consiglia
to seguire la convenzione di inserire all'interno della cartella 
\begin_inset Quotes eld
\end_inset


\emph on
features
\emph default

\begin_inset Quotes erd
\end_inset

 i test di accettazione ed attribuire ai relativi file l'estenzione 
\begin_inset Quotes eld
\end_inset


\emph on
.feature
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nella funzionalità 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x00 Hello RBlog!"

\end_inset

, oltre alla descrizione della funzionalità è presente un etichetta che
 permette di organizzare e categorizzare quanto sviluppato con Cucumber;
 
\begin_inset Quotes eld
\end_inset


\emph on
@cap1
\emph default

\begin_inset Quotes erd
\end_inset

 caratterizza sia la user-story sia gli scenari che la definiscono per ereditari
et.
 L'etichetta è stata introdotta per poter eseguire in maniera selettiva
 gli scenari della prima funzionalità.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cucumber --tags @cap1
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Comando per l'esecuzione degli scenari relativi alla feature 
\begin_inset Quotes eld
\end_inset

Hello RBlog!
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' possibile introdurre un numero arbitrario di etichette per ciascuna funzional
ità o scenario e sfruttando l'opzione 
\begin_inset Quotes eld
\end_inset


\emph on
--tags
\emph default

\begin_inset Quotes erd
\end_inset

 definire il corretto insieme di test da eseguire, tramite gli operatori
 logici AND, OR e NOT.
\end_layout

\begin_layout Subsubsection
Gli scenari
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Visita alla pagina iniziale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Allora posso visitare la pagina dell'autore
\end_layout

\begin_layout Plain Layout

E posso visitare la pagina dell'abstract
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:01x01 Homepage"

\end_inset

Navigazione verso la pagina iniziale
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo scenario descrive la navigazione verso la homepage, relativo alla
 funzionalità 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x00 Hello RBlog!"

\end_inset

 ed introduce la sintassi di Cucumber.
 Gli scenario sono caratterizzati da un titolo, che riassume il comportamento
 e da un insieme di passi.
 Seguendo la logica del BDD, ogni passo può alternativamente essere di tipo
 
\begin_inset Quotes eld
\end_inset


\emph on
Given
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
When
\emph default

\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\emph on
Then
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Tramite i passi di tipo 
\begin_inset Quotes eld
\end_inset

Given
\begin_inset Quotes erd
\end_inset

 è possibile verificare che il sistema sia in uno stato prefissato e conosciuto
 all'utente, stato dal quale sarà possibile compiere le azioni descritte
 successivamente nel test.
 Rispetto ad uno use-case un passo 
\begin_inset Quotes eld
\end_inset

Given
\begin_inset Quotes erd
\end_inset

 è l'equivalente di una precondizione.
\end_layout

\begin_layout Standard
I passi 
\begin_inset Quotes eld
\end_inset

When
\begin_inset Quotes erd
\end_inset

 descrivono le azioni compiute dall'utente e permettono la transizione del
 sistema verso un nuovo stato, analogamente agli eventi di una macchina
 a stati.
\end_layout

\begin_layout Standard
Lo scopo dei passi 
\begin_inset Quotes eld
\end_inset

Then
\begin_inset Quotes erd
\end_inset

 è di osservare il risultato delle azioni compiute precedentemente.
 Le osservazioni dovrebbero essere consistenti con i benefici dichiarati
 per la funzionalità ed analizzare solo quanto è osservabile tramite l'interfacc
ia del sistema ed ottenuto come conseguenza alle azioni compiute.
 Ad esempio, non è compito dei test di accettazione su RBlog verificare
 le tuple della tabella Post nel modello.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La scelta del prefisso del passo non limita le potenzialità del passo stesso,
 ma ovviamente un uso corretto favorisce la leggibilità del test.
 E' anche possibile sfruttare i prefissi 
\begin_inset Quotes eld
\end_inset


\emph on
And
\emph default

\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\emph on
But
\emph default

\begin_inset Quotes erd
\end_inset

 per rendere i propri scenari più scorrevoli; alle congiunzioni è attribuito
 il tipo del passo precedente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Schema dello scenario: Visita alla pagina dell'autore e alla pagina dell'abstrac
t
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Quando navigo verso "<nome della pagina>"
\end_layout

\begin_layout Plain Layout

Allora la pagina è intitolata "<nome della pagina>"     
\end_layout

\begin_layout Plain Layout

E posso tornare alla pagina iniziale   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Esempi:
\end_layout

\begin_layout Plain Layout

| nome della pagina |
\end_layout

\begin_layout Plain Layout

| Autore            |
\end_layout

\begin_layout Plain Layout

| Abstract          |
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:01x02 Pagine statiche"

\end_inset

Navigazione verso le pagine statiche
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cucumber offre la possibilità di definire scenari parametrici.
 Sfruttando la sintassi 
\emph on

\begin_inset Quotes eld
\end_inset

Schema dello 
\emph default
scenario
\begin_inset Quotes erd
\end_inset

, la tabella 
\begin_inset Quotes eld
\end_inset


\emph on
Esempi
\emph default

\begin_inset Quotes erd
\end_inset

 e i delimitatori 
\begin_inset Quotes eld
\end_inset


\emph on
< >
\emph default

\begin_inset Quotes erd
\end_inset

 è possibile verificare tanti scenari quanti sono i parametri all'interno
 della tabella: lo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset

 è effettuato sia sulla pagina dell'autore che sulla pagina dell'abstract.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Visita alle pagine statiche: la pagina dell'autore e all'abstract
 della tesi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Quando navigo verso "Autore"
\end_layout

\begin_layout Plain Layout

Allora la pagina è intitolata "Autore"
\end_layout

\begin_layout Plain Layout

E posso tornare alla pagina iniziale
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Testo generato dallo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Business Readable DSL
\end_layout

\begin_layout Standard
Il linguaggio utilizzato per descrivere le funzionalità e gli scenari in
 Cucumber è Gherkin.
\begin_inset Foot
status open

\begin_layout Plain Layout
Maggiori informazioni relative alla sintassi sono reperibili alla pagina
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/cucumber/cucumber/wiki/Gherkin
\end_layout

\end_inset


\end_layout

\end_inset

 Gli autori, gli stessi di Cucumber, descrivono il linguaggio come Business
 Readable DSL, definizione introdotta da Martin Fowler nel 2008.
\begin_inset Foot
status open

\begin_layout Plain Layout
L'articolo completo di Fowler è consultabile sul suo blog 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://martinfowler.com/bliki/BusinessReadableDSL.html
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'obbiettivo principale di un Business Readable DSL è permettere la partecipazio
ne all'analisi e alla revisione del codice a figure non tecniche.
 Fowler sottolinea come sia più importante definire un linguaggio leggibile
 rispetto ad uno anche scrivibile, in quanto un Business Readable DSL sopperisce
 alla difficoltà di stabilire un canale di comunicazione arricchente fra
 le diverse parti che partecipano allo sviluppo.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsubsection
I18n
\end_layout

\begin_layout Standard
Cucumber supporta attualmente 40 lingue, numero in rapida crescita secondo
 gli sviluppatori.
\begin_inset Foot
status open

\begin_layout Plain Layout
Per ottenere la lista aggiornata delle lingue supportate è possibile eseguire
 il comando cucumber --i18n help o consultare la risorsa contenente il dizionari
o 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/cucumber/gherkin/blob/master/lib/gherkin/i18n.json
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Cucumber l'implementazione dei passi non è vincolata dal tipo definito,
 ad esempio è possibile sfruttare un'asserzione come invariante.
 Questa particolarità di Cucumber offre la possibilità di definire più librerie
 di test di accettazione in differenti lingue ed utilizzare lo stesso codice
 per l'implementazione dei passi.
 Una potenzialità simile può essere utile per documentare lo sviluppo di
 progetti che coinvolgono stake-holders di diverse nazionalità.
\end_layout

\begin_layout Subsubsection
Supporto a Cucumber in RubyMine
\end_layout

\begin_layout Standard
RubyMine, l'ambiente di sviluppo scelto per sviluppare tramite RoR, integra
 le funzionalità di Cucumber e assiste il programmatore nel corso dello
 sviluppo dei test: la sintassi di Gherkin è evidenziata, è presente l'auto-comp
letamento delle parole chiave del DSL, è possibile navigare dalla definizione
 all'implementazione del passo ed è fornita un'interfaccia grafica per l'esecuzi
one dei test, configurabile in funzione di tag, file delle funzionalità
 da includere ed altri parametri.
\end_layout

\begin_layout Subsection
Capybara
\end_layout

\begin_layout Standard
Capybara è una libreria in Ruby che permette la definizione di test di accettazi
one automatici per applicazioni web, non necessariamente scritte tramite
 RoR, simulando le azioni eseguibili via interfaccia grafica.
 
\end_layout

\begin_layout Standard
Capybara nasconde all'utente i dettagli tecnici della navigazione tramite
 primitive di funzioni semplici, intuitive e versatili.
 A differenza di Selenium, le cui primitive si interfacciano con aspetti
 a più basso livello, le funzionalità di Capybara sono astratte e mantengono
 la stessa prospettiva di un test effettuato manualmente da un utente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La configurazione di Capybara è effettuata tramite un breve script in Ruby
 dove è necessario impostare le proprie preferenze.
 Innanzitutto è necessario scegliere quale browser web sarà utilizzato ed
 il relativo driver per Capybara importando la libreria nel file 
\begin_inset Quotes eld
\end_inset


\emph on
features/support/env.rb
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

require 'cucumber/rails'
\end_layout

\begin_layout Plain Layout

require 'capybara'
\end_layout

\begin_layout Plain Layout

require 'capybara/cucumber'
\end_layout

\begin_layout Plain Layout

require 'capybara/rspec'
\end_layout

\begin_layout Plain Layout

require 'capybara/poltergeist'
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Dipendenze all'interno dello script di configurazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Infine, se necessario, è possibile configurare il driver scelto: la struttura
 di Capybara permette l'uso di diversi driver e browser, senza modificare
 le primitive offerte.
 Tutti i driver devono implementare le funzionalità obbligatorie indicate
 nella libreria, ma è consentito non fornire il resto delle operazioni ma
 essere comunque annoverati fra i driver esistenti per Capybara.
 Per RBlog è stato utilizzato Poltergeist.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Capybara.default_driver = :poltergeist
\end_layout

\begin_layout Plain Layout

Capybara.register_driver :poltergeist do |app|
\end_layout

\begin_layout Plain Layout

	options = { 			
\end_layout

\begin_layout Plain Layout

		:js_errors => true,
\end_layout

\begin_layout Plain Layout

		:timeout => 120,
\end_layout

\begin_layout Plain Layout

		:debug => true,
\end_layout

\begin_layout Plain Layout

		:phantomjs_options => ['--load-images=yes', '--disk-cache=false'],
\end_layout

\begin_layout Plain Layout

		:inspector => true,
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	Capybara::Poltergeist::Driver.new(app, options)
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
Configurazione di Poltergeist
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le opzioni più rilevanti per Poltergeist sono:
\end_layout

\begin_layout Itemize
:js_errors rileva ogni errore relativo alle esecuzione di codice JavaScript
 e genera un errore in Ruby;
\end_layout

\begin_layout Itemize
:inspector è un'opzione sperimentale che permette il debug dell'esecuzione
 tramite una terza applicazione, come ad esempio Chrome web inspector;
\end_layout

\begin_layout Itemize
:debug reindirizza l'output dell'esecuzione in modalità debug verso STDERR.
\end_layout

\begin_layout Subsection
PhantomJS
\end_layout

\begin_layout Standard
PhantomJS è un browser headless, ovvero supporta tutte le funzionalità di
 un browser web moderno ma senza possedere un'interfaccia grafica e si basa
 sul motore di rendering WebKit, lo stesso utilizzato da Chrome e Safari.
\end_layout

\begin_layout Standard
E' particolarmente adatto all'esecuzione automatica di applicazioni web
 in quanto non è necessario che il sistema sia dotato di un framework per
 la gestione di GUI, funzionalità spesso mancante sui server che effettuano
 l'integrazione continua.
\end_layout

\begin_layout Standard
Con PhantomJS è anche possibile far coincidere il fallimento dei propri
 test in funzione di errori su codice JavaScript, funzionalità non presente
 su altri browser, grazie all'opzione :js_errors precedentemente descritta.
\begin_inset Foot
status open

\begin_layout Plain Layout
PhantomJS è installabile tramite i pacchetti d'installazione presenti sul
 sito ufficiale 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://phantomjs.org/download.html
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Poltergeist
\end_layout

\begin_layout Standard
Poltergeist è un driver per il browser PhantomJS ed implementa la totalità
 delle funzionalità obbligatorie e molte delle opzionali disponibili.
 Dopo aver configurato il driver nel file 
\begin_inset Quotes eld
\end_inset

env.rb
\begin_inset Quotes erd
\end_inset

 tutte le operazioni saranno gestite tramite la libreria di Capybara.
\end_layout

\begin_layout Standard
La combinazione Capybara - Poltergeist - PhantomJS è attualmente una delle
 più diffuse per lo sviluppo di test di accettazione automatici perché da
 ottimi risultati nella gestione di strumenti asincroni come AJAX, è estremament
e veloce e molto accurata nella gestione di falsi positivi, come ad esempio
 il click su eventi esistenti nel DOM di una pagina HTML ma non visibili.
\begin_inset Foot
status open

\begin_layout Plain Layout
L'installazione di Poltergeist è effettuata attraverso il gemfile e la gemma
 
\begin_inset Quotes eld
\end_inset

poltergeist
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 
\begin_inset Foot
status open

\begin_layout Plain Layout
Quando viene richiesto il click su un elemento, Poltergeist non genera un
 evento attraverso il DOM ma simula un evento reale, ad esempio scendendo
 lungo la pagina nel caso in cui l'elemento non dovesse essere visibile.
 Inoltre sono previste diverse casistiche di errori, come l'impossibilità
 di compiere azioni su un elemento coperto.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
La struttura dei passi in Capybara è definita a priori e non varia in funzione
 del tipo implementato.
 Per implementare un passo è necessario creare uno script Ruby, ad esempio
 
\begin_inset Quotes eld
\end_inset

features/steps_definition/constraints.rb
\begin_inset Quotes erd
\end_inset

, e definirne l'implementazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Given(/^apro RBlog$/) do
\end_layout

\begin_layout Plain Layout

	visit steps_helper.rblog_url
\end_layout

\begin_layout Plain Layout

	#...
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro RBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro RBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sfruttando il metodo Given di Cucumber, in generale lo schema è valido anche
 per gli altri tipi disponibili, è possibile specificare un'espressione
 regolare ed il comportamento associato.
 All'esecuzione dei test, Cucumber verifica che sia presente un'implementazione
 per ogni passo definito ed esegue le istruzioni associate.
 E' necessario che per ogni passo in linguaggio naturale esista un'unica
 espressione regolare corrispondente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^apro (.*)$/) do |site_name|
\end_layout

\begin_layout Plain Layout

	#...
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Ipotetica implementazione ulteriore.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'introduzione di un'ulteriore implementazione, anche se con tipo differente,
 genere un'ambiguità che secondo il comportamento standard di Cucumber non
 è risolta.
\begin_inset Foot
status open

\begin_layout Plain Layout
Sfruttando l'opzione --guess di Cucumber è possibile far variare il comportament
o per la scelta dell'implementazione da applicare.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
La struttura di Capybara
\end_layout

\begin_layout Standard
L'implementazione di passo è definibile all'interno di un blocco
\begin_inset Foot
status open

\begin_layout Plain Layout
In Ruby è possibile attribuire ad ogni metodo un blocco contenente del codice
 da eseguire durante l'esecuzione.
 I blocchi sono paragonabili ad espressioni lambda, ma non sono elementi
 di prim'ordine del linguaggio.
\end_layout

\end_inset

 e non esiste alcuna limitazione né controllo riguardo alla tipologia di
 espressioni che vengono eseguite durante il passo.
\end_layout

\begin_layout Standard
In Capybara esistono numerose funzionalità per la gestione degli elementi,
 indicati come nodi del DOM.
 La gerarchia dei nodi è la seguente:
\end_layout

\begin_layout Itemize
la classe più semplice è Capybara::Node::Simple e rappresenta gli elementi
 di una pagina web, tali oggetti possono essere individuati all'interno
 del documento e analizzati in funzione degli attributi, ma non sono utilizzabil
i per compiere azioni;
\end_layout

\begin_layout Itemize
la classe Capybara::Node::Base è la classe padre di Element e Document:
 gli oggetti delle classi figlie condividono gli stessi metodi sfruttando
 i metodi presenti nei moduli Finders, Matchers e Actions.
 A differenza dei nodi semplici è quindi possibile compiere azioni su di
 essi;
\end_layout

\begin_layout Itemize
la classe Element rappresenta un singolo elemento all'interno del DOM della
 pagina;
\end_layout

\begin_layout Itemize
la classe Document rappresenta i documenti HTML nella loro interezza.
\end_layout

\begin_layout Standard
Le funzionalità di Capybara sono suddivise in tre moduli: Finders, Actions
 e Matchers.
\end_layout

\begin_layout Standard
Il modulo Finders contiene un insieme di funzionalità dedicate all'individuazion
e di nodi all'interno della pagina.
 I metodi sono suddivisi in funzione del tipo di elemento ricercato, come
 ad esempio find_button e find_link, e della cardinalità attesa.
 Il metodo 
\begin_inset Quotes eld
\end_inset

all
\begin_inset Quotes erd
\end_inset

 restituisce tutti gli elementi che soddisfano la ricerca a differenza dei
 metodi 
\begin_inset Quotes eld
\end_inset

find_*
\begin_inset Quotes erd
\end_inset

 dai quali è atteso l'individuazione di esattamente un nodo.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il modulo Actions permette l'interazione con l'interfaccia della pagina:
 sono quindi previsti, ad esempio, metodi per la compilazione di form HTML
 ed la selezione di elementi.
 Le operazioni permettono anche di specificare delle opzioni per effettuare
 delle variazioni o verificare alcune proprietà prima di compiere l'evento.
\begin_inset Foot
status open

\begin_layout Plain Layout
Il metodo click_link permette di specificare un l'opzione :href per verificare
 l'uguaglianza del attributo href prima di effettuare il click sul collegamento.
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Infine il modulo Matchers verifica le proprietà di un nodo, sia esso un
 sotto elemento della pagina o il documento stesso.
 Ad esempio è possibile verificare che sia presente un selettore, indicando
 l'identificatore css o una query XPath, o la presenza di attributo per
 l'elemento che invoca il metodo.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La libreria di Capybara è ricca di funzionalità e si presta in maniera versatile
 a diversi usi e preferenze.
 Per la maggior parte dei metodi è prevista la possibilità di specificare
 delle opzioni ed influire, in funzione della natura dell'operazione, sul
 comportamento di default.
 Inoltre, soprattutto all'interno del modulo Matchers, esistono diversi
 modi per definire le istruzioni, facilitando la scrittura dei test.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

page.title
\end_layout

\begin_layout Plain Layout

page[:title]
\end_layout

\begin_layout Plain Layout

page.has_title? "xyz"
\end_layout

\begin_layout Plain Layout

page.has_no_title? "zyx"
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Istruzioni equivalenti per l'accesso e verifica dell'attributo 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

 di una pagina HTML.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Navigare all'interno del sito
\end_layout

\begin_layout Standard
Nel passo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Implementazione \"apro RBlog\""

\end_inset

 è utilizzato il metodo 
\begin_inset Quotes eld
\end_inset

visit
\begin_inset Quotes erd
\end_inset

 che permette la navigazione verso una certa pagina web.
 All'esecuzione del metodo coincide una richiesta HTTP in GET all'indirizzo
 indicato come parametro, che può essere sia relativo che assoluto.
\begin_inset Foot
status open

\begin_layout Plain Layout
Il metodo rblog_url dell'oggetto denominato steps_helper, appartiene alla
 classe StepsHelper, utilizzata per contenere alcuni metodi d'utilità sfruttati
 durante lo sviluppo dei test.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^navigo verso "([^"]*)"$/) do |page_name|
\end_layout

\begin_layout Plain Layout

	find_link(page_name).click
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:evento naviga verso"

\end_inset

Navigazione nel sito, sfruttando il testo visualizzato di un link.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo visit, utilizzato per aprire la pagina iniziale del blog, non
 verifica la presenza all'interno della pagina di un collegamento verso
 la destinazione, ma semplicemente effettua la richiesta all'indirizzo indicato.
\end_layout

\begin_layout Standard
Per verificare la presenza di link alle pagine statiche nell'homepage è
 stato utilizzato il metodo 
\begin_inset Quotes eld
\end_inset

find_link
\begin_inset Quotes erd
\end_inset

.
 Il metodo find_link ricerca un collegamento all'interno della pagina in
 funzione dell'identificatore degli elementi HMTL 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 o del testo visualizzato.
 Come per le altre varianti dei metodi find* in Finders, il metodo find_link
 lancia un eccezione nel caso in cui la ricerca non dovesse individuare
 esattamente un'elemento.
 Per completare l'evento, semplicemente si invoca il metodo 
\begin_inset Quotes eld
\end_inset

click
\begin_inset Quotes erd
\end_inset

 sul nodo restituito.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A differenza del passo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Implementazione \"apro RBlog\""

\end_inset

, dove non sono presenti parametri, nel passo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:evento naviga verso"

\end_inset

 viene selezionato il collegamento che coincide con il valore di 
\begin_inset Quotes eld
\end_inset

page_name
\begin_inset Quotes erd
\end_inset

, tramite un blocco con un singolo parametro.
 Cucumber per ogni passo che contiene del testo fra virgolette, genera dei
 blocchi parametrici automaticamente.
 E' possibile applicare lo stesso procedimento manualmente, sostituendo
 all'interno dell'espressione del passo un proprio pattern e aggiungendo
 un parametro a cui attribuire il valore.
 I parametri all'interno dei passi hanno tipo stringa, ma è possibile definire
 delle trasformazioni per convertire il valore ad un nuovo tipo tramite
 il metodo Transform.
\begin_inset Foot
status open

\begin_layout Plain Layout
Per maggiori dettagli consultare la documentazione di Cucumber 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.relishapp.com/cucumber/cucumber/docs/transforms
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Definizione delle asserzioni con RSpec
\end_layout

\begin_layout Standard
RSpec è un framework per il testing scritto in Ruby, le cui funzionalità
 sono suddivise in quattro moduli:
\end_layout

\begin_layout Itemize
RSpec-Core fornisce la struttura per la definizione di funzionalità e scenari
 per il BDD;
\end_layout

\begin_layout Itemize
RSpec-Expectations è una libreria di metodi per definire asserzioni;
\end_layout

\begin_layout Itemize
RSpec-Mocks è un framework per l'implementazione di stub, oggetti mock,
 verifiche sull'invocazione dei metodi e dell'interazione fra oggetti;
\end_layout

\begin_layout Itemize
RSpec-Rails è un framework per la definizione di test sulle componenti che
 definiscono un'applicazione RoR, come il modello, i controlli e le viste
 ma anche gli aiutanti e l'instradamento delle richieste.
\end_layout

\begin_layout Standard
All'interno della libreria di Capybara non sono presenti le funzionalità
 per la verifica di asserzioni, è quindi necessario sfruttare librerie terze.
 Oltre a RSpec è possibile l'integrazione all'interno di unit-test, Test::Unit
\begin_inset Foot
status open

\begin_layout Plain Layout
Maggiori informazioni per la definizione di test in Rails sono disponibili
 alla pagina 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html
\end_layout

\end_inset

.
\end_layout

\end_inset

 in Rails, oppure con le asserzioni definite in MiniTest::Spec
\begin_inset Foot
status open

\begin_layout Plain Layout
Maggiori informazioni sono contenute alla pagina del progetto 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/metaskills/minitest-spec-rails
\end_layout

\end_inset

.
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La struttura di un'asserzione in RSpec è definita da due elementi: l'oggetto
 da verificare ed uno o più matcher, concatenati da operatori logici.
\begin_inset Foot
status open

\begin_layout Plain Layout
La maggior parte dei matcher di RSpec prevedono la verifica di una singola
 proprietà, ma esistono anche matcher compositi con arietà variabile.
 La lista completa è consultabile sulla documentazione ufficiale 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.relishapp.com/rspec/rspec-expectations/v/3-1/docs/composing-matchers
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dalla versione 2.11 di RSpec, la versione corrente è la 3.1.0, è stata modificata
 la sintassi del metodo 
\begin_inset Quotes eld
\end_inset

expect
\begin_inset Quotes erd
\end_inset

 per renderla più leggibile e versatile.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

expect(obj).not_to <matcher>
\end_layout

\begin_layout Plain Layout

expect{ ...
 }.to <matcher>
\end_layout

\begin_layout Plain Layout

expect do
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

end.to <matcher>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Sintassi del metodo 
\begin_inset Quotes eld
\end_inset

expect
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo accetta un singolo parametro, sia esso un oggetto o un blocco
 che viene verificato dai matcher indicati.
 Un matcher in RSpec è un metodo e fornisce un risultato booleano in funzione
 dell'operazione implementata e degli argomenti.
 L'uso corretto dei matcher è come parametri dei metodi 
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

not_to
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Then(/^posso visitare la pagina dell'autore$/) do 
\end_layout

\begin_layout Plain Layout

	expect(find_link('Autore').visible?).to be_truthy 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica la presenza del link
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset

 richiede la possibilità di navigare verso la pagina statica dell'autore.
 L'asserzione è stata implementata sfruttando le funzionalità di Capybara,
 per individuare il collegamento in funzione del testo mostrato e ottenere
 la visibilità del nodo, e RSpec con il matcher 
\begin_inset Quotes eld
\end_inset

be_truthy
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Then(/^la pagina è intitolata "([^"]*)"$/) do |title_value|
\end_layout

\begin_layout Plain Layout

	expect(page.title).to eq(title_value)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione di un'asserzione parametrica.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nello scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset

 è richiesto il confronto di un parametro, definito attraverso l'espressione
 regolare, ed il titolo della pagina.
\begin_inset Foot
status open

\begin_layout Plain Layout
Capybara::DSL::page è un getter e restituisce la sessione correntemente
 sotto test.
 Una sessione in Capybara rappresenta l'interazione dell'utente con il sistema,
 maggiori dettagli sono presenti nella relativa sezione.
\end_layout

\end_inset

 In RSpec esistono tre matcher per la verifica dell'uguaglianza: 
\begin_inset Quotes eld
\end_inset

equal?
\begin_inset Quotes erd
\end_inset

 verifica se le variabili si riferiscono allo stesso oggetto, 
\begin_inset Quotes eld
\end_inset

eql?
\begin_inset Quotes erd
\end_inset

 effettua un confronto sullo stato dell'istanza mentre l'operatore 
\begin_inset Quotes eld
\end_inset

==
\begin_inset Quotes erd
\end_inset

 confronta sia il tipo degli oggetti che i relativi stati, sfruttando eventuali
 conversioni.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Given(/^apro RBlog$/) do
\end_layout

\begin_layout Plain Layout

	visit steps_helper.rblog_url
\end_layout

\begin_layout Plain Layout

	expect(page.status_code).to be == 200
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro RBlog\"-1"

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro RBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tramite il matcher 
\begin_inset Quotes eld
\end_inset

be
\begin_inset Quotes erd
\end_inset

 è possibile utilizzare gli operatori definiti in Ruby.
 Nel frammento di codice è verificato che lo stato HTTP sia equivalente
 a 200, che corrisponde alla corretta terminazione della richiesta.
\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Feature: Introducendo il (S)CSS
\end_layout

\begin_layout Plain Layout

Per rendere l'esperienza di navigazione gradevole
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che il sito esponesse una grafica omogenea
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:02x00 Introducendo il CSS"

\end_inset

Seconda funzionalità per RBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lo sviluppo attuale di RBlog prevede una semplice struttura e la navigazione
 fra le pagine esistenti, l'homepage e due pagine statiche contenenti una
 breve descrizione del progetto e della tesi.
 Il passo successivo prevede l'introduzione di fogli di stile e la verifica
 tramite Capybara degli effettivi cambiamenti nell'aspetto delle pagine.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Un aspetto importante nello sviluppo di applicazioni web è rispettare i
 principi di accessibilità consigliati dal W3C, il consorzio che si occupa
 della standardizzazione di internet e dei suoi servizi.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\emph on
«The power of the Web is in its universality.
 Access by everyone regardless of disability is an essential aspect.»
\emph default
 Tim Berners-Lee, W3C Director and inventor of the World Wide Web
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nella funzionalità non è richiesto che il sito sia accessibile da persone
 con disabilità, ma è comunque necessario verificare non solo la struttura
 delle pagine ma anche alcuni requisiti estetici siano rispettati: potrebbe
 essere necessario che le pagine verifichino un certo schema di colori o
 che sia presente un unico font.
\end_layout

\begin_layout Standard
Le caratteristiche estetiche dell'interfaccia e l'usabilità sono requisiti
 importanti nello sviluppo di un'applicazione web, ne consegue che anche
 gli strumenti per la definizione di test di accettazione dovrebbero offrire
 delle funzionalità per l'analisi di proprietà non strettamente legate alla
 struttura del DOM ed alle proprietà dei nodi, affinché tali richieste possano
 essere introdotte all'interno di scenari e funzionalità.
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

CSS with superpowers
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
RubyMine offre la possibilità di scegliere come implementare i propri fogli
 di stile: ovviamente è previsto l'uso del CSS3 per il quale è integrato
 il supporto, ma è anche disponibile sfruttare Sass, Scss e Less, estensioni
 dello standard che introducono nuove caratteristiche ai classici fogli
 di stile.
\end_layout

\begin_layout Standard
RubyMine genera per ogni controller un foglio di stile in Sass, vista la
 forte integrazione di questo linguaggio è stato deciso di sfruttarlo per
 il progetto.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.posts {
\end_layout

\begin_layout Plain Layout

	#notice {
\end_layout

\begin_layout Plain Layout

		margin: 1em 15%;
\end_layout

\begin_layout Plain Layout

		text-align: center;
\end_layout

\begin_layout Plain Layout

		p {
\end_layout

\begin_layout Plain Layout

			color: forestgreen;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del foglio di stile in Sass relativo ai post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sass fornisce alcuni strumenti sintattici per una facilitare il riuso e
 l'organizzazione del regole e la caratteristica che maggiormente semplifica
 lo sviluppo dei fogli di stile è la possibilità di definire sotto-regole
 per gli elementi presenti nelle pagine.
 L'organizzazione del foglio di stile è più lineare e rispecchia la struttura
 del documento, c'è un minor rischio di errori, il testo dei paragrafi è
 verde solo se contenuto in un nodo 
\begin_inset Quotes eld
\end_inset

notice
\begin_inset Quotes erd
\end_inset

 e non è necessario etichettare ogni elemento del DOM con identificatori
 e classi, inoltre è molto più semplice applicare delle correzioni a piccole
 porzioni dell'applicazione.
\end_layout

\begin_layout Standard
La sintassi di Sass prevede l'uso di variabili, ad esempio per salvare i
 riferimenti ad un colore o ad un font, consente l'importazione di altri
 documenti Sass e la definizione di fogli di stile parziali per fattorizzare
 alcuni elementi comuni dell'interfaccia.
 I file in Sass sono processati e compilati in un file CSS prima dell'utilizzo,
 il procedimento è gestito in automatico da RubyMine.
\end_layout

\begin_layout Subsection
Testare il css
\end_layout

\begin_layout Standard
Per verificare le potenzialità di Capybara relativamente all'analisi 
\begin_inset Quotes eld
\end_inset

stilistica
\begin_inset Quotes erd
\end_inset

 delle pagine è stato scelto di analizzare i colore di sfondo di alcuni
 elementi.
 All'interno dell'intestazione delle pagine sono presenti i collegamenti
 introdotti dalla precedente funzionalità; nell'iterazione corrente sono
 stati definiti diversi fogli di stile che creano un semplice effetto cromatico:
 il colore dello sfondo dei collegamenti cambia al passaggio del cursore.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.banner_link:hover {
\end_layout

\begin_layout Plain Layout

	background-color: #8c2828;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del foglio di stile relativo ai collegamenti nell'intestazione
 di RBlog.
\end_layout

\end_inset


\end_layout

\end_inset

Lo scenario relativo a questa funzionalità descrive il comportamento atteso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: l'intestazione espone dei semplici effetti cromatici
\end_layout

\begin_layout Plain Layout

	Dato che è presente l'intestazione
\end_layout

\begin_layout Plain Layout

	E l'intestazione permette la navigazione
\end_layout

\begin_layout Plain Layout

	E i collegamenti non hanno sfondo
\end_layout

\begin_layout Plain Layout

	Quando il cursore si sposta sui collegamenti
\end_layout

\begin_layout Plain Layout

	Allora lo sfondo del collegamento cambia
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario relativo alla funzionalità.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Analisi delle proprietà dei nodi
\end_layout

\begin_layout Standard
Il modulo Matchers di Capybara espone molti metodi e soluzioni equivalenti
 per la lettura dei valori presenti negli attributi dei nodi del documento
 e in HTML è possibile definire lo stile di un singolo nodo inserendo le
 regole desiderate all'interno dell'attributo 
\begin_inset Quotes eld
\end_inset

style
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Supponiamo che le pagine HTML sfruttino le regole di stile all'interno dei
 nodi stessi e non attraverso fogli di stile definiti nell'intestazione
 del documento HTML: durante l'analisi del valore di un attributo strutturato
 come 
\begin_inset Quotes eld
\end_inset

style
\begin_inset Quotes erd
\end_inset

 Capybara non effettua alcuna operazione straordinaria.
 Viene quindi estratta una stringa da analizzare tramite espressioni regolari
 create ad hoc per la regola CSS a cui si è interessati.
\end_layout

\begin_layout Subsubsection
Analisi dei fogli di stile e corrispondenza all'interno del DOM
\end_layout

\begin_layout Standard
La pratica di definire lo stile direttamente all'interno delle pagine HTML
 è deprecata in quanto minimizza il riuso del codice e rende estremamente
 fragile l'insieme delle viste in termini di manutenibilità.
\end_layout

\begin_layout Standard
Capybara, più precisamente Poltergeist, non effettua alcuna valutazione
 dei fogli di stile allegati alla pagina e non associa le regole presenti
 ai rispettivi nodi del DOM.
 Le regole sono ignorate e l'accesso agli attributi 
\begin_inset Quotes eld
\end_inset

style
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

background-color
\begin_inset Quotes erd
\end_inset

 restituiscono valore nullo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

expect(banner_link_div[:style]).not_to be_nil
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Asserzione fallita sull'attributo 
\begin_inset Quotes eld
\end_inset

style
\begin_inset Quotes erd
\end_inset

 per i collegamenti dell'intestazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Soluzione individuata
\end_layout

\begin_layout Standard
Preso atto delle mancanze di Capybara e Poltergeist, per completare l'implementa
zione dello scenario è stato individuata una soluzione alternativa, è stata
 utilizzata la funzionalità del framework di eseguire script JQuery all'interno
 della pagina.
\end_layout

\begin_layout Standard
JQuery è una libreria scritta in JavaScript, permette l'analisi e manipolazione
 del DOM, gestisce gli eventi all'interno della pagina, le animazioni e
 fornisce delle interfacce per semplificare l'uso di Ajax.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def background_color(id, page)
\end_layout

\begin_layout Plain Layout

	jscript = "$('#{id}').css('backgroundColor')"
\end_layout

\begin_layout Plain Layout

	page.evaluate_script(jscript)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Analisi del colore di sfondo dell'elemento via JQuery.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo sfrutta il selettore generato dall'identificatore e accede alla
 proprietà desiderata, il metodo 
\begin_inset Quotes eld
\end_inset

css
\begin_inset Quotes erd
\end_inset

 di JQuery supporta tutte le funzionalità del CSS3, permettendo sia la lettura
 che la modifica degli elementi.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Purtroppo però, anche questa soluzione è parziale.
 La proprietà principale delle regole del CSS è l'ereditarietà: la definizione
 di una regola per un certo elemento ha conseguenze anche ai sotto elementi
 presenti nel DOM.
 Gli attributi stilistici si propagano a cascata, se applicabili, e hanno
 conseguenze in funzione dell'importanza, la regola può essere definita
 dal browser web, dall'utente o dall'autore del sito, e dalla specificità
 della definizione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Given(/^i collegamenti non hanno sfondo$/) do
\end_layout

\begin_layout Plain Layout

	#header_rgb_background = steps_helper.background_color(steps_helper.header_id,
 page) 
\end_layout

\begin_layout Plain Layout

	@textual_header_link_divs.each do |banner_link_div|
\end_layout

\begin_layout Plain Layout

		id = banner_link_div[:id]
\end_layout

\begin_layout Plain Layout

		background_color = steps_helper.background_color("##{id}", page)
\end_layout

\begin_layout Plain Layout

		expect(background_color).to eq('rgba(0, 0, 0, 0)')
\end_layout

\begin_layout Plain Layout

		#expect(steps_helper.background_color("##{id}", page)).to be  eq(header_rgb_back
ground)
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Precondizione sul colore dei collegamenti nell'intestazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nell'implementazione del passo è presente un'asserzione commentata che impedisce
 il successo del test.
 JQuery infatti non effettua alcuna verifica sull'elemento 
\begin_inset Quotes eld
\end_inset

div
\begin_inset Quotes erd
\end_inset

 corrispondente all'intestazione e per il quale è presente un colore di
 sfondo ma restituisce il valore di default.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Sia lo scenario che è stato descritto che quelli non trattati della funzionalità
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:02x00 Introducendo il CSS"

\end_inset

 non verificano proprietà elaborate dei fogli di stile, ma le limitazioni
 presenti non permettono di sfruttare i test di accettazione per la verifica
 dei principi di accessibilità né per aspetti più elementari della grafica
 delle pagine web.
\end_layout

\begin_layout Subsection
Il contesto degli scenari
\end_layout

\begin_layout Standard
In Cucumber è possibile dichiarare per le funzionalità un contesto, definito
 da un numero arbitrario di passi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Contesto:
\end_layout

\begin_layout Plain Layout

	Dato apro RBlog
\begin_inset Caption Standard

\begin_layout Plain Layout

Background della funzionalità 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:02x00 Introducendo il CSS"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I passi definiti nel contesto sono eseguiti prima di ogni scenario appartenente
 alla funzionalità e sono utilizzati per fattorizzare alcune premesse e
 per rendere più incisivi gli scenari.
 Per evitare di complicare eccessivamente i test di accettazione è consigliato
 mantenere il contesto breve per mantenere alta la leggibilità degli scenari.
\begin_inset Foot
status open

\begin_layout Plain Layout
Una pratica empirica suggerisce di mantenere le funzionalità essenziali
 per permettere la lettura del contesto e dello scenario senza dover scorrere
 nella schermata.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nell'esempio è stato definito un contesto evitare la ripetizione del passo,
 relativo alla prima iterazione, in tutti gli scenari della funzionalità.
\end_layout

\begin_layout Subsection
Debug con Capybara
\end_layout

\begin_layout Standard
Utilizzare Poltergeist e PhantomJS semplifica la verifica di applicazioni
 web che sfruttano JavaScript e metodi asincroni, ma non offrono all'utente
 di verificare tramite la GUI le azioni che vengono effettuate nei test.
\end_layout

\begin_layout Standard
Per effettuare il debug, Poltergeist offre alcuni metodi per catturare la
 pagina corrente: tramite il metodo 
\begin_inset Quotes eld
\end_inset

save_and_open_page
\begin_inset Quotes erd
\end_inset

 si ottiene il codice HTML del DOM, mentre con il metodo 
\begin_inset Quotes eld
\end_inset

save_and_open_screenshot
\begin_inset Quotes erd
\end_inset

 viene catturata e salvata l'immagine della schermata.
\end_layout

\begin_layout Standard
All'interno dell'implementazione dei passi è possibile introdurre dei breackpoin
t, ma l'interfaccia e la proprietà che i singoli nodi espongono durante
 il debug non permette una semplice analisi.
 Durante lo sviluppo è stata combinata la possibilità di salvare le schermate
 del browser e inserire delle interruzioni nell'esecuzione dei test per
 verificare visivamente le immagini.
\end_layout

\begin_layout Subsection
XPath
\end_layout

\begin_layout Standard
Le funzionalità del modulo Finders permettono di effettuare query tramite
 XPath.
\begin_inset Foot
status open

\begin_layout Plain Layout
XPath è un linguaggio che permette di effettuare query di selezione all'interno
 di documenti XML.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Then(/^l'intestazione è posizionata all'inizio$/) do
\end_layout

\begin_layout Plain Layout

	header = page.find(:xpath, 'descendant::body/*[1]')
\end_layout

\begin_layout Plain Layout

	expect(@header).to eq(header)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Query per la selezione del primo elemento del 
\begin_inset Quotes eld
\end_inset

body
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il vantaggio di creare dei selettori attraverso query XPath consiste nella
 possibilità di introdurre sia vincoli sulla struttura, nel frammento di
 codice è selezionato il primo elemento appartenente al 
\begin_inset Quotes eld
\end_inset

body
\begin_inset Quotes erd
\end_inset

 della pagina, sia vincoli sul contenuto degli attributi e dei valori.
\end_layout

\begin_layout Standard
Al contrario, la definizione di selettori tramite CSS permette solo la definizio
ne di query sulla struttura del DOM.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def post_divs_matching_title(page, post_title)
\end_layout

\begin_layout Plain Layout

	xpath_query = "//div[@class = 'post'][p/a[contains(text(),'#{post_title}')]]"
\end_layout

\begin_layout Plain Layout

	page.all(:xpath, xpath_query)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Query per la selezione dei 
\begin_inset Quotes eld
\end_inset

div
\begin_inset Quotes erd
\end_inset

 con un titolo corrispondente al paramentro.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

find
\begin_inset Quotes erd
\end_inset

 di Capybara, ma in generale tutti i metodi del modulo Finders, supportano
 la definizione di selettori attraverso XPath e CSS, ma non è distinto automatic
amente il tipo di espressione utilizzata: nell'esempio infatti il metodo
 è invocato con il simbolo 
\begin_inset Quotes eld
\end_inset

:xpath
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Itemize
Tag per la pulizia piuttosto che sfruttare un una gemma come FactoryGirl
 o DatabaseCleaner - http://www.railsonmaui.com/tips/rails/capybara-phantomjs-polt
ergeist-rspec-rails-tips.html - http://robots.thoughtbot.com/how-we-test-rails-appl
ications
\end_layout

\begin_layout Standard
Nella definizione degli scenari è conveniente utilizzare uno stile che favorisca
 sia lo sviluppatore, che ha il compito di scrivere e mantenere i test di
 accettazione, sia per il product owner, che tramite gli scenari può seguire
 lo sviluppo del prodotto.
\end_layout

\begin_layout Standard
Gli scenari devono essere indipendenti fra loro, l'ordine di esecuzione
 non deve inficiare il risultato.
 Mantenere delle dipendenze funzionali all'interno nella libreria di testing
 può introdurre diverse problematiche all'aumentare della cardinalità e
 della complessità o alla variazione dello condizioni d'esecuzione, introducendo
 ad esempio l'esecuzione in parallelo di più scenari.
\end_layout

\begin_layout Standard
Per semplificare la lettura degli scenari ed il riuso dei passi è conveniente
 sfruttare il prefisso 
\begin_inset Quotes eld
\end_inset

And
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Definizione delle viste
\end_layout

\begin_layout Standard
find, find_link, find_content, xpath, contesto di ricerca
\end_layout

\begin_layout Standard
metodi sulla pagina
\end_layout

\begin_layout Section
Introduzione della funzionalità di ricerca
\end_layout

\begin_layout Standard
http://www.rubydoc.info/github/jnicklas/capybara/Capybara/Node/Finders#find-instan
ce_method
\end_layout

\begin_layout Standard
Asincronia in Capybara https://blog.codecentric.de/en/2013/08/cucumber-capybara-po
ltergeist/
\end_layout

\begin_layout Section
Introduzione dell'autenticazione
\end_layout

\begin_layout Section
Le sessioni in Capybara
\end_layout

\begin_layout Section
Mantenibilità degli Acceptance Tests
\end_layout

\begin_layout Standard
http://www.elabs.se/blog/15-you-re-cuking-it-wrong
\end_layout

\begin_layout Standard
http://eggsonbread.com/2010/09/06/my-cucumber-best-practices-and-tips/
\end_layout

\begin_layout Standard
https://blog.engineyard.com/2009/15-expert-tips-for-using-cucumber
\end_layout

\begin_layout Standard
http://blog.codeship.io/2013/05/21/testing-tuesday-6-top-5-cucumber-best-practices.
html
\end_layout

\begin_layout Standard
https://github.com/strongqa/howitzer/wiki/Cucumber-Best-Practices
\end_layout

\begin_layout Section
Conclusione
\end_layout

\end_body
\end_document
