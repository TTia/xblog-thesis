#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass classicthesis
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package babel
\inputencoding default
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter courier
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "breaklines=true,frame=tb,captionpos=t,frameround=f,showlines=true,numbers=left,stepnumber=1,numbersep=10pt,numberstyle={\small\color{gray}\ttfamily\scriptsize},tabsize=2,language=Ruby,alsolanguage=HTML,basicstyle={\ttfamily\scriptsize}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Ruby On Rails
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:rubyonrails"

\end_inset


\end_layout

\begin_layout Section
Introduzione a RoR
\end_layout

\begin_layout Enumerate
Perchè Rails, rimando ad articolo
\end_layout

\begin_layout Subsection
Ruby
\end_layout

\begin_layout Standard
Ruby è un linguaggio di programmazione open-source, general-purpose e orientato
 agli oggetti ideato da Yukihiro Matsumoto.
 La prima pubblicazione del linguaggio risale al 1995 ed attualmente è alla
 versione 2.1.
 Ruby è fortemente orientato alla produttività, permette di scrivere codice
 essenziale, con un netto risparmio di linee di codice rispetto a linguaggi
 tipati staticamente come Java o C# e offre una sintassi ricca e versatile.
 
\end_layout

\begin_layout Standard
La comunità di Ruby è estremamente attiva e dinamica e contribuisce in maniera
 attiva all'individuazione di bug e al miglioramento continuo del linguaggio.
 Non è l'obbietto di questa tesi addentrarsi nelle particolarità sintattiche
 e semantiche di Ruby, ma ritengo sia utile fornire qualche riferimento
 per l'apprendimento del linguaggio.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\emph on
«Se intraprendete lo studio di un kōan e vi ci dedicate senza interrompervi,
 scompariranno i vostri pensieri e svaniranno i bisogni dell'io.
 » 
\emph default
(Hakuin, Orategama)
\emph on

\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
I Ruby Koans
\begin_inset Foot
status open

\begin_layout Plain Layout
I Koans sono disponibili su 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://rubykoans.com/
\end_layout

\end_inset

.
\end_layout

\end_inset

, 
\begin_inset Quotes eld
\end_inset

koan
\begin_inset Quotes erd
\end_inset

 è la pronuncia giapponese dei caratteri cinesi, sono una collezione di
 esercizi su Ruby e permettono lo studio del linguaggio comprendendo la
 maggior parte strutture sintattiche, degli elementi semantici e delle strutture
 dato.
 L'utente è guidato tramite nell'apprendimento in puro stile TDD, in maniera
 semplice, leggera ed irriverente; terminato il corso si acquisisce una
 buona consapevolezza del linguaggio e confidenza con lo stile di Ruby.
\end_layout

\begin_layout Standard
Sempre nello stile tracciato da i koan, tenuti in massima considerazione
 all'interno della comunità di utenti di Ruby, ho approfondito la conoscenza
 del linguaggio e di RoR tramite il portale Ruby Monk
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rubymonk.com/
\end_layout

\end_inset


\end_layout

\end_inset

 che fornisce numerosi tutorial interattivi ed esercizi riassuntivi per
 ogni argomento; ogni lezione è completabile attraverso il proprio browser
 internet e fornisce numerosi consigli e indicazioni allo studente.
\end_layout

\begin_layout Subsection
Don't Repeat Yourself
\end_layout

\begin_layout Standard
Il principio di mantenere il proprio codice senza ripetizioni è molto diffuso
 nell'ambito dello sviluppo Agile ed in generale è un'ottima pratica di
 programmazione.
 Un progetto DRY permette agli sviluppatori di modificare il codice più
 semplicemente; una funzionalità descritta in un numero ridotto di unità
 di compilazioni e ben fattorizzata è facilmente individuabile, correggibile
 e modificabile senza incorrere in modifiche involontarie ad altre parti
 del sistema.
\end_layout

\begin_layout Standard
RoR fornisce differenti funzionalità, quali librerie, helpers e viste parziali,
 per aiutare lo sviluppatore a definire applicazioni DRY.
\begin_inset Newline newline
\end_inset

Nell'implementazione delle viste è comune che alcuni elementi siano presenti
 più volte all'interno della stessa applicazione o anche all'interno della
 stessa pagina.
 In RoR, è possibile definire delle viste parziali per poter fattorizzare
 al meglio queste porzioni di codice.
 Per rendere ancora più efficace questo meccanismo di fattorizzazione e
 definire dei comportamenti dinamici, è possibile passare al metodo 
\begin_inset Quotes eld
\end_inset

render
\begin_inset Quotes erd
\end_inset

, che si occupa di visualizzare file con estensione 'erb', dei parametri
 in maniera opzionale.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= render 
\end_layout

\begin_layout Plain Layout

	:partial => 'posts/logged_user_post_actions',
\end_layout

\begin_layout Plain Layout

	:locals => {
\end_layout

\begin_layout Plain Layout

		:current_user => current_user,
\end_layout

\begin_layout Plain Layout

		:post => post
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

%>
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualizzazione di un vista parziale.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<% if current_user %>
\end_layout

\begin_layout Plain Layout

	<div class='post_actions'>
\end_layout

\begin_layout Plain Layout

		<%= edit_post_image_link post %>
\end_layout

\begin_layout Plain Layout

		<%= remove_post_image_link post %>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

<% end %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Vista parziale.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre, data una vista parziale che visualizza un singolo elemento, è anche
 possibile passare al metodo render una collezione di oggetti sulla quale
 iterare, fornendo opzionalmente anche un separatore.
\begin_inset Foot
status open

\begin_layout Plain Layout
I metodi e le librerie in RoR tipicamente si prestano ad una grande varietà
 di usi e comportamenti, per una descrizione più precisa è possibile consultare
 la documentazione online.
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://api.rubyonrails.org/classes/ActionView/PartialRenderer.html
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La piattaforma RoR fornisce anche numerosi Helper.
 Un Helper è descritto da un insieme di funzionalità, definite all'interno
 di un modulo, utili per gestire problematiche classiche dello sviluppo
 di applicazioni web.
 La gestione di file, formattazione di date, gestione di form e generazione
 del relativo codice sono solo alcuni dei problemi risolvibili tramite gli
 helper definiti nell'API di RoR.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= truncate(post.body, :length => 500, :separator => ' ', :omission => '...')
 %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Il metodo 'truncate', appartenente al modulo TextHelper.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come già osservato durante l'uso delle viste parziali, le librerie offerte
 sono ricche di parametri opzionali, permettono l'uso di blocchi definiti
 dall'utente e sono ben documentate: ogni metodo presente è ampiamente descritto
 e offre diversi esempi per semplificarne l'uso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<%= form_for(@post) do |f| %>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	<div id="title_field">
\end_layout

\begin_layout Plain Layout

	<%= f.label :title, 'Titolo' %>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	<%= f.text_field :title, :size => 50 %>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

<% end %>
\begin_inset Caption Standard

\begin_layout Plain Layout
Un esempio dell'uso delle funzionalità di FormHelper.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' altrettanto semplice definire i propri Helper: per ogni Controller definito
 dall'utente è incluso di default il relativo Helper, ad esempio in RBlog
 la classe PostsController include il modulo personalizzato PostsHelper
 in maniera automatica, senza necessità di configurarne l'uso e la visibilità
 all'interno del progetto.
\end_layout

\begin_layout Subsection
Convention Over Configuration
\end_layout

\begin_layout Standard
RoR definisce un insieme di convenzioni per semplificare l'uso e la configurazio
ne della piattaforma da parte dello sviluppatore.
 Per minimizzare il tempo richiesto per la messa a punto di un nuovo progetto,
 è utile seguire le convenzioni proposte, ordinando il codice in cartelle
 secondo le diverse funzionalità, aderendo alle convenzioni di denominazione
 dei file e degli attributi presenti nel modello.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ovviamente non è possibile prescindere completamente dall'uso di alcuni
 file di configurazione, ma RoR facilita ulteriormente la definizione di
 questi file codificandoli con YAML
\begin_inset Foot
status open

\begin_layout Plain Layout
Per informazioni si rimanda al sito ufficiale.
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.yaml.org/
\end_layout

\end_inset


\end_layout

\end_inset

, un formato di serializzazione facilmente leggibile e scrivibile, e Ruby
 stesso.
 Lo sviluppatore inoltre può anche sfruttare i numerosi tool a linea di
 comando per la prima generazione delle risorse, utili anche per avere una
 traccia contenente le impostazioni più plausibili per una nuova applicazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

default: &default
\end_layout

\begin_layout Plain Layout

adapter: postgresql
\end_layout

\begin_layout Plain Layout

encoding: unicode
\end_layout

\begin_layout Plain Layout

host: localhost
\end_layout

\begin_layout Plain Layout

pool: 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

development:
\end_layout

\begin_layout Plain Layout

<<: *default
\end_layout

\begin_layout Plain Layout

database: rblog_development
\end_layout

\begin_layout Plain Layout

username: xblog
\end_layout

\begin_layout Plain Layout

password: ...
\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento in YAML relativo alla configurazione del modello.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
L'interpretazione di RoR del pattern MVC
\end_layout

\begin_layout Subsubsection
Il modello
\end_layout

\begin_layout Standard
L'interpretazione di RoR del modello dell'architettura MCV prende spunto
 dal patter Active Record introdotto da Martin Fowler.
 I record attivi introducono un livello di astrazione fra gli strumenti
 di persistenza ed i controlli che gestiscono e manipolano il dominio; i
 dati sono astratti a oggetti aventi sia le informazioni che li caratterizzano,
 ad esempio i diversi attributi e le relazioni con altri tipi di dato presenti
 nel dominio, sia che le funzionalità che ne descrivono il comportamento
 attraverso i metodi d'istanza.
\end_layout

\begin_layout Standard
Il database, ed in generale qualunque sistema garantisca la persistenza
 della nostra applicazione, non è acceduto direttamente ma tramite il processo
 ORM.
 Questa tecnica minimizza, se non addirittura elimina, la necessita di eseguire
 codice nativo, come query SQL, per manipolare il dominio.
 L'uso del pattern Active Record permette a RoR delineare in maniera netta
 la separazione fra modello e controlli.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre a rappresentare i dati, è possibile sfruttare Ruby per individuare
 relazioni di ereditarietà fra i tipi esistenti, validare i dati attraverso
 l'invocazione di metodi e definire le proprie interrogazioni attraverso
 un apposita libreria.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@posts = Post
\end_layout

\begin_layout Plain Layout

			.where('title like ?', "#{params[:search]}%")
\end_layout

\begin_layout Plain Layout

			.order('created_at DESC')
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Esecuzione di una semplice query in Ruby.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
I controlli
\end_layout

\begin_layout Standard
Essendo i controlli gli elementi di interconnessione fra il modello e le
 viste è difficile per lo sviluppatore mantenerne l'implementazione semplice.
 Proprio per semplificare la definizione ed il mantenimento sono presenti
 alcuni accorgimenti in RoR.
\end_layout

\begin_layout Standard
La configurazione delle richieste instradabili è specificata in file separato
 
\begin_inset Quotes eld
\end_inset


\emph on
routes.rb
\emph default

\begin_inset Quotes erd
\end_inset

, all'interno del quale è possibile configurare le richieste HTTP soddisfabili
 e definire una gerarchia delle entità manipolate dall'applicazione secondo
 i principi di un'architettura REST.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

resources :posts do
\end_layout

\begin_layout Plain Layout

	get :autocomplete_title, :on => :collection
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

resources :sessions, :only => [:new, :create, :destroy]
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del file 
\begin_inset Quotes eld
\end_inset

routes.rb
\begin_inset Quotes erd
\end_inset

 relativo ai controlli di post e sessioni.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un altro accorgimento apprezzato durante lo sviluppo è la possibilità di
 definire dei filtri per i controlli.
 Per ogni controllo sono previsti alcuni stati a cui è possibili attribuire
 eventi, i filtri per l'appunto.
 Sfruttando questa semplice tecnica è possibile fattorizzare alcuni comportament
i comuni all'interno dei controlli di una stessa entità, come ad esempio
 la verifica delle autorizzazione per alcune operazioni sensibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

before_action
\end_layout

\begin_layout Plain Layout

	:require_login,
\end_layout

\begin_layout Plain Layout

	only: [:new, :create, :edit, :update, :destroy]
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
L'uso dei filtri in RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Le viste
\end_layout

\begin_layout Standard
Le viste in RoR sono definibili introducendo nei file HTML elementi dinamici
 contenenti espressioni scritte in Ruby.
 ERB, acronimo per Embedded Ruby, permette l'inserimento di codice da processare
 all'interno del server web prima di fornire la risposta al client.
\end_layout

\begin_layout Standard
La definizione di viste dinamiche risulta immediata, conoscendo sia Ruby
 che HTML tramite solo tre tipi di delimitatori, che variano esclusivamente
 nel tipo di output generato.
\begin_inset Foot
status open

\begin_layout Plain Layout
Per maggiori informazioni relative alle viste e alla definizione di pagine
 dinamiche tramite ERB si rimanda alla seguente guida: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/layouts_and_rendering.html
\end_layout

\end_inset


\end_layout

\end_inset

 Le viste scritte tramite ERB sono facilmente leggibili grazie alla caratteristi
che di Ruby
\begin_inset Marginal
status open

\begin_layout Plain Layout
Ogni espressione ha un valore.
 Il valore di ritorno delle funzioni e dei metodi è dato dall'ultima espressione
 eseguita.
 Le parentesi sono opzionali ed anche i parametri possono esserlo.
\end_layout

\end_inset

, alla sintassi minima e alle numerose funzionalità presente negli Helper
 e librerie del linguaggio.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class='post'>
\end_layout

\begin_layout Plain Layout

	<p class='post_title'>
\end_layout

\begin_layout Plain Layout

		<%= link_to @post.title, @post %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

	<p class='post_detail'>
\end_layout

\begin_layout Plain Layout

		<%= author_detail(@post) %>
\end_layout

\begin_layout Plain Layout

		</br>
\end_layout

\begin_layout Plain Layout

		<% post_details(@post).each do |detail| %>
\end_layout

\begin_layout Plain Layout

			<%= detail %>
\end_layout

\begin_layout Plain Layout

		<% end %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

    <p class='post_content'>
\end_layout

\begin_layout Plain Layout

		<%= @post.body %>
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

	<%= render 
\end_layout

\begin_layout Plain Layout

		:partial => 'logged_user_post_actions',  
\end_layout

\begin_layout Plain Layout

		:locals => {:current_user => current_user, :post => @post}
\end_layout

\begin_layout Plain Layout

	%>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento di vista relativo alla visualizzazione di un singolo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Il testing
\end_layout

\begin_layout Standard
La propensione alla verifica dell'applicazione non è un elemento proprio
 dell'architettura MVC, ma influisce comunque notevolmente sul processo
 di sviluppo.
\end_layout

\begin_layout Standard
Tramite RoR è possibile gestire l'intero stack di un'applicazione web, test
 inclusi.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html
\end_layout

\end_inset


\end_layout

\end_inset

 Sfruttando RSpec, strumento eletto a standard de-facto, è possibile testare
 il modello attraverso i record attivi ed anche verificare i propri controller,
 definendo i parametri HTTP e dati.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Da Ruby 1.9 è incluso la libreria MiniTest, che fornisce le funzionalità
 per arricchire i propri test con delle callback da applicare a differenti
 stati dell'esecuzione della libreria di test, introduce oggetti 
\begin_inset Quotes eld
\end_inset


\emph on
mock
\emph default

\begin_inset Quotes erd
\end_inset

, consente di effettuare misurazioni delle prestazioni e molto altro.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/seattlerb/minitest
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Marginal
status open

\begin_layout Plain Layout
Paragonabili alla annotazioni 
\emph on
@After
\emph default
, 
\emph on
@Before
\emph default
, 
\emph on
@AfterClass
\emph default
 e 
\emph on
@BeforeClass
\emph default
 in JUnit 4.x.
\end_layout

\end_inset

 Esistono numerose gemme sviluppate da terze parti per aggiungere funzionalità
 e semplificare il processo di testing, ad esempio per la pulizia dei database
 utilizzati DatabaseCleaner è molto diffusa, al pari di Factory Girl
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/DatabaseCleaner/database_cleaner
\end_layout

\end_inset


\end_layout

\end_inset

 per la popolazione del modello.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/thoughtbot/factory_girl
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
E' anche previsto che il modello sia presente in tre versioni, -test, sviluppo
 e produzione- al fine di concedere allo sviluppatore la libertà di eseguire
 test sulle nuove funzionalità senza dover effettuare continui backup dei
 dati ed assumere altre precauzioni.
\begin_inset Newline newline
\end_inset

Rail fornisce inoltre il comando Rake per poter gestire al meglio l'esecuzione
 selettiva delle proprie librerie di test.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://guides.rubyonrails.org/testing.html##rake-tasks-for-running-your-tests
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
L'obbiettivo di questa tesi non è l'uso approfondito di RoR e delle sue
 funzionalità, ma durante l'implementazione del blog sono state notate alcune
 peculiarità del framework e del suo 
\begin_inset Quotes eld
\end_inset


\emph on
ecosistema
\emph default

\begin_inset Quotes erd
\end_inset

 che hanno contribuito che lo sviluppo si svolgesse in maniera lineare permetten
do di scrivere codice in maniera produttiva e concentrando la propria attenzioni
 all'indagine sui test di accettazione piuttosto che a problematiche di
 contorno.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A differenza di altre piattaforme, in cui sono presenti strumenti esterni
 per supportare la compilazione e la risoluzione delle dipendenze come Maven
 e Gradle, Ruby sfrutta un proprio meccanismo, definendo delle gemme.
 Ogni gemma rappresenta una libreria, ha un nome, versione ed architettura
 di riferimento.
 
\end_layout

\begin_layout Standard
Ogni applicazione è caratterizzata da una risorsa chiamata Gemfile, un semplice
 script in Ruby, che rappresenta l'insieme delle dipendenze e delle gemme
 da includere nel proprio progetto.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://rubygems.org/
\end_layout

\end_inset

 è il servizio di hosting di riferimento.
\end_layout

\end_inset

 E' possibile indicare quali librerie includere in funzione del tipo di
 compilazione adottata, rilascio, sviluppo o test, e delegando la verifica
 di aggiornamenti per librerie di terze parti al sistema.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

source 'https://rubygems.org'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

group :development, :test do
\end_layout

\begin_layout Plain Layout

	gem 'cucumber-rails', :require => false 	gem 'rspec-rails'
\end_layout

\begin_layout Plain Layout

	gem 'capybara'
\end_layout

\begin_layout Plain Layout

	gem 'poltergeist'
\end_layout

\begin_layout Plain Layout

	gem 'database_cleaner'
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del Gemfile di RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fra le gemme utilizzate, la più preziosa
\begin_inset Marginal
status open

\begin_layout Plain Layout
:)
\end_layout

\end_inset

 è Spring.
 La libreria permette di caricare in anticipo le modifiche fatte al codice
 sorgente dell'applicazione in maniera che sia sempre in esecuzione la versione
 più recente, evitando all'utente di dover riavviare l'esecuzione manualmente
 ad ogni cambiamento.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nel contesto di sviluppo di applicazioni MVC è facile introdurre delle discrepan
ze fra il modello e la rappresentazione delle entità all'interno dell'applicazio
ne, soprattutto sfruttando strumenti di versionamento che offrono operazioni
 equivalenti alla 
\begin_inset Quotes eld
\end_inset


\emph on
revert
\emph default

\begin_inset Quotes erd
\end_inset

 in Git.
 
\end_layout

\begin_layout Standard
In RoR è previsto il meccanismo delle migrazioni che fornisce uno strumento
 per mantenere lo schema del modello consistente durante il processo di
 sviluppo in maniera semplice e lineare.
 Ogni variazione alla struttura del modello è tradotto in una migrazione,
 che definisce l'insieme delle operazioni compiute a basso livello, l'aggiunta
 di colonne, la rimozione di un vincolo etc., ed attribuisce una versione
 all'operazione; le stesse informazioni sulle migrazioni sono mantenute
 nel modello e tengono traccia dei cambiamenti apportati e dello stato attuale
 dello schema, permettendo di mantenere tutte le componenti dell'architettura
 MVC consistenti fra loro.
\end_layout

\begin_layout Section
RubyMine
\end_layout

\begin_layout Standard
Per lo sviluppo di RBlog e la definizione dei test di accettazione è stato
 utilizzato RubyMine, alla versione 6.3.
 L'IDE prodotto da JetBrains, sviluppatori anche di IntelliJ IDEA, Android
 Studio, ReSharper per citare i più conosciuti, supporta le feature di Rails
 4.1 e Ruby 2.1, ovvero le versioni più recenti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'esperienza con RubyMine è stata ottima: durante lo sviluppo sono stati
 rilevati raramente problemi ed integra perfettamente tutte le funzionalità
 a riga di comando offerte da Rails; Ruby, HTML, JavaScript, JQuery, CoffeeScrip
t, SCSS sono solo alcuni dei linguaggi supportati nell'IDE e per tutti sono
 definite varie strategie di refactoring ed è possibile analizzarne le relative
 risorse tramite un potente tool di analisi del codice.
 
\end_layout

\begin_layout Standard
Nell'IDE sono presenti diversi plugin per l'integrazione con strumenti di
 terzi, come ad esempio Cucumber, Git
\begin_inset Marginal
status open

\begin_layout Plain Layout
Sono inclusi diversi plugin per il supporto sistemi di versionamento: attualment
e sono disponibili CVS, Git, Subversion, Mercurial e Perforce.
\end_layout

\end_inset

 e SSH.
 RubyMine è un prodotto curato nei dettagli, professionale ed allo stesso
 tempo adatto anche agli utenti alle prime armi; ma soprattutto permette
 l'implementazione di un'applicazione in Rails praticamente senza abbandonare
 l'ambiente di sviluppo.
\end_layout

\begin_layout Section
Hello RBlog!
\end_layout

\begin_layout Standard
L'obbiettivo di questa prima funzionalità è minimo, è necessario che l'applicazi
one sia in esecuzione ed il sito web raggiungibile.
 Inoltre il blog deve consentire la navigazione verso alcune pagine statiche.
\end_layout

\begin_layout Subsection
Cucumber
\end_layout

\begin_layout Standard
Il primo tassello necessario per l'implementazione dei test di accettazione
 su un'applicazione web sviluppata in RoR è Cucumber.
\end_layout

\begin_layout Standard
Cucumber è framework per il supporto al BDD, Behaviour Driven Development,
 che permette di scrivere i propri test in maniera leggibile, elegante e
 mantenibile.
 Il framework è disponibile anche in Java, .Net, Python, PHP e molti altri
 linguaggi e piattaforme.
\end_layout

\begin_layout Subsubsection
Le funzionalità
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:01x00 Hello RBlog!"

\end_inset

La prima feature di RBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I principali elementi in Cucumber, ed in generale nella definizione dei
 test di accettazione, sono le caratteristiche e potenzialità che l'applicazione
 offre e i diversi scenari che le definiscono.
\end_layout

\begin_layout Standard
Le funzionalità sono elementi esclusivamente descrittivi, non sono utilizzate
 esplicitamente nell'implementazione dei test ma hanno lo scopo di far cogliere
 la giusta prospettiva al team di sviluppo.
 Hanno titolo libero mentre la descrizione è definita tramite una user story
 secondo il formato 
\begin_inset Quotes eld
\end_inset


\emph on
Per
\emph default
 <beneficio>, 
\emph on
come
\emph default
 <ruolo>, 
\emph on
vorrei
\emph default
 <obbiettivo, desiderio>
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset

Nella listato, oltre alla descrizione della funzionalità è presente un etichetta
 che permette di organizzare e categorizzare quanto sviluppato con Cucumber;
 
\begin_inset Quotes eld
\end_inset


\emph on
@cap1
\emph default

\begin_inset Quotes erd
\end_inset

 in particolare caratterizza sia la user-story e per ereditarietà anche
 gli scenari che la definiscono; è stata introdotta per poter eseguire in
 maniera selettiva gli scenari della prima funzionalità.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cucumber --tags @cap1
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Comando per l'esecuzione degli scenari relativi alla feature 
\begin_inset Quotes eld
\end_inset

Hello RBlog!
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' possibile introdurre un numero arbitrario di etichette per ciascun elemento,
 sia funzionalità o scenario, e sfruttando l'opzione 
\begin_inset Quotes eld
\end_inset


\emph on
--tags
\emph default

\begin_inset Quotes erd
\end_inset

 definire il corretto insieme di test da eseguire, tramite gli operatori
 logici AND, OR e NOT.
\end_layout

\begin_layout Standard
Per facilitare lo sviluppo di test all'interno del proprio progetto è consigliat
o seguire la convenzione di inserire all'interno della cartella 
\begin_inset Quotes eld
\end_inset


\emph on
features
\emph default

\begin_inset Quotes erd
\end_inset

 i test di accettazione ed attribuire ai relativi file l'estenzione 
\begin_inset Quotes eld
\end_inset


\emph on
.feature
\emph default

\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Gli scenari
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Visita alla pagina iniziale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Allora posso visitare la pagina dell'autore
\end_layout

\begin_layout Plain Layout

E posso visitare la pagina dell'abstract
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:01x01 Homepage"

\end_inset

Navigazione verso la pagina iniziale
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il primo scenario descrive la navigazione verso la homepage
, relativo alla funzionalità 
\lang italian

\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x00 Hello RBlog!"

\end_inset

 ed introduce la sintassi di Cucumber.
 Gli scenario sono caratterizzati da un titolo, che riassume il comportamento
 e da un insieme di passi.
 Seguendo la logica del BDD, ogni passo può essere una precondizione, un
 evento oppure un'asserzione rispettivamente 
\begin_inset Quotes eld
\end_inset


\emph on
Given
\emph default

\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\emph on
When
\emph default

\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\emph on
Then
\emph default

\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Espandere, vedi preferito
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Come sarà analizzato nelle sezioni relative all'implementazione degli scenari,
 la scelta del prefisso del passo non inficia le potenzialità del passo
 stesso, ma un uso corretto favorisce la leggibilità del test.
 E' anche possibile sfruttare i prefissi 
\begin_inset Quotes eld
\end_inset


\emph on
And
\emph default

\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset


\emph on
But
\emph default

\begin_inset Quotes erd
\end_inset

 per rendere i propri scenari più scorrevoli; alla congiunzione si attribuisce
 il tipo del passo precedente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Schema dello scenario: Visita alla pagina dell'autore e alla pagina dell'abstrac
t
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Quando navigo verso "<nome della pagina>"
\end_layout

\begin_layout Plain Layout

Allora la pagina è intitolata "<nome della pagina>"     
\end_layout

\begin_layout Plain Layout

E posso tornare alla pagina iniziale   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Esempi:
\end_layout

\begin_layout Plain Layout

| nome della pagina |
\end_layout

\begin_layout Plain Layout

| Autore            |
\end_layout

\begin_layout Plain Layout

| Abstract          |
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:01x02 Pagine statiche"

\end_inset

Navigazione verso le pagine statiche
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cucumber offre la possibilità di definire scenari parametrici.
 Sfruttando la sintassi 
\emph on

\begin_inset Quotes eld
\end_inset

Schema dello 
\emph default
scenario
\begin_inset Quotes erd
\end_inset

, la tabella 
\begin_inset Quotes eld
\end_inset


\emph on
Esempi
\emph default

\begin_inset Quotes erd
\end_inset

 e i delimitatori 
\begin_inset Quotes eld
\end_inset


\emph on
< >
\emph default

\begin_inset Quotes erd
\end_inset

 è possibile verificare tanti scenari quanti sono i parametri all'interno
 della tabella: lo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset

 è effettuato sia sulla pagina dell'autore che sulla pagina dell'abstract.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Visita alle pagine statiche: la pagina dell'autore e all'abstract
 della tesi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Dato apro RBlog
\end_layout

\begin_layout Plain Layout

Quando navigo verso "Autore"
\end_layout

\begin_layout Plain Layout

Allora la pagina è intitolata "Autore"
\end_layout

\begin_layout Plain Layout

E posso tornare alla pagina iniziale
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Testo generato dallo scenario 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:01x02 Pagine statiche"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Gherkin
\end_layout

\begin_layout Standard
"it": { "name": "Italian", "native": "italiano", "feature": "Funzionalità",
 "background": "Contesto", "scenario": "Scenario", "scenario_outline": "Schema
 dello scenario", "examples": "Esempi", "given": "*|Dato|Data|Dati|Date",
 "when": "*|Quando", "then": "*|Allora", "and": "*|E", "but": "*|Ma" }
\end_layout

\begin_layout Standard
Possibilità di internazionalizzare i test
\end_layout

\begin_layout Standard
https://github.com/cucumber/gherkin/blob/master/lib/gherkin/i18n.json
\end_layout

\begin_layout 
https://github.com/cucumber/cucumber/wiki/Gherkin
\end_layout

\begin_layout 
http://www.elabs.se/blog/15-you-re-cuking-it-wrong
\end_layout

\begin_layout 
http://eggsonbread.com/2010/09/06/my-cucumber-best-practices-and-tips/
\end_layout

\begin_layout 
https://blog.engineyard.com/2009/15-expert-tips-for-using-cucumber
\end_layout

\begin_layout 
http://blog.codeship.io/2013/05/21/testing-tuesday-6-top-5-cucumber-best-practices.
html
\end_layout

\begin_layout 
https://github.com/strongqa/howitzer/wiki/Cucumber-Best-Practices
\end_layout

\begin_layout Subsubsection
Supporto a Cucumber in RubyMine
\end_layout

\begin_layout Subsection
Capybara
\end_layout

\begin_layout 
Interfaccia per i driver
\end_layout

\begin_layout 
https://blog.codecentric.de/en/2013/08/cucumber-setup-basics/
\end_layout

\begin_layout 
https://blog.codecentric.de/en/2013/08/cucumber-capybara-poltergeist
\end_layout

\begin_layout Subsection
RSpec
\end_layout

\begin_layout Itemize
https://github.com/rspec/rspec-rails
\end_layout

\begin_layout Itemize
http://www.rubyinside.com/how-to-rails-3-and-rspec-2-4336.html
\end_layout

\begin_layout Subsection
Poltergeist
\end_layout

\begin_layout Itemize
https://github.com/teampoltergeist/poltergeist
\end_layout

\begin_layout Itemize
http://www.railsonmaui.com/blog/2013/08/06/migrating-from-capybara-webkit-to-polte
rgeist-phantomjs/
\end_layout

\begin_layout Itemize
http://stackoverflow.com/questions/23951381/how-do-poltergeist-phantomjs-and-capy
bara-webkit-differ
\end_layout

\begin_layout Subsubsection
Phantom Js
\end_layout

\begin_layout Enumerate
Vantaggi rispetto ad un browser 
\begin_inset Quotes eld
\end_inset

visibile
\begin_inset Quotes erd
\end_inset

 - http://blog.codeship.io/2013/02/11/using-phantomjs-for-backend-tests.html
\end_layout

\begin_layout Subsection
Implementazione dei passi in Capybara
\end_layout

\begin_layout Subsection
RSpec
\end_layout

\begin_layout Subsection
Mixing Capybara & RSpec
\end_layout

\begin_layout Subsection
Scenario Outline
\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Subsection
SCSS
\end_layout

\begin_layout Standard
Matcher in Capybara
\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Itemize
Tag per la pulizia piuttosto che sfruttare un una gemma come FactoryGirl
 o DatabaseCleaner - http://www.railsonmaui.com/tips/rails/capybara-phantomjs-polt
ergeist-rspec-rails-tips.html
\end_layout

\begin_layout Standard
Nella definizione degli scenari è conveniente utilizzare uno stile che favorisca
 sia lo sviluppatore, che ha il compito di scrivere e mantenere i test di
 accettazione, sia per il product owner, che tramite gli scenari può seguire
 lo sviluppo del prodotto.
\end_layout

\begin_layout Standard
Gli scenari devono essere indipendenti fra loro, l'ordine di esecuzione
 non deve inficiare il risultato.
 Mantenere delle dipendenze funzionali all'interno nella libreria di testing
 può introdurre diverse problematiche all'aumentare della cardinalità e
 della complessità o alla variazione dello condizioni d'esecuzione, introducendo
 ad esempio l'esecuzione in parallelo di più scenari.
\end_layout

\begin_layout Standard
Per semplificare la lettura degli scenari ed il riuso dei passi è conveniente
 sfruttare il prefisso 
\begin_inset Quotes eld
\end_inset

And
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Definizione delle viste
\end_layout

\begin_layout Section
Introduzione della funzionalità di ricerca
\end_layout

\begin_layout Section
Introduzione dell'autenticazione
\end_layout

\begin_layout Section
Le sessioni in Capybara
\end_layout

\begin_layout Section
Conclusione
\end_layout

\end_body
\end_document
