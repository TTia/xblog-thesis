#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\use_default_options true
\master ../Relazione.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
MVC 5 17/11/14
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:spring"

\end_inset


\end_layout

\begin_layout Section
ASP.NET MVC 5
\end_layout

\begin_layout Standard
In questo capitolo è trattato lo sviluppo di CSBlog, un'applicazione web
 sviluppata tramite il framework ASP.NET MVC 5 e implementando la libreria
 di test di accettazione già mostrata nei precedenti capitoli utilizzando
 Specflow, una libreria per il BDD ispirata a Cucumber, e Coypu per automatizzar
e la navigazione del browser web.
\end_layout

\begin_layout Standard
In questo capitolo saranno descritte le particolarità del framework, dell'implem
entazione delle diverse componenti e degli strumenti utilizzati per implementare
 l'applicazione web.
 Dalla sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-CSBlog!"

\end_inset

 sono documentate le diverse funzionalità presenti nella libreria dei test
 di accettazione e descritto il processo di testing, includendo esempi e
 frammenti di codice.
\end_layout

\begin_layout Subsection
Visual Studio 2013
\end_layout

\begin_layout Standard
Per lo sviluppo di CSBlog, dei test di accettazione e la gestione del modello
 è stato utilizzato Visual Studio 2013 Ultimate, VS, che integra le diverse
 funzionalità per lo sviluppo web, la configurazione della propria applicazione
 e l'implementazione delle diverse componenti del pattern.
\end_layout

\begin_layout Standard
Tutti i plugin necessari, per il supporto a Specflow o l'installazione di
 PhantomJS, sono stati installati tramite NuGet, il gestore di pacchetti
 per il mondo .NET direttamente tramite l'ambiente di sviluppo.
 VS è un ambiente di sviluppo con enormi potenzialità, articolato e complesso,
 nel corso delle prossime sezioni sono descritte le funzionalità utilizzate
 per la definizione del progetto e dei test.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:L'interpretazione di MVC5"

\end_inset

L'interpretazione di ASP.NET del pattern MVC
\end_layout

\begin_layout Standard
Nelle prossime sezioni è descritto il processo di definizione dell'architettura
 di CSBlog, caratterizzato da un uso costante degli strumenti di VS per
 la definizione delle varie componenti.
 Al termine della sezione risulterà evidente come, nonostante il framework
 MVC5 e l'intero progetto ASP.NET sia estremamente articolato, lo sviluppo
 non risente delle grandi potenzialità messe a disposizione.
\end_layout

\begin_layout Subsection
Il modello
\end_layout

\begin_layout Standard
Per definire il modello con RoR e Spring è stato scelto di definire prima
 le entità, rispettivamente tramite gli ActiveRecord e JPA, ed utilizzare
 le classi per effettuare la generazione dei database su PostgreSql.
 RoR genera di default tre database e le tabelle delle migrazioni, ed anche
 JPA implementa ad alto livello molte funzionalità dei database relazioni,
 come i vincoli di integrità.
 E' quindi molto conveniente per lo sviluppatore progettare la persistenza
 partendo dalle classi che rappresentano il dominio.
\end_layout

\begin_layout Standard
Per MVC5 è stato scelto invece di definire il modello in maniera 
\begin_inset Quotes eld
\end_inset

classica
\begin_inset Quotes erd
\end_inset

 utilizzando il DDL di SQL, utilizzando SQL Server Express la versione gratuita
 del database sviluppato da Microsoft, la generazione guidata e gli strumenti
 grafici per la gestione dei database che hanno permesso la creazione delle
 tabelle 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

Autore
\begin_inset Quotes erd
\end_inset

 e della relazione presente fra le due entità in breve tempo.
\end_layout

\begin_layout Subsubsection*
Entity Framework
\end_layout

\begin_layout Standard
Per implementare l'interfaccia del modello di MVC5 è stato scelto l'Entity
 Framework, attualmente alla versione 6, che implementa l'astrazione del
 modello attraverso la tecnica ORM in maniera simile a quanto già visto
 per RoR e Spring.
 Il framework si integra con ADO.NET, responstabile dell'interazione con
 i sistemi di persistenza esistenti e del mantenimento della consistenza
 fra le entry e gli oggetti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le classi che descrivono le entità dell'EF estendono 
\begin_inset Quotes eld
\end_inset

DbContext
\begin_inset Quotes erd
\end_inset

, che fornisce le funzionalità per eseguire interrogazioni, tener traccia
 dei cambiamenti allo stato delle istanze ed invocare le operazioni di creazione
, aggiornamento e cancellazione.
 Visual Studio include un wizard per la configurazione del modello, che
 provvede a definire la connessione al database, a generare le classi parziali
\begin_inset Foot
status open

\begin_layout Plain Layout
Una classe parziale in C# rappresenta una parte di una classe intera.
 La definizione completa è suddivisa in più fine che saranno unite a tempo
 di compilazione.
\end_layout

\end_inset

 rappresentanti le entità e a configurare le risorse necessarie per il funzionam
ento dell'EF.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public partial class CSBlogEntities : DbContext{
\end_layout

\begin_layout Plain Layout

	public CSBlogEntities() : base("name=CSBlogEntities"){}         	protected
 override void OnModelCreating(DbModelBuilder modelBuilder){
\end_layout

\begin_layout Plain Layout

		throw new UnintentionalCodeFirstException();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Author> Authors { get; set; }
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Post> Posts { get; set; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Il contesto di CSBlog generato da VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le proprietà 
\begin_inset Quotes eld
\end_inset

Authors
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Posts
\begin_inset Quotes erd
\end_inset

 rappresentano le entità presenti nel database e sono utilizzate dall'EF
 per effettuare le query.
 Per implementare le interrogazioni necessarie per CSBlog è stato utilizzato
 LINQ, Language-Integrated Query.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

var postTitles = db.Posts.Select(p => p.title).ToList();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Proiezione dei titoli dei post in CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
LINQ permette di definire le proprie query attraverso un insieme di metodi
 che rispecchiano le funzionalità di SQL e permettono di utilizzare il paradigma
 ad oggetti, ad esempio nell'operazione di proiezione dell'esempio precedente
 per ottenere i titoli dei post esistenti è stato effettuato un'accesso
 all'attributo 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

 dell'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
 Utilizzando una libreria che fornisce una tale astrazione del modello e
 delle entità è possibile definire le proprie interrogazioni sfruttando
 tutte le funzionalità esistenti per C# in VS, come l'auto-completamento
 e l'evidenziatura dei diversi elementi sintattici.
 Inoltre LINQ definisce query utilizzando metodi generici che permettono
 di verificare a compile-time il corretto utilizzo delli tipi e degli attributi
 presenti nelle interrogazioni.
\begin_inset Newline newline
\end_inset

In maniera simile all'interfaccia per la definizione delle query con gli
 Active Record di RoR, lo sviluppatore può sfruttare l'astrazione introdotta
 dall'uso dell'EF e definire le proprie query in maniera veloce ed intuitiva.
 Rispetto però alla controparte in Ruby, LINQ è più completo permettendo
 la definizione di interrogazioni anche su altri sistemi per la persistenza,
 come documenti XML, ed anche su collezioni di tipo 
\begin_inset Quotes eld
\end_inset

IEnumerable
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La semplice query di proiezione dell'esempio è suddivisibile in tre elementi:
 l'ottenimento del contesto tramite le classi dell'EF, rappresentato dall'oggett
o 
\begin_inset Quotes eld
\end_inset

db
\begin_inset Quotes erd
\end_inset

, per specificare quale sia l'entità utilizzata nell'interrogazione, la
 specifica delle operazioni, come il metodo 
\begin_inset Quotes eld
\end_inset

Select
\begin_inset Quotes erd
\end_inset

, e l'esecuzione che coincide con l'invocazione del metodo 
\begin_inset Quotes eld
\end_inset

ToList
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
In generale ogni invocazione che comporta un accesso esplicito agli oggetti
 coincide con l'esecuzione della query.
 Ad esempio utilizzando il metodo 
\begin_inset Quotes eld
\end_inset

ToList
\begin_inset Quotes erd
\end_inset

, le funzionalità di LINQ 
\begin_inset Quotes eld
\end_inset

First
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

Any
\begin_inset Quotes erd
\end_inset

 o l'iterazione tramite il costrutto 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
 L'oggetto 
\begin_inset Quotes eld
\end_inset

postTitles
\begin_inset Quotes erd
\end_inset

 ha tipo IQueryable, interfaccia generica sul tipo dell'interrogazione,
 che estende IEnumerable e dichiara le funzionalità per compiere la valutazione
 della query.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre alla generazione dell'interfaccia del modello, VS include un browser
 del modello che rappresenta la struttura delle entità esistenti e le relazioni
 che intercorrono fra loro.
 Direttamente nell'ambiente di sviluppo è possibile visualizzare e aggiornare
 la struttura del modello, sincronizzando gli schemi dei database utilizzati,
 ed anche gestire associazioni e relazioni di ereditarietà.
\end_layout

\begin_layout Subsection
I controlli
\end_layout

\begin_layout Standard
Come per la definizione del modello, anche per i controlli e le relative
 azioni, sono stati utilizzati gli strumenti di VS per la generazione automatica
 delle componenti.
 Il wizard per la configurazione è ben strutturato e permette di indicare
 quali azioni sia necessario generare, ad esempio è possibile creare un
 controllo contenente le operazioni CRUD oppure vuoto, e se utilizzare l'EF
 per associare il nuovo controllo ad una delle entità e generare dei metodi
 opportunamente connessi al modello.
\end_layout

\begin_layout Standard
Durante il processo di configurazione del nuovo controllo è anche generato
 insieme di viste corrispondenti alle azioni create.
 In maniera simile a RubyMine, gli strumenti dell'ambiente di sviluppo facilitan
o lo sviluppo fornendo una struttura esistente per le nuove applicazioni
 e preziose indicazioni sulla struttura del framework e di come le componenti
 interagiscano fra loro.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per semplificare la risoluzione delle richieste HTTP all'applicazione, MVC5
 definisce un file 
\begin_inset Quotes eld
\end_inset

RouteConfig.cs
\begin_inset Quotes erd
\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

AppData
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class RouteConfig{
\end_layout

\begin_layout Plain Layout

	public static void RegisterRoutes(RouteCollection routes){
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	routes.MapRoute(
\end_layout

\begin_layout Plain Layout

		name: "Default",
\end_layout

\begin_layout Plain Layout

		url: "{controller}/{action}/{id}",
\end_layout

\begin_layout Plain Layout

		defaults: new {
\end_layout

\begin_layout Plain Layout

			controller = "Post",
\end_layout

\begin_layout Plain Layout

			action = "Index",
\end_layout

\begin_layout Plain Layout

			id = UrlParameter.Optional
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Definizione del pattern per la risoluzione delle richieste.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

RegisterRoutes
\begin_inset Quotes erd
\end_inset

 si occupa di registrare la convenzione scelta per la risoluzione delle
 richieste effettuate dagli utenti.
 Come si può osservare dal metodo, anche per CSBlog l'applicazione rispecchia
 l'organizzazione di un'architettura REST: ad esempio l'URL relativo 
\begin_inset Quotes eld
\end_inset

/Post/Create/
\begin_inset Quotes erd
\end_inset

 è suddiviso in due elementi, il nome del controllo e l'azione corrispondente.
 Inoltre è specificato quale sia l'homepage tramite il parametro 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

namespace Blog.Controllers {
\end_layout

\begin_layout Plain Layout

	public class PostController : Controller     {
\end_layout

\begin_layout Plain Layout

	    private CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

	    public ActionResult Details(Guid? id){
\end_layout

\begin_layout Plain Layout

		if (id == null){
\end_layout

\begin_layout Plain Layout

			return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		Post post = db.Posts.Find(id);
\end_layout

\begin_layout Plain Layout

		if (post == null){
\end_layout

\begin_layout Plain Layout

			return HttpNotFound();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		return View(post);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Visualizzazione di un singolo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per implementare un nuovo controllo, è sufficiente creare una nuova classe
 pubblica all'interno del namespace del progetto ed estendere la classe
 astratta 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

.
 Nel frammento della classe 
\begin_inset Quotes eld
\end_inset

PostController
\begin_inset Quotes erd
\end_inset

 è mostrata l'implementazione di una singola azione che, in funzione del
 parametro 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 carica tramite LINQ ed EF l'entità corrispondente e restituisce un riferimento
 alla vista 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

.
 Come in RoR per ogni azione, se non specificato diversamente, è prevista
 una vista con ugual nome, in particolare, dopo aver individuato il corretto
 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 all'interno del modello, il server web fornirà all'utente la vista corrisponden
te al file 
\begin_inset Quotes eld
\end_inset

Views/Details.cshtml
\begin_inset Quotes erd
\end_inset

.
 L'azione 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

 accetta richieste HTTP di qualsiasi tipo, per applicare delle limitazioni
 è sufficiente annotare il metodo con attributi come 
\begin_inset Quotes eld
\end_inset

HttpGet
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

HttpPost
\begin_inset Quotes erd
\end_inset

 presenti in MVC5.
\end_layout

\begin_layout Standard
Il tipo 
\begin_inset Quotes eld
\end_inset

ActionResult
\begin_inset Quotes erd
\end_inset

 utilizzato come risultato dell'azione ha il compito di incapsulare il risultato
 e permettere al framework fornire una risposta, nel frammento il metodo
 
\begin_inset Quotes eld
\end_inset

View
\begin_inset Quotes erd
\end_inset

 della classe padre 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

 istanzia un'oggetto 
\begin_inset Quotes eld
\end_inset

ViewResult
\begin_inset Quotes erd
\end_inset

 che specifica la vista da renderizzare.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Rispetto a Spring e RoR, non è prevista all'interno dell'architettura una
 componente con il ruolo di disaccoppiare i controlli dalla logica per l'accesso
 al modello, sta quindi all'utente introdurre il pattern che meglio si presta
 allo scopo ed implementarlo.
\end_layout

\begin_layout Subsection
Le viste
\end_layout

\begin_layout Standard
Per l'implementazione delle viste di CSBlog è stato utilizzato Razor, un
 linguaggio ASP.NET per l'implementazione di pagine dinamiche che introduce
 una sintassi basata sul C# ed integrata in VS tramite, ad esempio è previsto
 l'IntelliSense e la possibilità di creare nuove pagine sfruttando i wizard
 presenti nell'ambiente di sviluppo.
\end_layout

\begin_layout Standard
Razor rappresenta la scelta di default per lo sviluppo di una nuova applicazione
 web, introdotto dalla versione 4 del framework, introduce una sintassi
 per ottimizzare la generazione di pagine HTML, definenendo un insieme di
 costrutti per permettere allo sviluppatore di distinguere facilmente le
 porzioni di codice dinamico.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{
\end_layout

\begin_layout Plain Layout

	var helloRazor = "Benvenuto su CSBlog!";
\end_layout

\begin_layout Plain Layout

	var weekDay = DateTime.Now.DayOfWeek;
\end_layout

\begin_layout Plain Layout

	var greetingMessage = greeting + " Oggi è: " + weekDay;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

<p>@helloRazor</p>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Hello Razor!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il design delle istruzioni è essenziale ed è paragonabile ad ERB, sono infatti
 presenti anche in Razor dei dei delimitatori per includere all'interno
 delle viste codice.
 Nel frammento d'esempio è introdotto un blocco contente istruzioni C#,
 che utilizzano le librerie di sistema, all'interno del quale è creato un
 messaggio di benvenuto.
 Tramite la notazione 
\begin_inset Quotes eld
\end_inset

@variabile
\begin_inset Quotes erd
\end_inset

 è possibile accedere utilizzare all'interno della struttura del documento
 per utilizzare l'espressione concatenata nel blocco.
\end_layout

\begin_layout Standard
La distinzione fra la sintassi 
\begin_inset Quotes eld
\end_inset

@{...}
\begin_inset Quotes erd
\end_inset

 e l'operatore 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

 che permette di accedere ai valori e di utilizzarne le espressioni per
 generare le viste dinamiche, permette di dichiarare viste in cui sono distinte
 in maniera chiara le porzioni di codice che includono l'implementazione
 della logica dalle istruzioni che esclusivamente utilizzano le funzionalità
 in lettura.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ul>
\end_layout

\begin_layout Plain Layout

@for (int i = 0; i < 10; i++){
\end_layout

\begin_layout Plain Layout

	<li>@i</li>
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

</ul>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Il ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 in Razor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La sintassi di Razor include anche i più comuni costrutti sintattici, nell'esemp
io è mostrato l'utilizzo di un ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 le cui iterazioni generano nuovi elementi della lista 
\begin_inset Quotes eld
\end_inset

ul
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'organizzazione e le convenzioni utilizzate da MVC5 semplifica la definizione
 dell'intera applicazione, ed anche per la definizione delle viste è previsto
 un meccanismo per fattorizzare al meglio il proprio codice.
\end_layout

\begin_layout Standard
Per ogni vista da processare e visualizzare in risposta ad una richiesta
 HTTP, viene ricercato il file 
\begin_inset Quotes eld
\end_inset

_ViewStart.cshtml
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

cshtml
\begin_inset Quotes erd
\end_inset

 è l'estensione delle viste in Razor.
\end_layout

\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

Views
\begin_inset Quotes erd
\end_inset

.
 Per CSBlog è stato utilizzata per indicare quale sia il file Razor contenente
 il layout delle pagine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{
\end_layout

\begin_layout Plain Layout

	Layout = "~/Views/Shared/_Layout.cshtml";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Il contenuto della vista _ViewStart.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A differenza delle altre piattaforme, anche la scelta del layout può essere
 effettuata dinamicamente, permettendo di aver maggior controllo sull'aspetto
 delle proprie pagine semplicemente cambiando il percorso della risorsa
 o aggiungendo della logica all'assegnazione.
 Ad esempio è possibile definire più versioni del proprio sito, ottimizzandone
 l'uso in funzione del tipo di device che sta effettuando la navigazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<!DOCTYPE html>
\end_layout

\begin_layout Plain Layout

<html xmlns:th="http://www.thymeleaf.org">
\end_layout

\begin_layout Plain Layout

	@Html.Partial("_HeadPartial")
\end_layout

\begin_layout Plain Layout

	<body>
\end_layout

\begin_layout Plain Layout

		@Html.Partial("_HeaderPartial")
\end_layout

\begin_layout Plain Layout

		<div id="content">
\end_layout

\begin_layout Plain Layout

		@RenderBody()
\end_layout

\begin_layout Plain Layout

		</div>
\end_layout

\begin_layout Plain Layout

		@Html.Partial("_FooterPartial")
\end_layout

\begin_layout Plain Layout

	</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La struttura delle viste in CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per definire un layout è sufficiente creare una nuova vista con Razor ed
 utilizzare funzionalità come 
\begin_inset Quotes eld
\end_inset

Partial
\begin_inset Quotes erd
\end_inset

, per espandere il contenuto di una vista parziale, o 
\begin_inset Quotes eld
\end_inset

RenderBody
\begin_inset Quotes erd
\end_inset

 per espandere la vista restituita dall'azione che ha gestito la richiesta.
 Nell'esempio è mostrato com'è costituita la struttura di una pagina di
 CSBlog.
\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
Visual Studio, ASP.NET e l'EF sono software estremamente ampi, ricchi di
 funzionalità e professionali ma la creazione di una nuova applicazione
 per MVC5 definisce un progetto nel quale sono utilizzate la maggior parte
 delle componenti presenti nel framework.
 Navigando fra i sorgenti del progetto è possibile approfondirne le funzionalità
, intuirne le potenzialità e osservare le soluzioni proposte dal team di
 VS.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre ad includere un esempio di applicazione funzionante per ogni nuovo
 progetto, VS fornisce agli sviluppatori numerosi wizard per generare e
 configurare le nuove funzionalità.
 Durante il progetto non è mai stato necessario modificare manualmente i
 file XML per la configurazione dell'applicazione e l'introduzione di nuovi
 controlli, viste o entità non ha richiesto uno studio approfondito del
 framework per una singola funzionalità, come ad esempio per la definizione
 del modello con JPA.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Inoltre VS integra all'interno dell'ambiente di sviluppo tutte le diverse
 categorie di strumenti e linguaggi necessari per lo sviluppo di un'applicazione
 web.
 Oltre ai classici HTML, CSS e Javascript, è supportato di default lo sviluppo
 tramite Sass e Boostrap
\begin_inset Foot
status open

\begin_layout Plain Layout
Bootstrap è un'interessante framework, sviluppato originariamente da Twitter,
 per la definizione di pagine web responsive.
 E' particolarmente apprezzato per la definizione di siti facilmente navigabili
 da device mobile in quanto non prevede l'utilizzo di fogli di stile per
 definire la disposizione degli elementi nella pagina.
\end_layout

\end_inset

, tecnologie innovative per lo sviluppo di applicazioni Web.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-CSBlog!"

\end_inset

Hello CSBlog!
\end_layout

\begin_layout Standard
Nella sezione sono introdotti gli strumenti per effettuare la definizione
 dei test di accettazione automatici per CSBlog.
 Nella prima parte è descritto il processo di configurazione di Coypu, la
 libreria per l'automazione scelta per .NET, e di SpecFlow, il framework
 per il BDD.
 Successivamente sono introdotti i primi test e le funzionalità utilizzate
 per l'implementazione.
\end_layout

\begin_layout Subsection
SpecFlow
\end_layout

\begin_layout Standard
SpecFlow è un framework per .NET che utilizza alcune componenti di Cucumber
 come il DSL e il relativo parser, entrambe presenti pubblicamente su GitHub.
 Nonostante utilizzi Gherkin, non è un porting dell'intero framework in
 C# di cui al momento esistono le versioni Java, Ruby e JavaScript.
\end_layout

\begin_layout Paragraph
Le funzionalità
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La prima feature di SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Grazie all'utilizzo di SpecFlow è possibile riutilizzare la stessa libreria
 utilizzata per lo sviluppo di RBlog e SBlog.
 Nell'importazione e nello sviluppo dei post non sono state rilevate problemi
 legati al linguaggio ed ai costrutti sintattici utilizzati, sono però presenti
 delle differenze nell'implementazione, come verrà descritto nelle successive
 sezioni.
\end_layout

\begin_layout Paragraph
Supporto a Specflow in VS
\end_layout

\begin_layout Standard
Per utilizzare SpecFlow in VS è sufficiente installare tramite il gestore
 dei pacchetti il relativo plugin.
 Per eseguire le funzionalità e gli scenari tramite il runner di NUnit è
 necessario anche un pacchetto aggiuntivo, installabile tramite la console
 di NuGet utilizzando il comando seguente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Install-Package SpecFlow.NUnit
\begin_inset Caption Standard

\begin_layout Plain Layout
Installazione del plugin per SpecFlow in VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Completata l'installazione del software non è necessario compiere alcuna
 operazione di configurazione.
 Il plugin estende il funzionamento di VS aggiungendo il completo supporto
 a Gherkin, evidenziando la sintassi nelle diverse lingue esistenti, introducend
o l'autocompletamento all'interno dei file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, permettendo la navigazione da passo ad implementazione, permettendo la
 generazione automatica degli stub rappresentanti i passi e aggiungendo
 le funzionalità in Gherkin nei menù rapidi per la creazione delle risorse.
\end_layout

\begin_layout Standard
Per l'esecuzione delle funzionalità è possibile selezionare direttamente
 i file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, eventualmente utilizzando il tag 
\begin_inset Quotes eld
\end_inset

@ignore
\begin_inset Quotes erd
\end_inset

 per saltare alcuni scenari, oppure sfruttare l'integrazione con NUnit per
 scegliere quale sotto-insieme di scenari eseguire, è possibile sfruttare
 i diversi ordinamenti di NUnit per eseguire gli scenari in funzione di
 durata di esecuzione, risultato del test, tag utilizzati o namespace.
\end_layout

\begin_layout Subsection
Coypu
\end_layout

\begin_layout Standard
I parametri utilizzati per scegliere la libreiria per l'automazione della
 navigazione via browser favoriscono strumenti preferibilmente scritti nel
 linguaggio utilizzato per implementare l'applicazione web, il cui sviluppo
 sia attivo, che possibilmente siano open-source e che abbiano una comunità
 attiva per poter avere un riscontro in caso di difficoltà.
\end_layout

\begin_layout Standard
L'individuazione di una libreria per .NET che soddisfasse questi parametri
 non è stato semplice.
 Oltre a Selenium, già utilizzato per Java, sono stati valutati Watin, il
 cui sviluppo è fermo dal 2011, e Telerick Testing Framework, che per quanto
 sia un progetto attivo e ben documentato, sembra non essere utilizzato
 ed essere privo di una propria comunità di utenti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Viste le diverse difficoltà nella scelta di una libreria è stata effettuata
 una scelta sperimentale utilizzando Coypu, un wrapper di Selenium Web Driver,
 scritto in C# che nella propria implementazione si ispira al DSL di Capybara.
\end_layout

\begin_layout Standard
Il progetto è stato rilasciato la prima volta 2011, 2 anni prima del rilascio
 della versione beta di Selenium 2.0 ed è attualmente sviluppato, anche se
 il supporto è principalmente effettuato dal un singolo autore.
 Nonostante si tratti di una libreria open-source utilizzata da una ridotta
 comunità, presenta un'interessante prospettiva dell'automazione della navigazio
ne web che merita di essere approfondita.
\end_layout

\begin_layout Standard
I principali obbiettivi di Coypu riguardano la semplificazione e razionalizzazio
ne delle funzionalità della libreria di Selenium e la definizione di una
 libreria che, come Capybara, permetta di descrivere i propri test nella
 maniera più vicina possibile a come un utente descriverebbe le proprie
 azioni sul browser.
\end_layout

\begin_layout Subsubsection*
Configurazione di una sessione di testing
\end_layout

\begin_layout Standard
Come effettuato per Selenium in SBlog, anche per Coypu è stato scelto di
 utilizzare un nuovo ambiente di testing per ogni scenario, aprendo una
 nuova finestra prima prima dell'esecuzione e rilasciando le risorse al
 termine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[BeforeScenario]
\end_layout

\begin_layout Plain Layout

public void Before(){
\end_layout

\begin_layout Plain Layout

	var sessionConfiguration = new SessionConfiguration             	{
\end_layout

\begin_layout Plain Layout

		Port = 1448,
\end_layout

\begin_layout Plain Layout

		Driver = typeof(SeleniumWebDriver),
\end_layout

\begin_layout Plain Layout

		Browser = Coypu.Drivers.Browser.PhantomJS,
\end_layout

\begin_layout Plain Layout

		Timeout = TimeSpan.FromSeconds(5)
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	_browser = new BrowserSession(sessionConfiguration);            	_browser.Maximi
seWindow();             	_objectContainer.RegisterInstanceAs(_browser);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Creazione-della-sessione."

\end_inset

Creazione della sessione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche in SpecFlow è possibile definire delle callback, nell'esempio è definito
 un hook 
\begin_inset Quotes eld
\end_inset

BeforeScenario
\begin_inset Quotes erd
\end_inset

 da eseguire prima di ogni scenario, contenente le istruzioni per la definizione
 di una sessione.
 In particolare tramite la classe 
\begin_inset Quotes eld
\end_inset

SessionConfigurazion
\begin_inset Quotes erd
\end_inset

 è impostata la porta del server web, il driver ed il browser utilizzato
 ed il tempo massimo di esecuzione di ricerca per un selettore all'interno
 della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AfterScenario]
\end_layout

\begin_layout Plain Layout

public void AfterScenario(){
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	_browser.Dispose();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Chiusura del browser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per rilasciare la sessione di testing è invocato il metodo 
\begin_inset Quotes eld
\end_inset

dispose
\begin_inset Quotes erd
\end_inset

 al termine di ogni scenario.
\end_layout

\begin_layout Subsubsection*
PhantomJS
\end_layout

\begin_layout Standard
Per utilizzare PhantomJS per come browser per i propri test, è necessario
 mantenere l'eseguibile all'interno del path del proprio sistema o all'interno
 della cartella 
\begin_inset Quotes eld
\end_inset

bin
\begin_inset Quotes erd
\end_inset

 del progetto in VS.
 Per installare il browser localmente è possibile utilizzare la console
 di Nuget ed eseguire il seguente comando.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

install-package phantomjs.exe
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Installazione locale di PhantomJS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"apro CSBlog")]
\end_layout

\begin_layout Plain Layout

public void DatoAproCSBlog(){
\end_layout

\begin_layout Plain Layout

	/*..*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro SBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro SBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In maniera paragonabile a Cucumber e Cucumber-JVM, l'implementazione di
 un passo coincide con la definizione di un metodo pubblico annotato con
 un attributo, come Given nell'esempio, per indicare tramite l'espressione
 regolare quale sia il passo implementato.
 I passi devono essere inseriti all'interno di classi annotate con l'attributo
 
\begin_inset Quotes eld
\end_inset

Binding
\begin_inset Quotes erd
\end_inset

.
 Rispetto però ai framework BDD utilizzati finora, Specflow è più rigido
 per quanto riguarda l'implementazione dei passi, per eseguire i passi degli
 scenari è obbligatorio che il tipo dichiarato in Gherkin coincida con l'attribu
to utilizzato.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Binding]
\end_layout

\begin_layout Plain Layout

public class Constraints : BaseStep     {
\end_layout

\begin_layout Plain Layout

	[Given(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

	[When(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

	public void DatoMiAutenticoCome(string email){
\end_layout

\begin_layout Plain Layout

		/*..*/
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*..*/
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione valida per una pre-condizione ed un evento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre è possibile definire lo scope per ogni metodo o classe che implementi
 le funzionalità scritte in Gherkin tramite l'attributo 
\begin_inset Quotes eld
\end_inset

Scope
\begin_inset Quotes erd
\end_inset

.
 E' possibile definire un comportamento più o meno vincolante in funzione
 del diverso posizionamento dell'attributo, annotando l'intera classe o
 il singolo metodo.
 Il codice del prossimo listato vincola la visibilità esprimendo le diverse
 condizioni disponibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Scope(Tag = "xyz", Feature = "Funzionalità", Scenario = "Prova")]
\begin_inset Caption Standard

\begin_layout Plain Layout
Definizione dello scope per 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Navigare all'interno del sito
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"apro CSBlog")]
\end_layout

\begin_layout Plain Layout

public void DatoAproCSBlog(){
\end_layout

\begin_layout Plain Layout

	browser.Visit("/");
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("CSBlog", browser.Title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come in Selenium, Coypu fornisce all'utente diverse funzionalità per navigare
 all'interno del browser.
 Tramite l'istanza di 
\begin_inset Quotes eld
\end_inset

BrowserSession
\begin_inset Quotes erd
\end_inset

, che include le funzionalità per la gestione del browser come il ridimensioname
nto della finestra, il refresh della pagina e la navigazione attraverso
 la cronologia, è possibile navigare esplicitamente ad un URL passato come
 parametro, nell'esempio è mostrato come sia anche possibile utilizzare
 un percorso relativo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void AcceptModalDialog(Options options = null);
\end_layout

\begin_layout Plain Layout

public void CancelModalDialog(Options options = null);
\end_layout

\begin_layout Plain Layout

public bool HasDialog(string withText, Options options = null);
\end_layout

\begin_layout Plain Layout

public bool HasNoDialog(string withText, Options options = null);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Alcune delle funzionalità presenti nella classe BrowserWindow.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Approfondendo le funzionalità incluse nella classe 
\begin_inset Quotes eld
\end_inset

BrowserWindow
\begin_inset Quotes erd
\end_inset

, si intuisce la propensione di Coypu per la definizione di metodi che rappresen
tino le normali iterazioni di un'utente con il browser durante la navigazione
 web e siano il più intuitivi possibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[When(@"navigo verso ""(.*)""")]
\end_layout

\begin_layout Plain Layout

public void QuandoNavigoVerso(string pageName){
\end_layout

\begin_layout Plain Layout

	Assert.True(browser.FindLink(pageName).Exists());             	browser.ClickLink(pa
geName);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La particolarità di Coypu è di organizzare la libreria in maniera che le
 funzionalità utilizzate di frequente siano facilmente accessibili.
 Ad esempio per utilizzare un collegamento presente nella pagina per navigare
 all'interno del sito è sufficiente utilizzare il metodo 
\begin_inset Quotes eld
\end_inset

ClickLink
\begin_inset Quotes erd
\end_inset

 esistente all'interno della classe 
\begin_inset Quotes eld
\end_inset

BrowserWindow
\begin_inset Quotes erd
\end_inset

 che rappresenta la sessione di navigazione ed è quindi già istanziata al
 momento dell'esecuzione dei test.
\end_layout

\begin_layout Standard
Inoltre il metodo 
\begin_inset Quotes eld
\end_inset

ClickLink
\begin_inset Quotes erd
\end_inset

 effettua il click dell'elemento in funzione del testo che appare e non
 di un selettore CSS o XPath, facilitando la definizione di test che mantengono
 la stessa prospettiva di un utente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

FindLink
\begin_inset Quotes erd
\end_inset

 permette la ricerca all'interno di un DOM di un collegamento in funzione
 del testo fornito come parametro.
 Il metodo restituisce un'istanza di 
\begin_inset Quotes eld
\end_inset

ElementScope
\begin_inset Quotes erd
\end_inset

 che rappresenta un tag presente nel DOM, in maniera simile a Capybara,
 sono presenti numerose proprietà per ottenere informazioni sull'elemento
 ed i metodi per eseguire le azioni.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Al fine di semplificare la definizione dei test, include in tutte le funzionalit
à che effettuano analizzano il DOM un meccanismo di attesa implicito.
 Assumendo che ogni elemento possa essere il risultato di un'operazione
 asincrona, presente in Capybara e solo recentemente in Selenium, permette
 all'utente di definire test più semplici e mantenibili.
 Come definito nel metodo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Creazione-della-sessione."

\end_inset

, che rappresenta la creazione e configurazione di una nuova sessione per
 la verifica di uno scenario, è possibile impostare sia il valore di attesa
 massimo che la frequenza di pooling desiderata.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una carenza riscontrata nelle prime fasi di sviluppo è l'assenza di una
 documentazione che chiarisca il funzionamento della libreria.
 Nonostante Coypu permetta di intuire il funzionamento delle proprie funzionalit
à direttamente dalla segnatura dei metodi, la definizione di qualche esempio
 ne semplificherebbe l'utilizzo.
\end_layout

\begin_layout Paragraph
Definire asserzioni con NUnit
\end_layout

\begin_layout Standard
NUnit è una libreria per la definizione di unit-test in C# nata dal porting
 di JUnit, attualmente è alla versione 2.6 e lo sviluppo è svolto in maniera
 separata dalla versione Java.
\end_layout

\begin_layout Standard
Nonostante i due progetti non siano più sviluppati dallo stesso team, utilizzand
o le asserzioni di NUnit è facile riconoscere l'origine comune.
 Ad esempio nel successivo passo, sono utilizzati i metodi 
\begin_inset Quotes eld
\end_inset

AssertThat
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

AreEqual
\begin_inset Quotes erd
\end_inset

, che rispettivamente verificano la presenza di un elemento con identificatore
 HTML 
\begin_inset Quotes eld
\end_inset

logo
\begin_inset Quotes erd
\end_inset

 e effetua un confronto sul titolo della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Then(@"posso tornare alla pagina iniziale")]
\end_layout

\begin_layout Plain Layout

public void AlloraPossoTornareAllaPaginaIniziale(){
\end_layout

\begin_layout Plain Layout

	var logoLink = browser.FindId("logo");
\end_layout

\begin_layout Plain Layout

	Assert.That(logoLink.Exists());
\end_layout

\begin_layout Plain Layout

	logoLink.Click();
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("CSBlog", browser.Title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uno degli obbiettivi degli autori di NUnit è di definire dei metodi che,
 attraverso la propria segnatura, descrivano il proprio funzionamento e
 siano facilmente leggibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Assert.That(myString, Is.EqualTo("Hello"));
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Un possibile uso dell'asserzione 
\begin_inset Quotes eld
\end_inset

That
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

That
\begin_inset Quotes erd
\end_inset

 nell'esempio è utilizzato per verificare un valore booleano, in generale
 però è utilizzato per la sua caratteristica di accettare parametri 
\begin_inset Quotes eld
\end_inset

IConstraint
\begin_inset Quotes erd
\end_inset

.
 L'interfaccia definisce un insieme di metodi per rappresentare una condizione
 e, oltre alle classi esistenti nella libreria come mostrato nell'esempio,
 permette la definizione di classi personalizzate.
 In Coypu è presente una classe 
\begin_inset Quotes eld
\end_inset

Shows
\begin_inset Quotes erd
\end_inset

 che implementa diverse condizioni e aumenta la leggibilità delle asserzioni.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Assert.That(footer, Shows.Css("img"));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
Le funzionalità presenti nella libreria di Coypu non includono le funzionalità
 per leggere le proprietà di stile degli elementi presenti nel DOM di una
 pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Feature: Introducendo il CSS
\end_layout

\begin_layout Plain Layout

Per rendere l'esperienza di navigazione gradevole
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che il sito esponesse una grafica omogenea
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:02x00 Introducendo il CSS"

\end_inset

Seconda funzionalità per CSBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella funzionalità corrente dovrebbero essere verificati alcuni scenari
 relativi all'aspetto della pagina, in particolare gli effetti cromatici
 ampiamenti descritti nei precedenti capitoli e altre proprietà legate alla
 corretta visualizzazione degli elementi.
\end_layout

\begin_layout Standard
Nonostante gli sforzi dell'autore e degli sviluppatori, che frequentemente
 propongono le loro pull-request su GitHub, Coypu non può mantenere il livello
 di sviluppo di Selenium.
 Per fornire comunque pieno supporto ai propri utenti è possibile sfruttare
 la libreria nativa, utilizzata dalle stesse funzionalità di Coypu, come
 mostrato nel passo del listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Uso-delle-funzionalità"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"l'intestazione ha un colore di sfondo")]
\end_layout

\begin_layout Plain Layout

public void DatoLIntestazioneHaUnColoreDiSfondo(){
\end_layout

\begin_layout Plain Layout

	var selenium = ((OpenQA.Selenium.Remote.RemoteWebDriver)browser.Native);
\end_layout

\begin_layout Plain Layout

	var color = selenium.FindElementById("header").GetCssValue("background-color");
\end_layout

\begin_layout Plain Layout

	Assert.NotNull(color);
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("rgba(46, 47, 48, 1)", color);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Uso-delle-funzionalità"

\end_inset

Uso delle funzionalità native di Selenium.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel metodo è descritto l'utilizzo delle funzionalità di Selenium ed in particola
re l'invocazione del metodo 
\begin_inset Quotes eld
\end_inset

GetCssValue
\begin_inset Quotes erd
\end_inset

 per ottenere la rappresentazione 
\begin_inset Quotes eld
\end_inset

rgba
\begin_inset Quotes erd
\end_inset

 del colore di sfondo dell'intestazione.
\end_layout

\begin_layout Standard
La versione per C# di Selenium è estremamente simile a quella per Java,
 sintassi permettendo; per questo motivo non è stata completata l'implementazion
e degli scenari per la funzionalità corrente.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Standard
Nella sezione sono descritte le componenti di MVC5 che permettono la gestione
 delle entità attraverso CSBlog e lo sviluppo dei relativi test di accettazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Gestione dei post
\end_layout

\begin_layout Plain Layout

	Come Autore
\end_layout

\begin_layout Plain Layout

	Vorrei poter inserire, leggere, modificare e rimuovere dei post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter documentare la tesi
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:03x00 Modello"

\end_inset

Funzionalità dell'iterazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dipendenze
\end_layout

\begin_layout Standard
Anche per i test in CSBlog è necessario provvedere alla regressione del
 modello, rimuovendo dal database le entità create per verificare un particolare
 scenario.
 Come descritto nelle sezioni precedenti, con Coypu sono stati definiti
 due hook per la creazione e rilascio della sessione del browser, che assicura
 l'esecuzione dei test in nuovi ambienti ad ogni esecuzione e la rimozione
 di ogni cookie e sessione HTTP relativi a precedenti azioni.
\end_layout

\begin_layout Standard
Per completare il processo di regressione è necessario provvedere a rimuovere
 anche eventuali post creati negli scenari.
 La libreria di testing prevede l'utilizzo del tag 
\begin_inset Quotes eld
\end_inset

@clear
\begin_inset Quotes erd
\end_inset

 per segnalare le funzioalità o gli scenari che introducono ma non eliminano
 nuovi contenuti sul blog.
\end_layout

\begin_layout Standard
Nel successivo listato è mostrato l'intera callback eseguita alla conclusione
 degli scenari, indipendentemente dal risultato delle asserzioni.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [AfterScenario]         public void AfterScenario()         {  
           if (ScenarioContext.Current.ScenarioInfo.Tags.Contains("clear") 
                 || FeatureContext.Current.FeatureInfo.Tags.Contains("clear"))
             {                 login();
\end_layout

\begin_layout Plain Layout

                string LoremIpsumTitle = "Lorem Ipsum";                
 string xpathQuery = String.Format(                     "//div[@class = 'post'][p
/a[contains(text(),'{0}')]]", LoremIpsumTitle);
\end_layout

\begin_layout Plain Layout

                browser.Visit("/");                 foreach (var post in
 browser.FindAllXPath(xpathQuery)) {                     post.FindCss(".remove_post
_button").Click();                     browser.ClickButton("Confermi la rimozione?
");                                     }             }             _browser.Disp
ose();         }
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Callback relativa alla terminazione degli scenari.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'attributo 
\begin_inset Quotes eld
\end_inset

AfterScenario
\begin_inset Quotes erd
\end_inset

 accetta come parametri un numero variabile di tag per specificare per quali
 scenari debba essere eseguito il metodo.
 In Cucumber l'ordine di esecuzione degli hook coincide con l'ordine di
 registrazione dei metodi, mentre in Cucumber-JVM che sfrutta il meccanismo
 delle annotazioni, è possibile definire un'attributo per indicare la priorità
 di ciascuna callback.
\end_layout

\begin_layout Standard
Al contrario, in Specflow, non è possibile specificare alcun ordinamento
 ed invece di definire due callback, rispettivamente per la rimozione di
 eventuali post presenti nel blog e la conclusione della sessione di test,
 è necessario all'interno di un generico hook verificare manualmente la
 presenza del tag 
\begin_inset Quotes eld
\end_inset

@clear
\begin_inset Quotes erd
\end_inset

 per la funzionalità o lo scenario corrente ed eventualmente effettuare
 la rimozione degi post.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per implementare gli hook in SpecFlow è necessario utilizzare gli attributi
 per associare le callback agli eventi e implementare i metodi all'interno
 di classi annotate con l'attributo 
\begin_inset Quotes eld
\end_inset

Binding
\begin_inset Quotes erd
\end_inset

, come per la definizione dell'implemtazione dei passi.
\end_layout

\begin_layout Subsection
Gestione dei form
\end_layout

\begin_layout Standard
Nella sottosezione corrente è descritta l'implementazione delle componenti
 necessarie per l'impletazione della funzionalità per la creazione di un
 nuovo post.
 Come specificato nell'introduzione, VS permette la generazione dei controlli,
 attraverso un wizard di configurazione, e genera le corrispondenti viste.
\end_layout

\begin_layout Standard
Lo sviluppo si è svolto in maniera accellerata potendo sfruttare una struttura
 già esistente e dovendo esclusivamente personalizzarne il comportamento.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsubsection*
I controlli
\end_layout

\begin_layout Standard
Ad ogni componente è associato un controllo ed una collezione di azioni
 eseguibili, nel seguente frammento di codice sono mostrate le implementazione
 delle azioni per la creazione dei post.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    public class PostController : Controller     {         private CSBlogEntitie
s db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

       public ActionResult Create()         {             if (!isAuthorized())
                 return redirectToLoginPage();
\end_layout

\begin_layout Plain Layout

          return View();         }
\end_layout

\begin_layout Plain Layout

	/*..*/
\begin_inset Caption Standard

\begin_layout Plain Layout

Frammento di codice contente l'azione 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 per la visualizzazione della relativa vista.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come in RoR, sono presenti due metodi 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 per disaccoppiare la gestione della vista per la creazione di un nuovo
 post, contentente il form ed i campi del titolo e del contenuto, e la gestione
 della persistenza dell'oggetto definito attraverso l'interfaccia dell'applicazi
one nel modello.
\end_layout

\begin_layout Standard
Il ritorno di tipo 
\begin_inset Quotes eld
\end_inset

View
\begin_inset Quotes erd
\end_inset

, istanziato senza specificare parametri, risolve la richiesta visualizzando
 la vista 
\begin_inset Quotes eld
\end_inset

/Post/Create.cshtml
\begin_inset Quotes erd
\end_inset

 il cui nome coincide con l'identificatore dell'azione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// POST: /Post/Create        [HttpPost]         [ValidateAntiForgeryToken]
         public ActionResult Create([Bind(Include = "title,body")] Post
 post)         {             if (!isAuthorized())                 return
 redirectToLoginPage();             if (ModelState.IsValid)             {
                 post.id = Guid.NewGuid();                 post.createdAt =
 post.updatedAt = DateTime.Now;                                 post.authorId
 = (Guid)Session["author_id"];
\end_layout

\begin_layout Plain Layout

                db.Posts.Add(post);                 db.SaveChanges();     
            TempData["notice"] = String.Format("Il post '{0}' è stato creato
 con successo.", post.title);                 return RedirectToAction("Details",
 new { post.id });             }
\end_layout

\begin_layout Plain Layout

                   return View(post);         }
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:MVC5 Azione Persistenza Create"

\end_inset

Frammento di codice contente l'azione 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 persistenza del nuovo oggetto creato.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante la creazione di nuovi post sia stata suddivisa in due azioni,
 il metodo 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 è piusttosto articolato.
 Di seguito sono descritte le principali funzionalità:
\end_layout

\begin_layout Itemize
l'espressione boolean 
\begin_inset Quotes eld
\end_inset

ModelState.IsValid
\begin_inset Quotes erd
\end_inset

 verifica che i vincoli definiti a livello di logica dell'entità siano soddisfat
ti e si possa procedere nell'esecuzione delle istruzione per rendere persistenti
 i dati inseriti dall'utente;
\end_layout

\begin_layout Itemize
l'attributo 
\begin_inset Quotes eld
\end_inset

ValidateAntiForgeryToken
\begin_inset Quotes erd
\end_inset

 protegge l'applicazione, ed in particolare le pagine che permettono la
 definizione di nuovi contenuti, da attacchi di over-posting e dalla forgiatura
 di richieste 
\begin_inset Quotes eld
\end_inset

cross-site
\begin_inset Quotes erd
\end_inset

.
 Il processo per implementare la sicurezza dei form è abbastanza semplice
 e consiste con la generazione di un valore unico all'interno del form durante
 la visita della pagina e la copia del valore all'interno di un cookie HTTP
 creato ad-hoc, al momento dell'invio dei dati inseriti è verificato da
 MVC5 l'uguaglianza dei due valori eventualmente permettendo l'operazione;
\end_layout

\begin_layout Itemize
l'attributo 
\begin_inset Quotes eld
\end_inset

Bind
\begin_inset Quotes erd
\end_inset

 del parametro 
\begin_inset Quotes eld
\end_inset

post
\begin_inset Quotes erd
\end_inset

 specifica quali campi del form devono essere utilizzati per inizializzare
 l'oggetto, gli attributi della classe 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 comprendono anche altre informazioni che sono però inizializzate secondo
 la logica dell'applicazione;
\end_layout

\begin_layout Itemize
la proprietà Session permette l'accesso ai valori presenti nella corrente
 sessione HTTP,
\begin_inset space ~
\end_inset

in cui è mantenuto un riferimento all'identificatore dell'utente che ha
 effettuato l'autenticazione;
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

db.Posts.Add
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

db.SaveChanges
\begin_inset Quotes erd
\end_inset

 permettono aggiungono l'oggetto al modello e effettuano la persistenza
 delle modifiche.
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

RedirectToAction
\begin_inset Quotes erd
\end_inset

 restituisce un'istanza di tipo 
\begin_inset Quotes eld
\end_inset

RedirectToRouteResult
\begin_inset Quotes erd
\end_inset

 per effettuare la ridirezione della richiesta dopo aver creato il post.
 Combinando l'uso della ridirezione con il dizionario 
\begin_inset Quotes eld
\end_inset

TempData
\begin_inset Quotes erd
\end_inset

 è possibile fornire alla vista che verrà visualizzata al termine dell'azione
 corrente delle espressioni, il cui valore sarà mantenuto per una sola richiesta
 HTTP come valore all'interno della sessione corrente;
\end_layout

\begin_layout Itemize
Nel caso in cui la validazione degli attributi del post non sia andata a
 buon fine, il post restituisce un riferimento alla vista 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 fornendo lo stesso parametro ricevuto in input per inizializzare i campi
 del form;
\end_layout

\begin_layout Standard
Come in Spring, in cui è possibile sfruttare i parametri di tipo 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

 per per passare degli oggetti alla vista, in MVC5 è disponibile la proprietà
 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

ViewBag
\begin_inset Quotes erd
\end_inset

 presente nella super classe 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

.
 Il tipo 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

 in C# posticipa le operazioni di type-checking normalmente eseguite a compile
 time al momento dell'esecuzione, semplificando l'utilizzo delle proprietà
 come in questo caso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ViewBag.message = "Hello ViewBag";
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Esempio di utilizzo della proprietà 
\begin_inset Quotes eld
\end_inset

ViewBag
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Attribuita la stringa all'espressione dinamica, il valore sarà utilizzabile
 nelle viste in Razor.
\end_layout

\begin_layout Subsubsection*
Le viste
\end_layout

\begin_layout Standard
Dopo aver mostrato i controlli per la creazione di nuovi post, è ora descritta
 la vista per la creazione di nuovi post.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@model Blog.Models.Post
\end_layout

\begin_layout Plain Layout

@{     ViewBag.PageTitle = ViewBag.Title = "Crea un post"; }
\end_layout

\begin_layout Plain Layout

@using (Html.BeginForm()) {     @Html.AntiForgeryToken()     <div class="form-hori
zontal">
\end_layout

\begin_layout Plain Layout

        @Html.ValidationSummary(true)         <div class="form_actions">
             <input alt="Scrivi un nuovo post" id="submit" src="@Url.Content("~/I
mages/save_48.png")"                    type="image" value="Create" />  
       </div>         <p id="form_title">Scrivi un nuovo post</p>      
   <div class="form-group">             @Html.LabelFor(model => model.title,
 new { @class = "control-label" })             <div>                 @Html.Editor
For(model => model.title)                 <div class="error_explanation">
                     @Html.ValidationMessageFor(model => model.title)    
             </div>             </div>         </div>
\end_layout

\begin_layout Plain Layout

	<!-- ..
 -->
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In MVC, tramite le funzionalità di Razor è possibile tipare le proprie viste
 indicando, tramite la sintassi 
\begin_inset Quotes eld
\end_inset

@model
\begin_inset Quotes erd
\end_inset

, quale sia il tipo dell'entità rappresentata dalla pagina corrente.
 Nella classe 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

 sono presenti le funzionalità per istanziare degli oggetti di tipo 
\begin_inset Quotes eld
\end_inset

ViewResult
\begin_inset Quotes erd
\end_inset

 fornendo un istanza di 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

 che rappresenterà il modello, come mostrato nel listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:MVC5 Azione Persistenza Create"

\end_inset

 in caso di fallimento della validazione.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nella vista sono utilizzate diverse funzionalità di Razor:
\end_layout

\begin_layout Itemize
nella parte iniziale della vista sono inizializzati alcuni valori della
 proprietà 
\begin_inset Quotes eld
\end_inset

ViewBag
\begin_inset Quotes erd
\end_inset

 utilizzati all'interno della vista rappresentante il layout per impostare
 il titolo della pagina e dell'intestazione di CSBlog;
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

BeginForm
\begin_inset Quotes erd
\end_inset

, della classe 
\begin_inset Quotes eld
\end_inset

FormExtensions
\begin_inset Quotes erd
\end_inset

 di Razor, genera il codice HTML relativo all'elemento 
\begin_inset Quotes eld
\end_inset

form
\begin_inset Quotes erd
\end_inset

 e permette di utilizzare altri metodi per la definizione delle varie componenti
 del form;
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

ValidationSummary
\begin_inset Quotes erd
\end_inset

 restituisce le informazioni sulla validazione, nel caso in cui la vista
 attuale sia visualizzata come conseguenza del fallimento delle operazioni
 di persistenza;
\end_layout

\begin_layout Itemize
i metodi 
\begin_inset Quotes eld
\end_inset

LabelFor
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

EditorFor
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

TextAreaFor
\begin_inset Quotes erd
\end_inset

 generano gli elementi di input del form e i relativi 
\begin_inset Quotes eld
\end_inset

label
\begin_inset Quotes erd
\end_inset

 HTML;
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

ValidationMessageFor
\begin_inset Quotes erd
\end_inset

 ritorna i messaggi d'errore che descrivono i problemi riscontrati durante
 la validazione dell'entità, opportunamente formattati in HTML;
\end_layout

\begin_layout Subsubsection*
Gestione degli errori nei form
\end_layout

\begin_layout Standard
Utilizzando gli attributi dell'EF è possibile definire dei vincoli sugli
 attributi delle entità.
 Nel successivo listato è mostrato un frammento di codice relativo alla
 proprietà 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

 dell'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Required(ErrorMessage = "Titolo mancante.")]
\end_layout

\begin_layout Plain Layout

[StringLength(100, MinimumLength = 5, ErrorMessage = "Il titolo deve essere
 compreso fra 5 e 100 caratteri.")]
\end_layout

\begin_layout Plain Layout

[Remote("CheckForDuplication", "Post", AdditionalFields = "id")]
\end_layout

\begin_layout Plain Layout

[Display(Name = "Titolo", Description = "Inserisci in questo campo il titolo
 che vuoi dare al tuo articolo.")]         public string title { get; set;
 }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gli attributi 
\begin_inset Quotes eld
\end_inset

Required
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

StringLength
\begin_inset Quotes erd
\end_inset

 effettuano la verifica del valore della stringa e invalidano l'oggetto
 nel caso il titolo sia mancante, troppo corto o troppo lungo; è anche possibile
 associare a ciascun attributo un messaggio d'errore personalizzato che
 rappresenta il testo mostrato all'interno della vista.
\end_layout

\begin_layout Standard
Per effettuare operazioni di validazione come la verifica d'unicità del
 titolo, non è possibile sfruttare gli attributi già definiti in EF.
 Per verificare la presenza di altri post con il titolo uguale all'interno
 del blog è effettuata una richiesta HTTP asincrona tramite JQuery, definita
 tramite l'attributo 
\begin_inset Quotes eld
\end_inset

Remote
\begin_inset Quotes erd
\end_inset

 ed i parametri 
\begin_inset Quotes eld
\end_inset

CheckForDuplication
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 che rispettivamente rappresentano l'azione e l'azione che gestiranno la
 richiesta e il parametro aggiuntivo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
La verifica dell'unicità del titolo del post è effettuata sia alla creazione
 che alla modifica di un post, il parametro aggiuntivo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 può assumere valore nullo ed è utilizzato per associare il titolo passato
 di default come parametro GET all'identificatore del post.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Nel listato successivo, utilizzando LINQ per accedere al modello e JSon
 per definire il risultato dell'azione, è verificato in funzione dei parametri
 la presenza di eventuali post con titolo simili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [HttpGet]         public JsonResult CheckForDuplication(Guid? id,
 string title)         {             var post = db.Posts                
 .Where(p => p.title.Equals(title, StringComparison.CurrentCultureIgnoreCase))
                 .FirstOrDefault();             if (post != null && (id ==
 null || !post.id.Equals(id)))             {                 return Json("Il
 titolo è già presente.", JsonRequestBehavior.AllowGet);             }   
          return Json(true, JsonRequestBehavior.AllowGet);         }
\begin_inset Caption Standard

\begin_layout Plain Layout

Azione per la verifica dell'unicità del titolo dei post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Implementazione dei test
\end_layout

\begin_layout Standard
Oltre alle funzionalità per la navigazione, la classe 
\begin_inset Quotes eld
\end_inset

BrowserSession
\begin_inset Quotes erd
\end_inset

 di Coypu fornisce le funzionalità per la gestione dei form e selezionare
 gli elementi del DOM in funzione del tipo e del testo mostrato.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Given(@"mi autentico come ""(.*)""")]         [When(@"mi autentico
 come ""(.*)""")]         public void DatoMiAutenticoCome(string email) 
        {             string password = "password";             browser.ClickLink
("Login");             browser.FillIn("Email").With(email);             browser.Fil
lIn("Password").With(password);             browser.ClickButton("Login");
         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rispetto a Selenium, il DSL di Coypu è estremamente semplice e facilmente
 utilizzabile; inoltre è evidente la propensione della libreria a favorire
 la definizione di selettori in funzione del testo mostrato dai vari elementi.
\end_layout

\begin_layout Standard
Queste pratiche permettono la definizione di test leggibili e di semplice
 comprensione, semplificando le future manutenzioni del codice.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        protected ElementScope findPostByTitle(String title) {         
    return browser.FindAllCss(".post").First(p => p.FindLink(title, new Options
 { TextPrecision = TextPrecision.Substring }).Exists());         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo del listato precedente definisce una funzionalità ausiliaria per
 ricercare all'interno del DOM un post, contenuto all'interno di un 
\begin_inset Quotes eld
\end_inset

div
\begin_inset Quotes erd
\end_inset

 con attributo di 
\begin_inset Quotes eld
\end_inset

class
\begin_inset Quotes erd
\end_inset

 uguale a 
\begin_inset Quotes eld
\end_inset

post
\begin_inset Quotes erd
\end_inset

, il cui titolo, rappresentato da un collegamento, contenga il testo indicato
 dal parametro.
\end_layout

\begin_layout Standard
Il metodo è una funzionalità utile per individuare il l'elemento HTML che
 contiene le informazioni visualizzate per un certo post, il cui risultato
 è utilizzato per effettuare ulteriori accessi all'HTML interno.
\end_layout

\begin_layout Standard
Nelle versioni in Ruby e Java, lo stesso metodo è stato definito utilizzando
 un selettore ed un'espressione XPath.
 Con Coypu e le funzionalità dell'interfaccia 
\begin_inset Quotes eld
\end_inset

IEnumerable
\begin_inset Quotes erd
\end_inset

, che permettono l'uso di funzioni, è possibile definire query articolate
 ma allo stesso tempo comprensibili.
 Inoltre la definizione di selettori attraverso una concatenazione di metodi
 riduce la fragilità dei metodi semplificando le manutenibilità del codice
 e permette la verifica tramite la compilazione rispetto ad una query XPath
 rappresentata in una stringa.
\end_layout

\begin_layout Subsubsection*
Selettori
\end_layout

\begin_layout Standard
In Coypu sono implementati una buona varietà di metodi per l'implementazione
 di funzionalità per la definizione di selettori ed in generale effettuare
 ricerche all'interno del DOM.
 Oltre i metodi specifici per un tipo di elemento, come 
\begin_inset Quotes eld
\end_inset

FindLink
\begin_inset Quotes erd
\end_inset

 già mostrato in precedenza, sono presenti anche funzionalità più simili
 a quelle viste per Selenium.
\end_layout

\begin_layout Standard
Di seguito sono proposti alcuni esempi e frammenti dei passi contenti alcuni
 dei metodi esistenti nella libreria.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

            browser.FindCss(".post_title a", text: title).Exists();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In maniera simile a Capybara, ed in particolare ai metodi del modulo 
\begin_inset Quotes eld
\end_inset

Finders
\begin_inset Quotes erd
\end_inset

, nel metodo 
\begin_inset Quotes eld
\end_inset

FindCSS
\begin_inset Quotes erd
\end_inset

 è possibile specificare delle stringhe o delle espressioni regolari oltre
 alle regole del CSS.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        protected ElementScope header {get{return browser.FindId("header");}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre alle funzionalità classiche delle librerie di automazione web, come
 il metodo 
\begin_inset Quotes eld
\end_inset

FindId
\begin_inset Quotes erd
\end_inset

, Coypu cerca di fornire delle variazioni tramite parametri opzionali o
 implementando metodi derivati come 
\begin_inset Quotes eld
\end_inset

FindIdEndingWith
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 public void DatoIlPostNonELeggibileSuCSBlog(string title)         {   
          browser.Visit("/");             var posts = browser.FindAllCss(".post");
\end_layout

\begin_layout Plain Layout

            foreach (var post in posts) {                 Assert.That(!post.FindLi
nk(title).Exists());             }         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A differenza di Capybara, Coypu non restituisce errore nel caso in cui la
 venga utilizzato un metodo per individuare un singolo elemento ed al contrario
 siano presenti più potenziali risultati, ma restituisce il primo elemento
 incontrato.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per gestire collezioni di elementi sono disponibili metodi come 
\begin_inset Quotes eld
\end_inset

FindAllCss
\begin_inset Quotes erd
\end_inset

; rispetto ai metodi che restituiscono un singolo risultato, i metodi che
 ricercano tutti i potenziali riscontri all'interno della pagina non applicano
 strategie di attesa per eventuali elementi asincroni, bensì restituiscono
 la collezione di lementi presenti al momento dell'invocazione.
 Per modificare il comportamento è possibile definire un predicato per descriver
e lo stato desiderato.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Then(@"l_intestazione è posizionata all_inizio")]         public
 void AlloraLInizio()         {             var first = browser.FindXPath("//body
/*[1]");             Assert.True(first.Exists());             Assert.True(header.Exi
sts());             Assert.AreEqual(first.Id, header.Id);         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante la libreria propenda per l'utilizzo di funzionalità ad alto livello,
 per favorire la leggibilità dei test, è anche possibile definire i seletori
 tramite espressioni XPath.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        protected ElementScope FindNotice(string noticeMessage)        
 {             var notice = browser.FindId("notice", new Options { TextPrecision=
 TextPrecision.Exact});             Assert.That(notice.Exists());         
    return notice;         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In alcune parti della libreria si può notare la forte ispirazione che Capybara
 ha dato al progetto, ad esempio i metodi permettono l'uso di un parametro
 
\begin_inset Quotes eld
\end_inset

Options
\begin_inset Quotes erd
\end_inset

 che ricorda l'uso del dizionario come parametro opzionale in Ruby.
 Le istanze della classe 
\begin_inset Quotes eld
\end_inset

Options
\begin_inset Quotes erd
\end_inset

 permettono di modificare il comportamento dei metodi, specificando la strategia
 di attesa e di polling, il tipo di confronto sulle stringhe da utilizzare,
 la cardinalità attesa e molti altri parametri.
\end_layout

\begin_layout Subsection
Debug con Specflow
\end_layout

\begin_layout Standard
Durante lo sviluppo di CSBlog con VS sono state individuate alcune difficoltà
 nell'applicare la tecnica dell'ATDD a causa dell'impossibilità di eseguire
 il debug dei test.
 All'interno dell'ambiente di sviluppo è possibile eseguire la propria applicazi
one sia in modalità debug classica, VS monitora l'esecuzione ed eventualmente
 gestisce e segnala gli errori, oppure è possibile procedere all'esecuzione
 semplice.
\end_layout

\begin_layout Standard
Dai test fatti su VS, qualsiasi sia il tipo di escuzione dell'applicazione,
 sembra che non sia possile eseguire i propri test di accettazione in modalità
 debug, perchè è consentito che venga eseguito al più un solo processo;
 creando un secondo progetto contenente esclusivamente i test ed aprendo
 due istanze di VS, una per lo sviluppo ed una per il testing, si dovrebbe
 evitare i conflitti durante l'esecuzione, introducendo però possibili rallentam
enti nel sistema.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Login & Autorizzazione
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap6 Funzionalità: Autenticazione su SBlog   Come Autore di SBlog   Vorrei
 che alcune operazioni sensibili siano permesse previa autenticazione  
 Per poter garantire l'autenticità dei contenuti
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come per le funzionalità riguardanti l'analisi del CSS e delle proprietà
 estetiche dei nodi dell'HTML, Coypu non implementa metodi specifici per
 la gestione dei cookie e delle sessioni.
 E' comunque possibile utilizzare le funzionalità native per effettuare
 operazioni sui cookie e le sessioni HTTP come già descritto nella rispettiva
 sezione in SBlog.
\end_layout

\begin_layout Subsection
Accesso ai singoli attributi
\end_layout

\begin_layout Standard
La classe 
\begin_inset Quotes eld
\end_inset

ElementScope
\begin_inset Quotes erd
\end_inset

 di Coypu ridefinisce il comportamento dell'operatore 
\begin_inset Quotes eld
\end_inset

[ ]
\begin_inset Quotes erd
\end_inset

: come in Capybara, è possibile accedere ai singoli elementi indicando la
 stringa della proprietà desiderata.
 La scelta di accedere alle proprietà di un elemento HTML come si accederebbe
 ad un'array associativo presenta i vantaggi di essere facilmente leggibile
 e comprensibile, inoltre dal punto di vista dell'implementazione è facilmente
 estendibile nel caso il W3C prevedesse delle variazioni nell'HTML, come
 è ad esempio accaduto per la versione HTML5.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Asincronia
\end_layout

\begin_layout Standard
Coypu è apparso su GitHub, in versione open-source, per la prima volta nel
 2011.
 Nello stesso anno 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Coypu gestisce gli elementi della pagina con lo stesso principio di Capybara,
 ogni elemento può potenzialmente essere asincrono.
 Partendo proprio da questo presupposto è stato definito il progetto di
 Coypu, preferendo la definizione di una strategia di ricerca globale tramite
 attese e polling rispetto alla definizione di asserzioni sullo stato degli
 elementi, perchè difficili da esprimere, implementare e mantenere.
\end_layout

\begin_layout Subsection
JavaScript
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Easter Egging
\end_layout

\begin_layout Plain Layout

	Come Sviluppatore
\end_layout

\begin_layout Plain Layout

	Vorrei che nel blog fosse presente un mio logo
\end_layout

\begin_layout Plain Layout

	Per firmare il mio lavoro
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Contesto:     Dato apro CSBlog
\end_layout

\begin_layout Plain Layout

  Scenario: EasterEgg     Dato non è presente il logo nell'intestazione
     Quando clicco sull'area del pié di pagina     Allora è presente il
 logo
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:05bx00 EasterEgg"

\end_inset

Introduzione di un breve script Javascript.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nei successi listati è mostrata l'implementazione dello scenario 
\begin_inset Quotes eld
\end_inset

EasterEgg
\begin_inset Quotes erd
\end_inset

.
 Rispetto alle attese esplicite, ma anche a Capybara che sfrutta il metodo
 
\begin_inset Quotes eld
\end_inset

synchronize
\begin_inset Quotes erd
\end_inset

 per verificare il completamento delle operazioni asincrone, l'implementazione
 è nettamente più compatta e leggibile; inoltre non è presente alcuna particolar
ità rispetto ai test descritti nelle precedenti sessioni che suggerisca
 che il piè di pagina implementi un comportamento asincrono.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Given(@"non è presente il logo nell'intestazione")]         public
 void DatoNonEPresenteIlLogoNellIntestazione()         {             Assert.That(
footer, Shows.No.Css("img"));         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [When(@"clicco sull'area del pié di pagina")]         public void
 QuandoCliccoSullAreaDelPieDiPagina()         {             footer.Click();
         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Then(@"è presente il logo")]         public void AlloraEPresenteIlLogo(
)         {             var footer = base.footer;             Assert.That(footer,
 Shows.Css("img"));             Assert.That(footer.FindId("woodstock").Exists());
         }
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scenari sull'auto-completamento con JQuery UI
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap5 Funzionalità: Ricerca fra i post   Come Lettore   Vorrei poter ricercare
 i post su RBlog   Per poter navigare fra i contenuti più velocemente
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella funzionalità corrente è verificato il widget per l'auto-complemento
 del menu della ricerca, implementato tramite JQuery UI ed una chiamata
 AJAX.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Autocompletamento della ricerca
\end_layout

\begin_layout Plain Layout

	Dato nell'intestazione è presente la barra di ricerca
\end_layout

\begin_layout Plain Layout

	Dato il post "Lorem Ipsum" esiste
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "lor" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora viene proposto il post "Lorem Ipsum"
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "xyz" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora non è proposto alcun post
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario riguardante l'auto-completamento della ricerca.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nei successivi listati sono incluse le implementazioni dei passi che verificano
 la presenza del menù a tendina per il campo 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset

 della ricerca.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Then(@"viene proposto il post ""(.*)""")]         public void AlloraVien
ePropostoIlPost(string title)         {             var suggestion = browser.Find
Css(".ui-menu-item", title);             Assert.That(suggestion.Exists());
         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Coypu anche per uno scenario più complesso, in quanto l'operazione asincrona
 ha maggior latenza rispetto alla risoluzione della chiamata Javascript
 dello scenario 
\begin_inset Quotes eld
\end_inset

EasterEgg
\begin_inset Quotes erd
\end_inset

, non necessità di introdurre istruzioni ad-hoc.
 Inoltre Coypu è coerente nell'implementazione delle proprie funzionalità
 e restituisce solo elementi effettivamente visibili nella pagina
\begin_inset Foot
status open

\begin_layout Plain Layout
Tramite la configurazione della sessione di navigazione, è possibile richiedere
 che siano individuati anche gli elementi non visibili.
\end_layout

\end_inset

, al contrario utilizzando Selenium per questo stesso test è stato necessario
 verificare l'effettiva visualizzazione dell'elemento 
\begin_inset Quotes eld
\end_inset

ui-menu-item
\begin_inset Quotes erd
\end_inset

 tramite il metodo 
\begin_inset Quotes eld
\end_inset

isDisplayed
\begin_inset Quotes erd
\end_inset

 dell'interfaccia 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 a causa del comportamento particolare del widget.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Then(@"non è proposto alcun post")]         public void AlloraNonEPropo
stoAlcunPost()         {             Assert.That(browser, Shows.No.Css(".ui-menu-ite
m"));         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il widget per l'auto-completamento, probabilmente per minimizzare il numero
 di operazioni di modifica del DOM, applica un meccanismo simile al caching.
 Invece di rimuovere le opzioni proposte dalla pagina, che corrispondono
 ai punti di una lista numerata in HTML, rende non visibile l'intera lista
 ma ne mantiene gli elementi nel DOM.
 Quando sarà effettuata una nuova ricerca all'interno della pagina, il widget
 aggiusta la cardinalità della lista e sostiuisce il testo degli elementi
 con i nuovi valori.
\end_layout

\end_body
\end_document
