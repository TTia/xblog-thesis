#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\use_default_options true
\master ../Relazione.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Spring 13/11/14
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:spring"

\end_inset


\end_layout

\begin_layout Section
Spring MVC
\end_layout

\begin_layout Standard
In questo capitolo è trattato lo sviluppo di SBlog con Spring, un framework
 per la definizione di applicazioni web scritto in Java, e l'implementazione
 della libreria di test di accettazione automatici utilizzata per RBlog
 con Cucumber JVM e Selenium Web Driver.
\end_layout

\begin_layout Standard
La struttura di questo capitolo su Spring è simile al precedente: le prime
 sezioni descrivono l'architettura del framework, introducendo gli strumenti
 più significati nella definizione di SBlog, dalla sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-SBlog!"

\end_inset

 è descritto il processo d'implementazione delle funzionalità e scenari
 già descritti nel precedente capitolo, documentando tramite esempi e frammenti
 di test lo sviluppo dei test di accettazione.
\end_layout

\begin_layout Subsection
Spring Tool Suite
\end_layout

\begin_layout Standard
Spring Tool Suite, STS, è una versione personalizzata di Eclipse per supportare
 lo sviluppo tramite il framework.
 I plugin presenti nell'ambiente di sviluppo forniscono supporto per i diversi
 linguaggi nello sviluppo web, come HTML, CSS o Javascript, l'integrazione
 con le componenti del framework, come la creazione di progetti guidata
 o la rappresentazione grafica delle componenti dell'applicazione, e le
 funzionalità già presenti nella versione di Eclipse per Java EE, Enterprise
 Edition.
\end_layout

\begin_layout Standard
Per lo sviluppo di SBlog è stata utilizzata la versione 3.6.2 di Spring Tool
 Suite, basata su Eclipse Luna 4.4.
 Oltre ad utilizzare il software disponibile sul sito di Spring, è possibile
 anche installare le funzionalità di STS in una versione già esistente di
 Eclipse tramite l'apposito plugin.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:L'interpretazione di Spring del pattern MVC"

\end_inset

L'interpretazione di Spring del pattern MVC
\end_layout

\begin_layout Standard
Nella sezione saranno descritti le componenti dell'architettura MVC in funzione
 dell'interpretazione data da Spring.
 Rispetto a RoR, come descritto in seguito, il framework Java necessita
 di una maggiore configurazione delle sue componenti, sono quindi inclusi
 numerosi esempi per dare un'indicazione del processo di sviluppo e alcuni
 riferimenti.
\end_layout

\begin_layout Subsection
Il modello
\end_layout

\begin_layout Standard
Per l'implementazione del modello in Spring è stato utilizzato JPA 
\begin_inset Foot
status open

\begin_layout Plain Layout
Rispetto a RoR, in Spring si gode di estrema libertà nella scelta delle
 librerie da utilizzare per la propria applicazione web.
 
\end_layout

\end_inset

, Java Persistence API, una specifica Java per l'accesso, la persistenza
 e la gestione dei dati di DBMS relazionali, nella quale sono descritti
 i criteri per mappare un POJO, Plain Old Java Object, su un database.
\end_layout

\begin_layout Standard
Il vantaggio nell'utilizzo di una libreria che implementi la specifica,
 JPA infatti non fornisce alcuna implementazione, consiste nel poter modellare
 il dominio attraverso classi Java.
 Un POJO, termine introdotto da Martin Fowler
\begin_inset CommandInset citation
LatexCommand cite
key "POJO"

\end_inset

, è un oggetto Java che rappresenta le informazioni di un'entità del dominio
 e le relazioni che intercorrono con altri elementi attraverso l'insieme
 dei suoi attributi.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
EclipseLink è una delle implementazioni esistenti per JPA, fornisce tutte
 le funzionalità previste dallo standard alla versione 2.1, e rispetto ad
 altre librerie come Hibernate, attualmente è leggermente più performante
 ed ha una miglior gestione del caricamento delle entità.
\end_layout

\begin_layout Standard
JPA 2.1, la versione attuale, fornisce agli sviluppatori sia strumenti per
 effettuare la definizione dello schema sia per effettuare interrogazioni
 senza utilizzare SQL puro, mantenendo parte dell'astrazione introdotta
 utilizzando la tecnica ORM.
\end_layout

\begin_layout Subsubsection*
DDL con JPA
\end_layout

\begin_layout Standard
Lo schema del modello di SBlog è stato definito esclusivamente tramite le
 annotazioni previste dalla specifica, JPA fa ampio uso del meccanismo della
 reflection
\begin_inset Foot
status open

\begin_layout Plain Layout
Il meccanismo della reflection in Java permette di ispezionare il codice
 compilato al fine individuare elementi di interesse.
\end_layout

\end_inset

 per analizzare a run-time le entità esistenti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il dominio di SBlog è composto da due entità 
\begin_inset Quotes eld
\end_inset

Author
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 che rispettivamente descrivono gli autori del blog e gli articoli presenti,
 tramite i propri attributi d'istanza.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Entity
\end_layout

\begin_layout Plain Layout

public class Post {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione dell'entità Post.
\end_layout

\end_inset


\end_layout

\end_inset

Per dichiarare una nuova entità è necessario definire una classe Java e
 utilizzare l'annotazione 
\begin_inset Quotes eld
\end_inset

@Entity
\begin_inset Quotes erd
\end_inset

, che presenta diversi overload per specificare parametri come il nome della
 tabella utilizzato nello schema.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Id
\end_layout

\begin_layout Plain Layout

@GeneratedValue(strategy = GenerationType.TABLE)
\end_layout

\begin_layout Plain Layout

Integer id;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Column(nullable = false, unique = true)
\end_layout

\begin_layout Plain Layout

String title;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione di alcuni attributi per l'entità Post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rappresentata la tabella, per aggiungere delle colonne è sufficiente introdurre
 degli attributi d'istanza ed annotarli con 
\begin_inset Quotes eld
\end_inset

@Column
\begin_inset Quotes erd
\end_inset

 o altre annotazioni più specifiche.
\end_layout

\begin_layout Standard
Tramite i parametri è possibile dichiarare dei vincoli sui valori, ad esempio
 il titolo di un post deve essere sempre presente ed essere unico.
 Il tipo della colonna è inferito dal tipo Java, il tipo 
\begin_inset Quotes eld
\end_inset

Integer
\begin_inset Quotes erd
\end_inset

 corrisponde a 
\begin_inset Quotes eld
\end_inset

integer
\begin_inset Quotes erd
\end_inset

 in PostgreSQL e 
\begin_inset Quotes eld
\end_inset

String
\begin_inset Quotes erd
\end_inset

 a 
\begin_inset Quotes eld
\end_inset

varchar(255)
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per la definizione di colonne che rappresentano la chiave primaria della
 tabella è stata utilizzata l'annotazione 
\begin_inset Quotes eld
\end_inset

@Id
\begin_inset Quotes erd
\end_inset

 generando i valori in maniera univoca all'interno della tabella corrispondente
 all'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Temporal(TemporalType.TIMESTAMP)
\end_layout

\begin_layout Plain Layout

Date updatedAt;
\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione di un attributo temporale.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'annotazione 
\begin_inset Quotes eld
\end_inset

@Temporal
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
L'enumerazione 
\begin_inset Quotes eld
\end_inset

TemporalType
\begin_inset Quotes erd
\end_inset

 permette di specificare il tipo da mantere sul database, scegliendo fra
 
\begin_inset Quotes eld
\end_inset

java.sql.Date
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

java.sql.Time
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

java.sql.Timestamp
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 permette di rappresentare sul modello attributi di tipo 
\begin_inset Quotes eld
\end_inset

Date
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Calendar
\begin_inset Quotes erd
\end_inset

, non è ancora possibile utilizzare la classe 
\begin_inset Quotes eld
\end_inset

LocalDate
\begin_inset Quotes erd
\end_inset

 introdotta con Java 8 che fornisce diversi metodi per una migliore gestione
 delle fasce orarie.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre gli attributi primitivi che rappresentano le colonne delle tuple,
 sono presenti attributi composti: ogni articolo ha un solo autore ed ogni
 autore può scrivere più articoli, definendo una relazione uno a molti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Author {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	@OneToMany(..., fetch = FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

	Set<Post> posts;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public class Post {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

    @ManyToOne(..., fetch=FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

	Author author;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Le relazioni presenti fra le entità del modello.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con le annotazioni 
\begin_inset Quotes eld
\end_inset

OneToMany
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes erd
\end_inset

ManyToOne
\begin_inset Quotes erd
\end_inset

 e il parametro 
\begin_inset Quotes eld
\end_inset

fetch
\begin_inset Quotes erd
\end_inset

, è possibile caricare in maniera 
\begin_inset Quotes eld
\end_inset

lazy
\begin_inset Quotes erd
\end_inset

 le entità correlate, come i post scritti da un autore, posticipando l'operazion
e al momento dell'eventuale accesso.
 Al contrario, sfruttando il caricamento degli oggetti in maniera 
\begin_inset Quotes eld
\end_inset

eager
\begin_inset Quotes erd
\end_inset

, EclipseLink carica dal modello ogni attributo direttamente o indirettamente
 interessato dalla query, evitando successive interazioni con i database.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La definizione delle relazioni varia in funzione delle entità e di come
 è previsto che siano effettuati gli accessi ai POJO nell'applicazione.
 In JPA è possibile dichiarare relazioni unidirezionali, in cui l'associazione
 è mantenuta da un solo oggetto e non è possibile effettuare la navigazione
 in direzione contraria, oppure bidirezionali.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ManyToOne(cascade = {CascadeType.MERGE, CascadeType.REFRESH},
\end_layout

\begin_layout Plain Layout

	fetch=FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

@JoinTable(name = AUTHOR_POST_JOIN_TABLE,
\end_layout

\begin_layout Plain Layout

	joinColumns = @JoinColumn(name = POST_JOIN_COLUMN),          	inverseJoinColumn
s = @JoinColumn(name = AUTHOR_JOIN_COLUMN),             uniqueConstraints
 = @UniqueConstraint(columnNames = {                     	AUTHOR_JOIN_COLUMN,
 POST_JOIN_COLUMN}))
\end_layout

\begin_layout Plain Layout

Author author;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Attributo author per la classe Post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@OneToMany(mappedBy = "author",
\end_layout

\begin_layout Plain Layout

	cascade = { CascadeType.ALL },
\end_layout

\begin_layout Plain Layout

	fetch = FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

Set<Post> posts;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Attributo posts per la classe Author.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'attributo 
\begin_inset Quotes eld
\end_inset

fetch
\begin_inset Quotes erd
\end_inset

 specifica il comportamento di EclipseLink per il caricamento dei dati,
 
\begin_inset Quotes eld
\end_inset

cascade
\begin_inset Quotes erd
\end_inset

 definisce i vincoli di integrità referenziale di propagazione.
 A differenza di altre proprietà del DDL di JPA, la propagazione delle operazion
i non ha ripercussioni sullo schema dei database ed è gestita direttamente
 sui POJO; la mancanza di controlli sul DBMS obbliga a descrivere accuratamente
 la logica delle proprie operazioni CRUD, per mantenere la consistenza fra
 i record dei database e gli oggetti ed evitare errori.
\end_layout

\begin_layout Standard
Oltre alle relazioni utilizzate per SBlog sono ovviamente disponibili le
 annotazioni per implementare associazioni con altre cardinalità.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'annotazione 
\begin_inset Quotes eld
\end_inset

@JoinTable
\begin_inset Quotes erd
\end_inset

 dell'attributo 
\begin_inset Quotes eld
\end_inset

author
\begin_inset Quotes erd
\end_inset

 specifica la tabella ausiliaria in cui mantenere la relazione, che conterrà
 coppie formate da identificatori dell'autore e dell'articolo.
 
\begin_inset Quotes eld
\end_inset

@UniqueConstraint
\begin_inset Quotes erd
\end_inset

 introduce un vincolo di unicità.
 Inoltre scegliendo di rappresentare la relazione con un oggetto 
\begin_inset Quotes eld
\end_inset

Set
\begin_inset Quotes erd
\end_inset

 è possibile gestire la cardinalità dell'associazione direttamente al livello
 d'astrazione dei POJO.
\end_layout

\begin_layout Subsubsection*
Generazione dello schema
\end_layout

\begin_layout Standard
La configurazione di Spring avviene principalmente tramite DI, Dependency
 Injection, e la definizione di bean.
 I bean sono metodi factory che istanziano oggetti rappresentanti le diverse
 proprietà configurabili del framework; tramite la DI gli oggetti sono istanziat
i ed utilizzati quando opportuno.
\begin_inset Foot
status open

\begin_layout Plain Layout
La definizione dei bean può avvenire sia tramite factory method opportunamente
 annotati, sia utilizzando file XML.
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Bean
\end_layout

\begin_layout Plain Layout

public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
\end_layout

\begin_layout Plain Layout

	LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFact
oryBean();
\end_layout

\begin_layout Plain Layout

	em.setDataSource(dataSource());
\end_layout

\begin_layout Plain Layout

	em.setPackagesToScan("sblog.orm");
\end_layout

\begin_layout Plain Layout

	JpaVendorAdapter vendorAdapter = new EclipseLinkJpaVendorAdapter(); 	em.setJpaVe
ndorAdapter(vendorAdapter);
\end_layout

\begin_layout Plain Layout

	em.setJpaProperties(additionalProperties());
\end_layout

\begin_layout Plain Layout

	em.setJpaDialect(new EclipseLinkJpaDialect());
\end_layout

\begin_layout Plain Layout

	return em;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Configurazione Entity Manager"

\end_inset

Configurazione del metodo factory per la gestione delle entità del modello.
\end_layout

\end_inset


\end_layout

\end_inset

Per impostare la connessione ai database e configurare l'entity manager
 è necessario introdurre almeno due bean.
 In particolare il metodo factory 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Configurazione Entity Manager"

\end_inset

 specifica l'implementazione scelta per JPA e alcune proprietà attraverso
 un apposito metodo 
\begin_inset Quotes eld
\end_inset

additionalProperties
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Fra le proprietà configurabili di EclipseLink è possibile scegliere se generare
 direttamente il database o un script contenente il DDL, inoltre ad ogni
 avvio può essere verificato lo schema ed eventualmente apportate delle
 modiche se non stati fatti dei cambiamenti alle classi delle entità.
\end_layout

\begin_layout Subsubsection*
Query
\end_layout

\begin_layout Standard
Per semplificare la definizione di operazioni CRUD e effettuare delle interrogaz
ioni sul dominio, Spring include una gerarchia di interfacce Java generiche.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface PostRepository extends JpaRepository<Post, Integer> {
\end_layout

\begin_layout Plain Layout

	public Post findPostByTitle(String title); 
\end_layout

\begin_layout Plain Layout

	public List<Post> findPostByTitleContainingIgnoreCase(String title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:PostRepository"

\end_inset

Interfaccia PostRepository per la gestione e interrogazione dell'entità
 Post sul modello.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per utilizzare le funzionalità presenti nella libreria è stata creata un'interfa
ccia 
\begin_inset Quotes eld
\end_inset

PostRepository
\begin_inset Quotes erd
\end_inset

 che estende 
\begin_inset Quotes eld
\end_inset

JpaRepository
\begin_inset Quotes erd
\end_inset

.
 Come si può osservare nell'implementazione, l'interfaccia padre è generica
 sulla classe che rappresenta i post ed il tipo della chiave primaria.
\begin_inset Foot
status open

\begin_layout Plain Layout
L'uso di 
\begin_inset Quotes eld
\end_inset

Integer
\begin_inset Quotes erd
\end_inset

 come tipo della chiave primaria dell'entità Post, piuttosto che utilizzare
 il tipo primitivo 
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

, è stato dettato dalla necessità di usare il tipo come parametro generico
 di 
\begin_inset Quotes eld
\end_inset

JpaRepository
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'interfaccia 
\begin_inset Quotes eld
\end_inset

JpaRepository
\begin_inset Quotes erd
\end_inset

 estende le interfacce generiche 
\begin_inset Quotes eld
\end_inset

CrudRepository
\begin_inset Quotes erd
\end_inset

, che fornisce i metodi corrispondenti alle operazioni CRUD, 
\begin_inset Quotes eld
\end_inset

PagingAndSortingRepository
\begin_inset Quotes erd
\end_inset

 che definisce la possibilità di effettuare interrogazioni paginate
\begin_inset Foot
status open

\begin_layout Plain Layout
Data un'interrogazione, la paginazione restituisce un sottoinsieme delle
 entità risultato in funzione dei parametri di cardinalità e ordinalità,
 rispettivamente il numero di elementi del risultato e la pagina scelta.
\end_layout

\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Repository
\begin_inset Quotes erd
\end_inset

 che è la radice della gerarchia.
\begin_inset Newline newline
\end_inset

L'implementazione delle funzionalità dichiarate nelle interfaccia è fornita
 dalla libreria JPA Criteria, che inferisce dinamicamente dalla segnatura
 del metodo Java una query JPQL, Java Persistence query language.
\end_layout

\begin_layout Standard
JPQL è un linguaggio per la definizione di query che utilizza il paradigma
 ad oggetti, ad esempio le proiezioni SQL sono effettuate utilizzando la
 notazione puntata per l'accesso agli attributi.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
E' possibile estendere le numerose funzionalità presenti nella libreria
 dichiarando nuovi metodi, nell'interfaccia 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:PostRepository"

\end_inset

 sono stati introdotti due metodi che rispettano le convezioni introdotte
 dalla libreria Spring Data Repositories e generano interrogazioni sulle
 entità Post: il metodo 
\begin_inset Quotes eld
\end_inset

findPostByTitle
\begin_inset Quotes erd
\end_inset

 individua un singolo oggetto in funzione del parametro, mentre 
\begin_inset Quotes eld
\end_inset

findPostByTitleContainingIgnoreCase
\begin_inset Quotes erd
\end_inset

 interroga il modello per ottenere le entità il cui titolo soddisfi l'espression
e regolare.
\end_layout

\begin_layout Standard
Come si può intuire dal secondo metodo, l'implementazione di interrogazioni
 con un alto numero di condizioni di selezione comporta la dichiarazione
 di metodi con segnature eccessivamente lunghe e complicate, inoltre non
 è possibile utilizzare l'operazione di join fra entità.
 Per evitare a questi problema è possibile annotare i metodi del interfaccia
 repository con 
\begin_inset Quotes eld
\end_inset

@Query
\begin_inset Quotes erd
\end_inset

 specificando direttamente il testo dell'interrogazione in JPQL.
\end_layout

\begin_layout Subsection
I controlli
\end_layout

\begin_layout Standard
Rispetto a RoR, la cui configurazione dei controlli è principalmente inferita
 in funzione delle convenzioni del framework, in Spring è necessario utilizzare
 un discreto numero di annotazioni.
\end_layout

\begin_layout Standard
Come per RBlog, sono stati sviluppati tre controller per gestire le richieste
 riguardanti gli autori, i post e le procedure di autenticazione ed autorizzazio
ne.
 Un controller in Spring coincide con una classe, annotata con 
\begin_inset Quotes eld
\end_inset

@Controller
\begin_inset Quotes erd
\end_inset

 che ne definisce il ruolo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Controller
\end_layout

\begin_layout Plain Layout

@RequestMapping(value = "/posts")
\end_layout

\begin_layout Plain Layout

public class PostController extends AbstractController {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	@RequestMapping(value = "/{id}", method = RequestMethod.GET) 	public String
 show(@PathVariable Integer id, Model model) { 		Post post = /*...*/
\end_layout

\begin_layout Plain Layout

		model.addAttribute("page_title", post.getTitle());
\end_layout

\begin_layout Plain Layout

		model.addAttribute("content_template", "/posts/show");
\end_layout

\begin_layout Plain Layout

		model.addAttribute("posts", new Post[] { post });
\end_layout

\begin_layout Plain Layout

		return super.defaultMapping(model);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Dichiarazione metodo Show"

\end_inset

Dichiarazione di un controller per i Post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

PostController
\begin_inset Quotes erd
\end_inset

 è la classe che gestisce le richieste riguardanti gli articoli presenti
 sul blog.
 L'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestMapping
\begin_inset Quotes erd
\end_inset

 definisce i parametri delle richieste d'instradamento ed è utilizzabile
 sia per classi che singoli metodi.
 L'uso dell'annotazione per la classe specifica la radice delle richieste
 soddisfacibili dai metodi presenti.
\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

, che permette la lettura di un singolo post, soddisfa l'instradamento delle
 richieste HTTP del tipo 
\begin_inset Quotes eld
\end_inset

posts/42
\begin_inset Quotes erd
\end_inset

 concatenando gli attributi 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 dell'annotazione sulla classe e sul singolo metodo, semplificando la definizion
e di di controlli in stile REST.
\end_layout

\begin_layout Standard
Oltre a specificare gli URL delle richieste, tramite l'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestMapping
\begin_inset Quotes erd
\end_inset

 è possibile configurare quali tipi di connessioni HTTP sono accettati dal
 metodo, 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

 ad esempio accetta esclusivamente richieste in GET.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una particolarità del metodo 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

 è di essere parametrico sull'identificatore intero dei post, l'attributo
 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

/{id}
\begin_inset Quotes erd
\end_inset

 associa, previa conversione di tipo, il valore della stringa all'oggetto
 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 di tipo 
\begin_inset Quotes eld
\end_inset

Integer
\begin_inset Quotes erd
\end_inset

 annotato tramite 
\begin_inset Quotes eld
\end_inset

@PathVariable
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La struttura delle azioni a cui è associata una pagina web, come il metodo
 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

, prevede un oggetto di tipo 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

, utilizzato come parametro di output, al quale aggiungere coppie chiave-valore
 rappresentanti gli attributi dinamici necessari alla vista e una stringa
 come valore di ritorno per specificare l'elemento da renderizzare.
\end_layout

\begin_layout Standard
Per rendere più modulare SBlog, il ritorno delle azioni restituisce sempre
 una stringa che fa riferimento al layout del sito.
 Il parametro 
\begin_inset Quotes eld
\end_inset

content_template
\begin_inset Quotes erd
\end_inset

 utilizzato da un'apposita espressione in Thymeleaf, il template engine
 scelto per SBlog, definisce il contenuto della pagina, nell'esempio verrà
 visualizzata la vista 
\begin_inset Quotes eld
\end_inset

/posts/show
\begin_inset Quotes erd
\end_inset

.
 Maggiori dettagli su Thymeleaf sono presenti nella successiva sezione.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@RequestMapping(value = "/autocomplete_title", method = RequestMethod.GET)
\end_layout

\begin_layout Plain Layout

@ResponseBody
\end_layout

\begin_layout Plain Layout

public String[] autocompleteTitle(@RequestParam(value = "title", required
 = true) String title) {
\end_layout

\begin_layout Plain Layout

		return postService.queryByTitle(title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione di un metodo privo di interfaccia web.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per gestire le richieste HTTP di tipo GET, che includono i parametri direttament
e nell'URL, è utilizzata l'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestParam
\begin_inset Quotes erd
\end_inset

 che permette di ottenere un riferimento ai valori forniti e di introdurre
 anche dei vincoli, nell'esempio è richiesto che sia presente un parametro
 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

.
 Oltre agli attributi 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

required
\begin_inset Quotes erd
\end_inset

 è anche possibile definire un valore di default da applicare in assenza
 del dato.
\end_layout

\begin_layout Standard
Per ottenere un riferimento ad un parametro presente nel body di una richiesta
 HTTP è possibile utilizzare l'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestBody
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La particolarità del metodo 
\begin_inset Quotes eld
\end_inset

autocompleteTitle
\begin_inset Quotes erd
\end_inset

 rispetto all'azione 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

 descritta in precedenza è nel tipo di risposta che fornisce.
 Il metodo, definito per l'auto-completamento del widget di JQuery UI già
 presente in RBlog, restituisce la serializzazione di un array di stringhe
 invece che il riferimento ad una vista.
 L'annotazione 
\begin_inset Quotes eld
\end_inset

@ResponseBody
\begin_inset Quotes erd
\end_inset

 indica che il valore di ritorno dev'essere inserito all'interno di un 
\begin_inset Quotes eld
\end_inset

body
\begin_inset Quotes erd
\end_inset

 di una risposta web.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le azioni di Spring utilizzano ampiamente i parametri come output.
 Introducendo ulteriori parametri rispetto a quelli descritti finora negli
 esempi è possibile attivare e gestire funzionalità utili per le viste.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@RequestMapping(value = "/new", method = RequestMethod.POST) public String
 newPost(@Valid Post post, BindingResult bindingResult, 			Model model,
 RedirectAttributes redirectAttributes, 			HttpSession httpSession) {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ad esempio, la vista relativa alla scrittura di un nuovo articolo prevede
 la gestione di numerosi aspetti, a differenza di RoR che disaccoppia le
 azioni di gestione dei form e della persistenza dell'entità, in Spring
 i due comportamenti sono implementati insieme.
 I parametri utilizzati sono:
\end_layout

\begin_layout Itemize
un'istanza di tipo 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 che rappresenta l'articolo, l'oggetto può essere vuoto in quanto la pagina
 è appena stata visualizzata o contenente i dati dopo aver effettuato il
 salvataggio;
\end_layout

\begin_layout Itemize
un oggetto 
\begin_inset Quotes eld
\end_inset

BindingResult
\begin_inset Quotes erd
\end_inset

 che contiene i possibili messaggi di errore del processo di validazione
 per ogni elemento del form;
\end_layout

\begin_layout Itemize
un oggetto 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

 per fornire parametri alla vista;
\end_layout

\begin_layout Itemize
un oggetto 
\begin_inset Quotes eld
\end_inset

RedirectAttributes
\begin_inset Quotes erd
\end_inset

 per gestire la ridirezione in caso di salvataggio del post;
\end_layout

\begin_layout Itemize
un parametro 
\begin_inset Quotes eld
\end_inset

HttpSession
\begin_inset Quotes erd
\end_inset

 per la gestione della sessione e la verifica delle autorizzazioni;
\end_layout

\begin_layout Standard
La tecnica scelta da Spring per gestire i diversi aspetti comporta un'eccessiva
 mole di parametri e funzionalità da implementare in un singolo metodo.
 Sta allo sviluppatore intervenire fattorizzando le azioni e gestire manualmente
 le diverse casistiche, operazioni comodamente implementate di default in
 RoR alla creazione di un nuovo controllo.
\end_layout

\begin_layout Subsubsection*
I Service
\end_layout

\begin_layout Standard
Per fattorizzare la logica dei controller Spring definisce i service, classi
 Java annotate con 
\begin_inset Quotes eld
\end_inset

@Service
\begin_inset Quotes erd
\end_inset

 che hanno il compito di far interagire i controller con le classi repository
 definite dall'utente.
\end_layout

\begin_layout Standard
In SBlog è presente un 
\begin_inset Quotes eld
\end_inset

SessionService
\begin_inset Quotes erd
\end_inset

, che fornisce le funzionalità per l'autenticazione e la codifica delle
 password, e 
\begin_inset Quotes eld
\end_inset

PostService
\begin_inset Quotes erd
\end_inset

 che assicura la consistenza delle informazioni sul modello, ad esempio
 inizializzando la data di creazione e di aggiornamento un articolo alla
 creazione o alla modifica.
\end_layout

\begin_layout Standard
I service, così come gli helper in RoR, permettono di disaccoppiare la logica
 delle operazioni dalle azioni dei controller, permettendo un'implementazione
 più semplice delle componenti.
\end_layout

\begin_layout Subsubsection*
La dependecy injection
\end_layout

\begin_layout Standard
Per utilizzare al meglio le diverse componenti in SBlog è stato fatto ampio
 uso dell'annotazione 
\begin_inset Quotes eld
\end_inset

@AutoWired
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Controller
\end_layout

\begin_layout Plain Layout

@RequestMapping(value = "/posts")
\end_layout

\begin_layout Plain Layout

public class PostController extends AbstractController {
\end_layout

\begin_layout Plain Layout

	@Autowired 	
\end_layout

\begin_layout Plain Layout

	PostService postService;
\end_layout

\begin_layout Plain Layout

	@Autowired
\end_layout

\begin_layout Plain Layout

	AuthorService authorService;
\end_layout

\begin_layout Plain Layout

	@Autowired
\end_layout

\begin_layout Plain Layout

	SessionService sessionService;
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Uso dell'annotazione @Autowired.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per ogni componente esistente in Spring, sia essa un 
\begin_inset Quotes eld
\end_inset

@Repository
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

@Controller
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

@Service
\begin_inset Quotes erd
\end_inset

, è generato un corrispondente 
\begin_inset Quotes eld
\end_inset

bean
\begin_inset Quotes erd
\end_inset

.
 Grazie all'annotazione 
\begin_inset Quotes eld
\end_inset

@AutoWired
\begin_inset Quotes erd
\end_inset

 e alla dependency injection, le corrette istanze dei componenti sono 
\begin_inset Quotes eld
\end_inset

iniettate
\begin_inset Quotes erd
\end_inset

 quando necessario, semplificando notevolmente la risoluzione delle dipendenze.
\end_layout

\begin_layout Subsection
Le viste
\end_layout

\begin_layout Standard
Per l'implementazione delle viste di SBlog è stato utilizzato Thymeleaf,
 una libreria Java per la generazione dinamica di documenti web.
 La libreria, organizzata in due moduli contenenti le funzionalità standard
 e quelle specifiche per Spring, permette la definizione di pagine dinamiche
 utilizzando esclusivamente elementi sintattici esistenti nell'HTML.
 Al contrario ERB e Razor, il template engine di MVC 5 descritto nel prossimo
 capitolo, prevedono l'utilizzo di delimitatori per includere frammenti
 di codice non interpretabili da un browser ma da processare tramite un
 server web.
\end_layout

\begin_layout Standard
Dopo essermi documentato sui template engine comunemente utilizzati con
 Spring e Java, ho scelto di non implementare le viste tramite JSP, JavaServer
 Page.
 Il motivo principale della scelta sono i diversi problemi tecnici nella
 configurazione della libreria utilizzando Spring MVC 4 e Spring Boot, che
 verrà discusso in seguito.
\end_layout

\begin_layout Subsubsection*
Thymeleaf
\end_layout

\begin_layout Standard
Tutti gli attributi utilizzati dalla libreria sono presenti nel namespace
 
\begin_inset Quotes eld
\end_inset

http://www.thymeleaf.org
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
In eclipse è presente un plugin per assistere lo sviluppatore nella definizione
 delle viste tramite l'auto-completamento e la colorazione delle parole
 chiave.
\end_layout

\end_inset

; una vista definita con Thymeleaf ha estensione e struttura identica ad
 un documento HTML statico: senza il supporto di un server web i tag introdotti
 dalla libreria non vengono analizzati dai browser permettendo l'implementazione
 di prototipi offline, per sviluppare l'interfaccia dell'applicazione non
 è quindi necessario aver già un'architettura MVC funzionante.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html xmlns:th="http://www.thymeleaf.org">
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione del namespace.
\end_layout

\end_inset


\end_layout

\end_inset

Come in RoR, uno degli obbiettivi nella definizione delle viste è individuare
 delle tecniche per fattorizzare gli elementi comuni.
 Tramite l'attributo 
\begin_inset Quotes eld
\end_inset

th:replace
\begin_inset Quotes erd
\end_inset

 è possibile sostituire il nodo corrente con un'intera vista.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<!DOCTYPE html>
\end_layout

\begin_layout Plain Layout

<html xmlns:th="http://www.thymeleaf.org">
\end_layout

\begin_layout Plain Layout

	<head th:replace="/layouts/head"/>
\end_layout

\begin_layout Plain Layout

	<body th:class="${class_name}">
\end_layout

\begin_layout Plain Layout

		<div id="header" th:replace="/layouts/header"></div>
\end_layout

\begin_layout Plain Layout

		<div th:replace="${content_template}"></div>
\end_layout

\begin_layout Plain Layout

		<div id="footer" th:replace="/layouts/footer"></div>
\end_layout

\begin_layout Plain Layout

	</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Struttura comune delle viste in SBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le viste in SBlog prevedono un elemento 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

, contenente i riferimenti alle risorse come fogli di stile
\begin_inset Foot
status open

\begin_layout Plain Layout
A differenza di RoR e RubyMine, nella definizione delle viste non è stato
 utilizzato Sass, o altre estensioni del CSS, per la mancanza di plugin
 in Eclipse che forniscano la compilazione automatica ed il supporto alla
 scrittura delle pagine di stile.
\end_layout

\end_inset

 e librerie JavaScript.
 Il 
\begin_inset Quotes eld
\end_inset

body
\begin_inset Quotes erd
\end_inset

 è suddiviso in tre principali aree: l'intestazione, il contenuto principale
 ed il piè di pagina.
\begin_inset Newline newline
\end_inset

Indicativamente, ogni attributo presente in HTML5 ha una controparte in
 Thymeleaf per la definizione di comportamenti dinamici, brevemente nelle
 prossime sezioni sono introdotte le funzionalità utilizzate ed alcuni frammenti
 delle viste che le contengono.
\end_layout

\begin_layout Subsubsection*
Visualizzazione dei post
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class='post' th:each="post : ${posts}">
\end_layout

\begin_layout Plain Layout

	<p class="post_title">
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:TL Iterazione sui post"

\end_inset

Iterazione su una collezione di post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'attributo 
\begin_inset Quotes eld
\end_inset

each
\begin_inset Quotes erd
\end_inset

 presente nel primo nodo della vista parziale permette di iterare su una
 collezione 
\begin_inset Quotes eld
\end_inset

posts
\begin_inset Quotes erd
\end_inset

 in maniera simile al costrutto 
\begin_inset Quotes eld
\end_inset

foreach
\begin_inset Quotes erd
\end_inset

 di Java.
 Gli oggetti presenti nella vista sono acceduti tramite l'istanza di 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

 presente nell'azione del controller che ha gestito la richiesta; l'espressione
 
\begin_inset Quotes eld
\end_inset

${id}
\begin_inset Quotes erd
\end_inset

 effettua l'accesso all'elemento associato alla chiave 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class="post_detail" th:text="${post.creationDetail()}"></div>
\end_layout

\begin_layout Plain Layout

<div class="post_detail" th:text="${post.author.authorDetail()}"></div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Iterazione sugli attributi di un post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'interno delle espressioni di Thymeleaf gli attributi forniti alla vista
 sono oggetti ed è quindi possibile accedere ai metodi d'istanza e ai valori.
 L'attributo 
\begin_inset Quotes eld
\end_inset

text
\begin_inset Quotes erd
\end_inset

 sostituisce il testo presente all'interno del nodo HTML con il valore dell'espr
essione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<a th:if="${post.body.length()} > 500" th:href="|/posts/${post.id}|">
\end_layout

\begin_layout Plain Layout

	Leggi 			il resto...
\end_layout

\begin_layout Plain Layout

</a>
\begin_inset Caption Standard

\begin_layout Plain Layout
Utilizzo di un'espressione if.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre all'attributo 
\begin_inset Quotes eld
\end_inset

each
\begin_inset Quotes erd
\end_inset

 sono presenti altre istruzioni, come 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

unless
\begin_inset Quotes erd
\end_inset

, per controllare il flusso dell'esecuzione.
 Nell'esempio il collegamento verrà visualizzato in funzione della guardia,
 in generale l'uso di costrutti come 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

 condiziona la visita da parte di Thymeleaf di tutto il sotto-albero.
\end_layout

\begin_layout Subsubsection*
Gestione dei form
\end_layout

\begin_layout Standard
La gestione dei form è uno dei contesti per cui Thymeleaf è stata specializzato
 per integrarsi al meglio con le funzionalità di Spring.
 Per implementare la verifica dei dati inseriti nei form, in Spring è possibile
 utilizzare le annotazioni presenti nel package 
\begin_inset Quotes eld
\end_inset

javax.validation.constraints
\begin_inset Quotes erd
\end_inset

 di JPA per validare i valori dei singoli attributi, non è possibile ad
 esempio verificare che il titolo di un post non sia già presente nel dominio.
\end_layout

\begin_layout Standard
A differenza di RoR, dove la validazione dei form coincide con la validazione
 effettuata dai database, gli strumenti di Spring replicano i meccanismi
 esistenti a basso livello e permettono di anticipare tali verifiche.
 Questa scelta comporta la duplicazione dei vincoli sul dominio, esprimendoli
 sia a livello logico che di persistenza.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Size(min=5, max=100, message = "Il titolo deve essere compreso fra 5 e
 100 caratteri.")
\end_layout

\begin_layout Plain Layout

@NotNull(message = "Titolo mancante.")
\end_layout

\begin_layout Plain Layout

@Column(nullable = false, unique = true)
\end_layout

\begin_layout Plain Layout

String title;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Uso delle annotazioni di JPA per la validazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre alle annotazioni della libreria è possibile implementarne di personalizzat
e, ad esempio che verifichino l'unicità del titolo, definendo una nuova
 annotazione e una classe contenente la logica.
 Purtroppo nella definizione del vincolo di unicità, sono stati rilevati
 errori nell'uso dei repository istanziati tramite DI e ho dovuto implementarne
 la logica manualmente nel controllo dei post.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Gli errori del form sono forniti ai controller tramite un parametro di tipo
 
\begin_inset Quotes eld
\end_inset

BindingResult
\begin_inset Quotes erd
\end_inset

, già introdotto nella precedente sezione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class="error_explanation" th:if="${#fields.hasErrors('title')}">
\end_layout

\begin_layout Plain Layout

	<p id="error_description" th:errors="*{title}"></p>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento della vista per la visualizzazione degli errori sul campo del
 titolo.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'interno delle viste di Thymeleaf sono state utilizzate le funzionalità
 della classe ausiliaria 
\begin_inset Quotes eld
\end_inset

fields
\begin_inset Quotes erd
\end_inset

, che implementa le funzionalità per la gestione della compilazione dei
 form HTML.
\begin_inset Foot
status open

\begin_layout Plain Layout
Sono presenti altre classi per il supporto di operazioni comuni nelle viste,
 come la formattazione di date.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rispetto a ERB e Razor, le viste sviluppate con Thymeleaf appaiono più semplici
 e leggibili.
 Utilizzando gli attributi per generare il contenuto dinamico si riduce
 sensibilmente la propensione ad introdurre logica all'interno delle viste,
 rispettando i ruoli delle componenti del pattern MVC.
 Tuttavia Thymeleaf introduce una sintassi articolata e non molto intuitiva
 che può costituire un ostacolo ad una rapida definizione della logica elementar
e di una vista, come la formattazione di una stringa o la generazione dinamica
 di collegamenti.
\end_layout

\begin_layout Subsection
Il testing
\end_layout

\begin_layout Standard
Spring implementa le funzionalità per definire unit ed integration test.
 Per SBlog non sono stati implementati test oltre a quelli di accettazione,
 la struttura e la logica è molto simile a quanto sviluppato su RoR, ma
 ritengo sia utile fornire qualche riferimento.
\begin_inset Newline newline
\end_inset

L'implementazione di unit-test in Spring è possibile grazie alla DI e a
 oggetti mock per poter testare in isolamento le singole funzionalità.
\end_layout

\begin_layout Standard
Per implementare i propri integration-test non è necessario effettuare il
 deploy dell'intera applicazione, infatti sfruttando le funzionalità presenti
 nel modulo 
\begin_inset Quotes eld
\end_inset

spring-test
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Spring Test-Framework"

\end_inset

 è possibile verificare l'interazione delle diverse componenti.
\begin_inset Newline newline
\end_inset

Tutti i test in Spring sono eseguibili tramite JUnit
\begin_inset CommandInset citation
LatexCommand cite
key "JUnit"

\end_inset

: l'annotazione 
\begin_inset Quotes eld
\end_inset

@RunWith
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "JUnit RunWith"

\end_inset

 permette di configurare quale runner utilizzare, è quindi possibile uniformare
 l'ambiente di testing e le funzionalità di supporto per tutti i differenti
 livelli di verifica dell'applicazione.
 Maggiori dettagli su JUnit sono presenti nella prossima sezione.
\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
Spring è estremamente modulare e consente all'utente piena libertà nella
 scelta degli strumenti, che comporta tuttavia la necessità di configurare
 i relativi bean.
 Per semplificare lo sviluppo dell'applicazione è stato utilizzato Spring
 Boot, un progetto degli stessi sviluppatori del framework.
\end_layout

\begin_layout Standard
Per ridurre al minimo la necessità di configurazione di una nuova applicazione,
 è possibile utilizzare i progetti 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

 esistenti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependencies>
\end_layout

\begin_layout Plain Layout

	<dependency>
\end_layout

\begin_layout Plain Layout

		<groupId>org.springframework.boot</groupId> 		<artifactId>spring-boot-starter-we
b</artifactId>
\end_layout

\begin_layout Plain Layout

	</dependency>
\end_layout

\begin_layout Plain Layout

	<dependency>
\end_layout

\begin_layout Plain Layout

		<groupId>org.springframework.boot</groupId>
\end_layout

\begin_layout Plain Layout

		<artifactId>spring-boot-starter-thymeleaf</artifactId>
\end_layout

\begin_layout Plain Layout

	</dependency>
\end_layout

\begin_layout Plain Layout

	<dependency>
\end_layout

\begin_layout Plain Layout

		<groupId>org.springframework.boot</groupId>
\end_layout

\begin_layout Plain Layout

		<artifactId>spring-boot-starter-data-jpa</artifactId>
\end_layout

\begin_layout Plain Layout

		<exclusions>
\end_layout

\begin_layout Plain Layout

			<exclusion> 				<artifactId>hibernate-entitymanager</artifactId>
\end_layout

\begin_layout Plain Layout

				<groupId>org.hibernate</groupId>
\end_layout

\begin_layout Plain Layout

			</exclusion>
\end_layout

\begin_layout Plain Layout

		</exclusions>
\end_layout

\begin_layout Plain Layout

	</dependency>
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Alcuni 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

 di Spring Boot utilizzati per SBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aggiungendo gli opportuni 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

 alle dipendenze del proprio progetto, nell'esempio è mostrato un frammento
 del POM
\begin_inset Foot
status open

\begin_layout Plain Layout
Un POM, Project Object Model, è un file XML utilizzato da Maven per la definizio
ne delle informazioni del progetto.
 All'interno del file è possibile definire diversi processi di compilazione,
 ad esempio includendo o meno le librerie per il testing, dichiarare le
 dipendenze del progetto e molto altro.
\end_layout

\end_inset

 di SBlog ma è possibile utilizzare anche Gradle, le maggior parte delle
 componenti e dei bean necessari sono configurati con le impostazioni più
 comuni.
 Ovviamente alcune proprietà specifiche, come le credenziali per la connessione
 ai database, sono da impostare manualmente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le componenti non configurabili tramite Spring Boot, sia perché troppo specifich
e sia perché riguardanti strumenti non presenti negli 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

, sono configurabili tramite i bean.
 Spring, attualmente alla versione 4.1, è retro-compatibile permettendo la
 definizione di bean attraverso file XML, definendo una gerarchia di classi
 o tramite l'annotazione 
\begin_inset Quotes eld
\end_inset

@Bean
\begin_inset Quotes erd
\end_inset

 ed i factory method, tecnica utilizzata in SBlog.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-SBlog!"

\end_inset

Hello SBlog!
\end_layout

\begin_layout Standard
Per effettuare un confronto il più attendibile possibile, la libreria di
 test di accettazione definita per RBlog e scritta in Gherkin è stata riutilizza
ta anche per la versione del blog in Spring.
 I due blog sono equivalenti nelle funzionalità e molto simili nelle nelle
 tecnologie utilizzate, in questa e nelle prossime sezioni è descritto il
 processo di definizione dei test, omettendo però la descrizione dei tool
 già utilizzati per RBlog.
\end_layout

\begin_layout Subsection
Cucumber-JVM
\end_layout

\begin_layout Standard
Cucumber-JVM, il porting in Java del framework per Cucumber, presenta differenze
 minime rispetto alla versione per Ruby, principalmente dovute alle diversità
 del linguaggio.
\end_layout

\begin_layout Paragraph
Le funzionalità
\end_layout

\begin_layout Standard
Il linguaggio utilizzato per la definizione delle funzionalità e degli scenari
 è Gherkin, utilizzando i test già scritti per RBlog non è stato rilevato
 alcun problema sintattico né relativo alle funzionalità supportate dalla
 versione Java di Cucumber.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La prima feature di SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Avendo già descritto la struttura di una funzionalità in Gherkin, è possibile
 concentrare l'attenzione sulla configurazione del framework.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>info.cukes</groupId> 	<artifactId>cucumber-junit</artifactId>
\end_layout

\begin_layout Plain Layout

	<version>1.1.8</version>
\end_layout

\begin_layout Plain Layout

	<scope>test</scope>
\end_layout

\begin_layout Plain Layout

</dependency>
\end_layout

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>info.cukes</groupId> 	<artifactId>cucumber-picocontainer</artifactId>
 	<version>1.1.8</version>
\end_layout

\begin_layout Plain Layout

	<scope>test</scope>
\end_layout

\begin_layout Plain Layout

</dependency>
\begin_inset Caption Standard

\begin_layout Plain Layout
Aggiunta delle dipendenze per il BDD in Maven.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per l'esecuzione dei test in Java innanzitutto è necessario includere le
 dipendenze all'interno del POM di Maven.
 Oltre a 
\begin_inset Quotes eld
\end_inset

cucumber-junit
\begin_inset Quotes erd
\end_inset

 è necessario includere anche PicoContainer, una libreria per il supporto
 alla DI utilizzata per individuare le classi contenenti gli hook e le definizio
ne dei passi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@RunWith(Cucumber.class)
\end_layout

\begin_layout Plain Layout

@CucumberOptions(format = {tags = {"@cap1", "~@ignore"})
\end_layout

\begin_layout Plain Layout

public class RunCukesTest {}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Runner per Cucumber-JVM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aggiunte le dipendenze e le funzionalità è sufficiente configurare un classe
 con le annotazioni di JUnit per eseguire i test.
 L'annotazione 
\begin_inset Quotes eld
\end_inset

@CucumberOptions
\begin_inset Quotes erd
\end_inset

 indica i tag degli scenari da eseguire.
\end_layout

\begin_layout Paragraph
Supporto a Cucumber in RubyMine
\end_layout

\begin_layout Standard
Per Eclipse è disponibile un plugin per Cucumber
\begin_inset CommandInset citation
LatexCommand cite
key "Eclipse Cucumber JVM Plugin"

\end_inset

 che fornisce la formattazione del codice scritto in Gherkin, l'auto-completamen
to e l'evidenziatura della sintassi per tutte le lingue supportate.
\end_layout

\begin_layout Standard
Rispetto all'integrazione in RubyMine manca la possibilità di navigare dal
 passo all'implementazione, inoltre la funzionalità per eseguire i test
 tramite le risorse scritte in Gherkin sembra non funzionare, obbligando
 ad eseguire direttamente il runner di JUnit.
\end_layout

\begin_layout Subsection
Selenium 2.0
\end_layout

\begin_layout Standard
Selenium 2.0 è una libreria per l'automazione la navigazione internet.
 Rispetto alle versioni precedenti della libreria, gli sviluppatori affermano
 di aver definito un'interfaccia più intuitiva e compatta.
\end_layout

\begin_layout Standard
Selenium WebDriver, la libreria che implementa le operazioni per l'accesso
 alle pagine web, utilizza il supporto nativo di ogni browser per l'automazione.
 La prima differenza rispetto a Capybara è data dalla possibilità di utilizzare
 tutte le funzionalità di browser web, come la navigazione grazie alla cronologi
a e l'uso dei preferiti, piuttosto che limitarsi alla sola navigazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>org.seleniumhq.selenium</groupId> 	<artifactId>selenium-java</artifactId
>
\end_layout

\begin_layout Plain Layout

	<version>2.43.1</version>
\end_layout

\begin_layout Plain Layout

</dependency>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Aggiunta della dipendenza di Selenium a SBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per poter definire i test utilizzando le funzionalità di Selenium è sufficiente
 aggiungere la dipendenza del porting in Java al POM del progetto.
\end_layout

\begin_layout Subsubsection*
PhantomJS
\end_layout

\begin_layout Standard
Data la forte integrazione di Selenium con i browser web è stato scelto
 di adottare anche per i test su SBlog PhantomJS.
 Scegliendo di implementare i test di accettazione automatici con Cucumber,
 nelle varie versioni, ed utilizzando lo stesso software per la navigazione
 dei blog è più facile associare ad ogni problema o difficoltà un responsabile
 ed effettuare un'analisi più accurata e metodica.
\end_layout

\begin_layout Subsubsection*
Ghost Driver
\end_layout

\begin_layout Standard
Ghost Driver è un'implementazione JavaScript del protocollo WebDriver Web
 di PhantomJS che permette di eseguire i comandi contattando tramite richieste
 HTTP un servizio REST, che restituisce i risultati delle interazioni serializza
ti con JSon.
\end_layout

\begin_layout Standard
Per configurare Ghost Driver è sufficiente aggiungere la dipendenza al POM.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>com.github.detro.ghostdriver</groupId>
\end_layout

\begin_layout Plain Layout

	<artifactId>phantomjsdriver</artifactId>
\end_layout

\begin_layout Plain Layout

	<version>1.1.0</version>
\end_layout

\begin_layout Plain Layout

</dependency>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
L'implementazione di un passo in Cucumber-JVM è eseguita annotando un metodo
 pubblico con una delle annotazioni corrispondenti al tipo di passo e specifican
do il valore dell'espressione regolare.
 Inoltre è possibile specificare un parametro 
\begin_inset Quotes eld
\end_inset

timeout
\begin_inset Quotes erd
\end_inset

 per specificare il tempo massimo di esecuzione del passo.
\end_layout

\begin_layout Standard
Come per la versione in Ruby, non c'è corrispondenza fra il tipo dell'implementa
zione, in Java è rappresentato dall'annotazione, ed i tipi di passi applicabili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Dato("^apro SBlog$")
\end_layout

\begin_layout Plain Layout

public void apro_SBlog() {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro SBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro SBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per implementare passi parametrici è sufficiente aggiungere dei parametri
 al metodo; come in Ruby i valori estratti dall'espressione del passo hanno
 tipo stringa, ma è possibile annotare i parametri con 
\begin_inset Quotes eld
\end_inset

@Format
\begin_inset Quotes erd
\end_inset

 per effettuare eventuali conversioni.
\end_layout

\begin_layout Standard
Eventuali inconsistenze fra il numero di parametri del passo e del metodo
 sono segnalate tramite eccezione.
\end_layout

\begin_layout Paragraph
La struttura di Selenium
\end_layout

\begin_layout Standard
Rispetto alla struttura di Capybara, Selenium organizza le funzionalità
 in maniera articolata
\begin_inset CommandInset citation
LatexCommand cite
key "Selenium Hierarchy"

\end_inset

.
 La libreria è rappresentata attraverso più gerarchie di classi, interfacce
 ed enumerazioni.
 Di seguito sono introdotti gli elementi più importanti e maggiormente utilizzat
i per il testing su SBlog:
\end_layout

\begin_layout Itemize
l'interfaccia 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 rappresenta gli elementi HTML e include le principali operazioni eseguibili
 tramite Selenium.
 Le linee guida della libreria prevedono che ogni metodo effettui un controllo
 sulla validità del chiamante, verificando che sia presente nel DOM al momento
 dell'esecuzione dell'operazione;
\end_layout

\begin_layout Itemize
l'interfaccia 
\begin_inset Quotes eld
\end_inset

WebDriver
\begin_inset Quotes erd
\end_inset

 è la radice della gerarchia delle operazioni che descrivono le operazioni
 eseguibili durante i test.
 Le funzionalità dichiarate nell'interfaccia riguardano il controllo del
 browser stesso, la selezione degli elementi presenti nel DOM e il supporto
 al debug durante i test;
\end_layout

\begin_layout Itemize
la classe astratta 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

 implementa diversi factory metodi per individuare elementi all'interno
 del DOM.
 Il metodo 
\begin_inset Quotes eld
\end_inset

findElement
\begin_inset Quotes erd
\end_inset

 dell'interfaccia 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 richiede un'istanza della classe 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

 per compiere la ricerca nel documento.
 Rispetto a Capybara le possibilità per implementare un selettore sono indicativ
amente equivalenti, ma Selenium offre metodi come 
\begin_inset Quotes eld
\end_inset

ByTagName
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

ByPartialLinkText
\begin_inset Quotes erd
\end_inset

, derivati rispettivamente da 
\begin_inset Quotes eld
\end_inset

ByCssSelector
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

ByLinkText
\begin_inset Quotes erd
\end_inset

, che semplificano lo sviluppo dei test;
\end_layout

\begin_layout Itemize
l'interfaccia 
\begin_inset Quotes eld
\end_inset

WebDriverException
\begin_inset Quotes erd
\end_inset

 rappresenta la gerarchia degli errori presenti nella libreria.
\end_layout

\begin_layout Paragraph
Navigare all'interno del sito
\end_layout

\begin_layout Standard
La navigazione in Selenium è effettuabile utilizzando tre tipologie di metodi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

driver.navigate().to(getSblogURL());
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Navigazione esplicita.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

navigate
\begin_inset Quotes erd
\end_inset

 restituisce un'istanza di tipo 
\begin_inset Quotes eld
\end_inset

Navigation
\begin_inset Quotes erd
\end_inset

 che permette al driver di accedere alle funzionalità del browser e di navigare,
 sia utilizzando la cronologia, sia indicando esplicitamente un URL da raggiunge
re.
 Il metodo 
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

 effettua richiesta in GET per l'URL specificato e blocca l'esecuzione fino
 al caricamento della nuova pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WebElement link = driver.findElement(By.linkText(linkText));
\end_layout

\begin_layout Plain Layout

link.click();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:evento naviga verso selenium"

\end_inset

Navigazione nel sito, sfruttando il testo visualizzato di un link.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre alla navigazione esplicita, è possibile compiere effettuare un azione,
 come la selezione di un collegamento, su un oggetto 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 individuato tramite un selettore.
 Nell'esempio è effettuata la navigazione ad una delle pagine statiche del
 blog presenti per la prima funzionalità, individuando il link attraverso
 il testo degli elementi 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

findElement
\begin_inset Quotes erd
\end_inset

 restituisce il primo elemento che soddisfa il selettore di tipo 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

.
 Per ogni ricerca all'interno del DOM è previsto un tempo massimo di attesa
 entro il quale l'elemento deve apparire ed una frequenza di polling.
 L'eccezione 
\begin_inset Quotes eld
\end_inset

NoSuchElementException
\begin_inset Quotes erd
\end_inset

 è sollevata nel caso l'elemento non fosse presente.
\end_layout

\begin_layout Paragraph
Integrazione con JUnit
\end_layout

\begin_layout Standard
Per l'esecuzione degli scenari e la definizione delle asserzioni è stato
 utilizzato JUnit, una libreria Java per la definizione di test.
\end_layout

\begin_layout Standard
A differenza di RSpec, la cui struttura prevede 4 moduli organizzati per
 funzionalità, non è possibile utilizzare un sottoinsieme di JUnit.
 Per definire un test con JUnit è sufficiente annotare con 
\begin_inset Quotes eld
\end_inset

@Test
\begin_inset Quotes erd
\end_inset

 un metodo pubblico, utilizzando però Cucumber non è possibile far corrispondere
 a ciascun scenario un singolo test.
 I test infatti sono definiti dinamicamente tramite il runner di Cucumber
 che seleziona i metodi corrispondenti a ciascun passo e non rispetta quindi
 la struttura classica prevista da JUnit.
\end_layout

\begin_layout Standard
In assenza della corrispondenza 
\begin_inset Quotes eld
\end_inset

@Test
\begin_inset Quotes erd
\end_inset

 - scenario, non è possibile utilizzare le funzionalità di JUnit implementate
 tramite annotazione, come la verifica delle eccezioni o la definizione
 di 
\begin_inset Quotes eld
\end_inset

@Rule
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "JUnit Rule"

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le asserzioni in JUnit sono metodi statici della classe 
\begin_inset Quotes eld
\end_inset

Assert
\begin_inset Quotes erd
\end_inset

 ed offrono le funzionalità per la verifica dello stato di uno o più oggetti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WebElement logo = driver.findElement(By.id("logo"));
\end_layout

\begin_layout Plain Layout

assertEquals(logo.getAttribute("href"), getSblogURL());
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica del attributo 
\begin_inset Quotes eld
\end_inset

href
\begin_inset Quotes erd
\end_inset

 del collegamento presente nell'intestazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

assertEquals(driver.getTitle(), pageTitle);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica del titolo della pagina.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Feature: Introducendo il (S)CSS
\end_layout

\begin_layout Plain Layout

Per rendere l'esperienza di navigazione gradevole
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che il sito esponesse una grafica omogenea
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:02x00 Introducendo il CSS"

\end_inset

Seconda funzionalità per RBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Testare il css
\end_layout

\begin_layout Standard
https://github.com/Huddle/PhantomCSS
\end_layout

\begin_layout Standard
http://huddle.github.io/Resemble.js/
\end_layout

\begin_layout Standard
Per verificare le potenzialità di Capybara relativamente all'analisi 
\begin_inset Quotes eld
\end_inset

stilistica
\begin_inset Quotes erd
\end_inset

 delle pagine è stato scelto di analizzare il colore di sfondo di alcuni
 elementi.
 All'interno dell'intestazione delle pagine sono presenti i collegamenti
 introdotti dalla precedente funzionalità; nell'iterazione corrente sono
 stati definiti diversi fogli di stile che creano un semplice effetto cromatico:
 il colore dello sfondo dei collegamenti nell'intestazione cambia al passaggio
 del cursore.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.banner_link:hover {
\end_layout

\begin_layout Plain Layout

	background-color: #8c2828;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del foglio di stile relativo ai collegamenti nell'intestazione
 di RBlog.
\end_layout

\end_inset


\end_layout

\end_inset

Lo scenario relativo a questa funzionalità descrive il comportamento atteso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: l'intestazione espone dei semplici effetti cromatici
\end_layout

\begin_layout Plain Layout

	Dato che è presente l'intestazione
\end_layout

\begin_layout Plain Layout

	E l'intestazione permette la navigazione
\end_layout

\begin_layout Plain Layout

	E i collegamenti non hanno sfondo
\end_layout

\begin_layout Plain Layout

	Quando il cursore si sposta sui collegamenti
\end_layout

\begin_layout Plain Layout

	Allora lo sfondo del collegamento cambia
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario relativo alla funzionalità.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Analisi delle proprietà dei nodi
\end_layout

\begin_layout Paragraph
Analisi dei fogli di stile e corrispondenza all'interno del DOM
\end_layout

\begin_layout Subsection
Il contesto degli scenari
\end_layout

\begin_layout Subsection
Debug con Capybara
\end_layout

\begin_layout Subsection
XPath
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Gestione dei post
\end_layout

\begin_layout Plain Layout

	Come Autore
\end_layout

\begin_layout Plain Layout

	Vorrei poter inserire, leggere, modificare e rimuovere dei post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter documentare la tesi
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:03x00 Modello"

\end_inset

Funzionalità dell'iterazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'obbiettivo dell'iterazione corrente è aggiungere delle pagine dinamiche
 per la gestione dei post su RBlog.
 Le funzionalità supportate sono le CRUD, Create, Read, Update, Delete.
 La generazione dei controller e del modello è stata fatta sfruttando le
 funzionalità a riga di comando del comando 
\begin_inset Quotes eld
\end_inset

rails generate
\begin_inset Quotes erd
\end_inset

 che permette la definizione di tutte le componenti presenti nel framework
 attraverso una sintassi intuitiva.
\end_layout

\begin_layout Standard
Le componenti generate richiedono ovviamente di essere personalizzate ma
 espongono una struttura completa che minimizza la configurazione.
\end_layout

\begin_layout Subsection
Dipendenze
\end_layout

\begin_layout Standard
Nella definizione degli scenari è conveniente utilizzare uno stile che favorisca
 sia lo sviluppatore, che ha il compito di scrivere e mantenere i test di
 accettazione, sia gli stakes holder, che tramite gli scenari possono seguire
 lo sviluppo del prodotto.
\end_layout

\begin_layout Standard
Gli scenari devono essere indipendenti fra loro e l'ordine di esecuzione
 non deve aver conseguenze sul risultato.
 Mantenere delle dipendenze funzionali all'interno nella libreria di testing
 può introdurre diverse problematiche all'aumentare della cardinalità dei
 test e della complessità o alla variazione dello condizioni d'esecuzione,
 introducendo ad esempio l'esecuzione in parallelo di più scenari.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Gli scenari della funzionalità 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:03x00 Modello"

\end_inset

 sfruttando le interfacce di RBlog per creare, modificare e rimuovere post.
 E' quindi necessario introdurre delle procedure per annullare le modifiche
 compiute.
\end_layout

\begin_layout Paragraph
Hooks
\end_layout

\begin_layout Standard
Cucumber definisce degli istanti durante l'esecuzione dei test ai quali
 
\begin_inset Quotes eld
\end_inset

agganciare
\begin_inset Quotes erd
\end_inset

 l'esecuzione di eventi definiti dallo sviluppatore.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Scrittura di un nuovo post
\end_layout

\begin_layout Plain Layout

	Dato il post "Lorem Ipsum" non è leggibile su RBlog
\end_layout

\begin_layout Plain Layout

	E apro la pagina per la creazione di un nuovo post
\end_layout

\begin_layout Plain Layout

	Quando inserisco "Lorem Ipsum" come titolo
\end_layout

\begin_layout Plain Layout

	E inserisco del testo riempitivo come contenuto
\end_layout

\begin_layout Plain Layout

	E salvo il post
\end_layout

\begin_layout Plain Layout

	Allora il post "Lorem Ipsum" è stato creato con successo
\end_layout

\begin_layout Plain Layout

	E il post "Lorem Ipsum" è leggibile su RBlog
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Creazione di un nuovo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lo scenario si conclude con la creazione di un nuovo post dal titolo 
\begin_inset Quotes eld
\end_inset

Lorem Ipsum
\begin_inset Quotes erd
\end_inset

, eseguendo nuovamente il test la prima pre-condizione non sarebbe verificata.
 Tramite il meccanismo degli hook
\begin_inset CommandInset citation
LatexCommand cite
key "Cucumber Hook"

\end_inset

 in Cucumber sono state definite delle procedure per annullare tutte le
 modifiche effettuate sull'applicazione.
\begin_inset Foot
status open

\begin_layout Plain Layout
La definizione degli hook non richiede alcuna configurazione, è sufficiente
 inserire il nuovo file all'interno della cartella contenente l'implementazione
 dei passi.
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

After('@clear') do
\end_layout

\begin_layout Plain Layout

	clear_all_ipsums(page)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Hook eseguito al termine degli scenari.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel frammento è utilizzato il metodo 
\begin_inset Quotes eld
\end_inset

After
\begin_inset Quotes erd
\end_inset

, a cui è attribuita l'operazione da eseguire al termine dello scenario.
 Il metodo è applicato esclusivamente agli scenari che sono etichettati
 con 
\begin_inset Quotes eld
\end_inset

@clear
\begin_inset Quotes erd
\end_inset

, se fosse utilizzato senza parametri l'esecuzione avverrebbe al termine
 di ogni scenario della libreria.
\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

clear_all_ipsums
\begin_inset Quotes erd
\end_inset

 verifica la presenza di articoli i cui titoli contengano il testo 
\begin_inset Quotes eld
\end_inset

Lorem Ipsum
\begin_inset Quotes erd
\end_inset

 e ne effettuano la cancellazione.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

After
\begin_inset Quotes erd
\end_inset

, ma in generale anche 
\begin_inset Quotes eld
\end_inset

Before
\begin_inset Quotes erd
\end_inset

 e gli hook per i singoli passi 
\begin_inset Quotes eld
\end_inset

AfterStep
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

BeforeStep
\begin_inset Quotes erd
\end_inset

, sono utilizzabili con un numero arbitrario di etichette.
 Inoltre è possibile definire dei blocchi con un singolo parametro rappresentant
e lo scenario che espone delle funzionalità per verificare il risultato
 dello scenario\SpecialChar \@.

\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Around('@fast') do |scenario, block|
\end_layout

\begin_layout Plain Layout

	Timeout.timeout(0.5) do
\end_layout

\begin_layout Plain Layout

		block.call
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

Around
\begin_inset Quotes erd
\end_inset

 invece è utilizzato per essere eseguito 
\begin_inset Quotes eld
\end_inset

intorno
\begin_inset Quotes erd
\end_inset

 allo scenario e poter effetture delle misurazioni sulla velocità degli
 scenario.
 Lo scenario è passato al blocco del metodo attraverso un ulteriore parametro.
\end_layout

\begin_layout Paragraph
Tool disponibili
\end_layout

\begin_layout Standard
Per non introdurre un alto numero di librerie all'interno del progetto,
 gli hook eseguono le azioni di regressione attraverso l'interfaccia grafica
 dell'applicazione utilizzando le stesse funzionalità presenti nei passi.
\end_layout

\begin_layout Standard
Esistono però delle librerie che, attraverso una sintassi semplificata,
 offrono le funzionalità per la creazione e manipolazione di nuovi elementi
 all'interno del modello come FactoryGirl, o strumenti come DatabaseCleaner
 che offrono le funzionalità per l'eliminazione di quanto presente nel sistema
 attraverso diverse strategie.
\end_layout

\begin_layout Standard
Nel caso di librerie di test complesse potrebbe essere conveniente utilizzare
 uno di questi strumenti per semplificare lo sviluppo e concentrarsi esclusivame
nte sullo verifica degli scenari.
\end_layout

\begin_layout Subsection
Gestione dei form
\end_layout

\begin_layout Standard
Per le operazioni di inserimento e modifica dei post in RBlog sono state
 definite due viste e un semplice form, contenuto all'interno di una vista
 parziale.
 La gestione degli eventi da parte di Capybara e Poltergeist è uno degli
 aspetti in cui la coppia framework - driver eccelle.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^inserisco "([^"]*)" come titolo$/) do |title_value|
\end_layout

\begin_layout Plain Layout

	page.fill_in 'post_title', :with => title_value
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I campi dei form sono compilati attraverso il metodo 
\begin_inset Quotes eld
\end_inset

fill_in
\begin_inset Quotes erd
\end_inset

 che individua i nodi HTML 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

text_area
\begin_inset Quotes erd
\end_inset

 in funzione del nome del campo e inserisce il testo specificato dal parametro
 
\begin_inset Quotes eld
\end_inset

:with
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^salvo il post$/) do
\end_layout

\begin_layout Plain Layout

	click_button 'submit'
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le funzionalità del modulo Actions sono estremamente semplici ed intuitive:
 sono supportati diversi tipologie di campi, dalle aree testuali ai check
 box, è possibile selezionare un file da allegare tramite il metodo 
\begin_inset Quotes eld
\end_inset

attach_file
\begin_inset Quotes erd
\end_inset

.
 Tutti i metodi presenti offrono allo sviluppatore del driver di estendere
 le funzionalità attraverso un parametro 
\begin_inset Quotes eld
\end_inset

options
\begin_inset Quotes erd
\end_inset

 di tipo Hash, l'implementazione della struttura dato dizionario in Ruby.
\end_layout

\begin_layout Paragraph
Il metodo within
\end_layout

\begin_layout Standard
Per semplificare l'esecuzione di più operazioni che condividono lo stesso
 nodo è disponbile il metodo 
\begin_inset Quotes eld
\end_inset

within
\begin_inset Quotes erd
\end_inset

, che esegue il blocco associato nel contesto del nodo passato come parametro.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^cancello il post "([^"]*)"$/) do |post_title|
\end_layout

\begin_layout Plain Layout

	expect(page.has_content?(post_title)).to be_truthy
\end_layout

\begin_layout Plain Layout

	post_div = steps_helper.post_div_by_title(page, post_title)
\end_layout

\begin_layout Plain Layout

	within(post_div) do
\end_layout

\begin_layout Plain Layout

		#...
\end_layout

\begin_layout Plain Layout

		find('.remove_post_button').click
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Login & Autorizzazione
\end_layout

\begin_layout Standard
L'obbiettivo della funzionalità è l'introduzione di un meccanismo di autenticazi
one e gestione delle autorizzazioni in RBlog.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Autenticazione su RBlog
\end_layout

\begin_layout Plain Layout

	Come Autore di RBlog
\end_layout

\begin_layout Plain Layout

	Vorrei che alcune operazioni sensibili siano permesse previa autenticazione
\end_layout

\begin_layout Plain Layout

	Per poter garantire l'autenticità dei contenuti
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Descrizione della funzionalità di autenticazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per supportare le operazioni di login e logout all'interno del blog è stata
 modificata l'applicazione in tutte le sue componenti.
 All'interno del modello è stato introdotta l'entità autore, definita da
 un indirizzo email, unico all'interno del dominio, una password ed una
 relazione uno a molti con i post.
\end_layout

\begin_layout Standard
Per rendere più realistico il meccanismo di autenticazione, non è mantenuta
 la password in chiaro ma la coppia impronta hash e salt, riducendo la sensibili
tà ad attacchi di tipo dizionario sull'impronta hash della password.
 Il salt è una stringa casuale da concatenare alla password in chiaro per
 generare impronte hash più sicure.
 La generazione del sale e il calcolo delle impronte è effettuato tramite
 la gemma BCrypt
\begin_inset CommandInset citation
LatexCommand cite
key "BCrypt"

\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class SessionsController < ApplicationController
\end_layout

\begin_layout Plain Layout

	def create
\end_layout

\begin_layout Plain Layout

		author = Author.authenticate(params[:email], params[:hpassword])
\end_layout

\begin_layout Plain Layout

		if author
\end_layout

\begin_layout Plain Layout

			session[:author_id] = author.id
\end_layout

\begin_layout Plain Layout

			redirect_to
\end_layout

\begin_layout Plain Layout

				:root, :notice => 'Login effettuato, benvenuto!'
\end_layout

\begin_layout Plain Layout

		else
\end_layout

\begin_layout Plain Layout

			redirect_to :log_in, :notice => 'Credenziali invalide.'
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento del controllo per l'autenticazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il controllo 
\begin_inset Quotes eld
\end_inset

SessionController
\begin_inset Quotes erd
\end_inset

 è stato aggiunto all'applicazione, dichiarando l'instradamento per le richieste
 alla pagina di login, la creazione della sessione ed il logout.
 Il login su RBlog coincide con la creazione di una sessione con attributo
 l'identificatore univoco dell'autore.
 Rails fornisce le interfacce per la gestione di sessioni, che vengono criptate
 di default.
\end_layout

\begin_layout Subsection
Black-box Testing
\end_layout

\begin_layout Standard
Lo sviluppo di test di accettazione automatici prevede di considerare il
 sistema da una prospettiva esterna, senza alcuna conoscenza dell'implementazion
e sottostante.
 I test sono definiti e verificati osservando il comportamento di una scatola
 nera e non dovrebbero fare assunzioni sul comportamento del software.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nonostante questo requisito, i test sull'autenticazione rilassano il principio
 del black-box testing per verificare le potenzialità di Capybara nella
 gestione di sessioni e cookie.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def encrypted_session(page)
\end_layout

\begin_layout Plain Layout

	cookies = page.driver.cookies
\end_layout

\begin_layout Plain Layout

	cookies.values[0].value
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Accesso alla sessione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
E' importante ricordare che l'architettura di Capybara prevede l'utilizzo
 di driver e funzionalità a basso livello, come la gestione delle sessioni,
 potrebbero variare in funzione delle componenti scelte.
\end_layout

\begin_layout Standard
Poltergeist implementa le funzionalità per la lettura dei cookie, come mostrato
 nel metodo 
\begin_inset Quotes eld
\end_inset

encrypted_session
\begin_inset Quotes erd
\end_inset

, definendo diversi metodi per accedere alle proprietà.
\begin_inset Foot
status open

\begin_layout Plain Layout
Sono presenti i metodi: 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

domain
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

path
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

secure?
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

httponly?
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

expires
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre è possibile creare e rimuovere i cookie, funzionalità utili nella
 definizione degli hook di Cucumber.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^mi autentico come "([^"]*)"$/) do |email|
\end_layout

\begin_layout Plain Layout

	pre_login_encrypted_session = steps_helper.encrypted_session(page)
\end_layout

\begin_layout Plain Layout

	visit steps_helper.login_page_url
\end_layout

\begin_layout Plain Layout

	/*.....*/
\end_layout

\begin_layout Plain Layout

	/*Login*/
\end_layout

\begin_layout Plain Layout

	/*.....*/
\end_layout

\begin_layout Plain Layout

	post_login_encrypted_session = steps_helper.encrypted_session(page)
\end_layout

\begin_layout Plain Layout

	expect(pre_login_encrypted_session).not_to
\end_layout

\begin_layout Plain Layout

	eq(post_login_encrypted_session)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Login su RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'implementazione del passo di login comprende la compilazione dei campi
 relativi all'email e alla password ed una semplice asserzione sul valore
 criptato della sessione: dopo la verifica delle credenziali viene aggiunto
 un attributo facendo variare la codifica.
\end_layout

\begin_layout Subsection
Manutenibilità
\end_layout

\begin_layout Standard
L'introduzione dell'autenticazione è l'unica funzionalità che abbia inciso
 su tutte le componenti dell'applicazione ed anche sui test di accettazione
 già presenti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap3
\end_layout

\begin_layout Plain Layout

@clear_and_logout
\end_layout

\begin_layout Plain Layout

Funzionalità: Gestione dei post
\end_layout

\begin_layout Plain Layout

	Come Autore   
\end_layout

\begin_layout Plain Layout

	Vorrei poter inserire, modificare e rimuovere dei post su RBlog   
\end_layout

\begin_layout Plain Layout

	Per poter documentare la mia tesi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Contesto:     
\end_layout

\begin_layout Plain Layout

	Dato che apro RBlog
\end_layout

\begin_layout Plain Layout

	E mi autentico come "mattia@rblog.io"
\begin_inset Caption Standard

\begin_layout Plain Layout
Variazioni nella funzionalità di creazione dei post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Introducendo la verifica delle autorizzazioni, l'accesso alle funzionalità
 di creazione, modifica e cancellazione di un post non sono più eseguibile
 senza aver compiuto l'autenticazione.
\begin_inset Foot
status open

\begin_layout Plain Layout
Dalle pagine sono rimossi i collegamenti alle azioni riservate e l'accesso
 diretto alle pagine senza aver effettuato l'autenticazione causa la ridirezione
 verso la pagina di login.
\end_layout

\end_inset

 E' stato quindi necessario modificare il contesto di alcune funzionalità
 specificando l'azione di login ed estendere le operazioni di regressione
 dopo ogni scenario per includere il logout.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

After('@clear_and_logout') do
\end_layout

\begin_layout Plain Layout

	clear_all_ipsums(page)
\end_layout

\begin_layout Plain Layout

	logout(page)
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Il nuovo hook combina regressione del modello e logout.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La precedente etichetta 
\begin_inset Quotes eld
\end_inset

@clear
\begin_inset Quotes erd
\end_inset

 è stata sostituita da 
\begin_inset Quotes eld
\end_inset

@clear_and_logout
\begin_inset Quotes erd
\end_inset

, non è stata trovato alcun riferimento sull'ordine di esecuzione degli
 hook che avrebbe permesso l'introduzione di una nuova etichetta piuttosto
 che la modifica di quella esistente.
\end_layout

\begin_layout Standard
Le variazioni riguardanti le operazioni di regressione hanno ulteriormente
 complicato la funzionalità: ritengo che l'uso di etichette, sintatticamente
 più vicine a Java che al linguaggio naturale, stoni all'interno di un documento
 scritto attraverso un linguaggio Business Readable come Gherkin.
\end_layout

\begin_layout Standard
L'uso di etichette su scenari e funzionalità dovrebbe essere utile solo
 per organizzare i test in maniera non funzionale, come categorizzare in
 base al tempo di esecuzione richiesto -ad esempio @rapido, @standard e
 @lento- o stabilendo i giusti intervalli di l'esecuzione su un server per
 la CI -ad esempio @sempre, @ogni_ora, @ogni_notte-.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Asincronia
\end_layout

\begin_layout Standard
L'obbiettivo delle prossime funzionalità è verificare le potenzialità di
 Capybara con Javascript, JQuery, JQuery UI e Ajax, strumenti che permettono
 la definizione di comportamenti asincroni.
\end_layout

\begin_layout Subsection
JavaScript
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Easter Egging
\end_layout

\begin_layout Plain Layout

	Come Sviluppatore
\end_layout

\begin_layout Plain Layout

	Vorrei che nel blog fosse presente un mio logo
\end_layout

\begin_layout Plain Layout

	Per firmare il mio lavoro
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:05bx00 EasterEgg"

\end_inset

Introduzione di un breve script Javascript.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tramite questa funzionalità è introdotto un piccolo script Javascript, associato
 all'evento 
\begin_inset Quotes eld
\end_inset

onclick
\begin_inset Quotes erd
\end_inset

 del 
\begin_inset Quotes eld
\end_inset

div
\begin_inset Quotes erd
\end_inset

 piè di pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div id="footer" onclick="switch_easter_egg()">
\end_layout

\begin_layout Plain Layout

	<p>© 2014 - Mattia</p>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Footer di RBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function switch_easter_egg() {
\end_layout

\begin_layout Plain Layout

	var woodstock = $('#woodstock');
\end_layout

\begin_layout Plain Layout

	if (!woodstock.length) {
\end_layout

\begin_layout Plain Layout

		var img = document.createElement("img");
\end_layout

\begin_layout Plain Layout

		img.src = "/assets/woodstock.png";
\end_layout

\begin_layout Plain Layout

		img.id = "woodstock";
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

		document.getElementById("footer").appendChild(img);
\end_layout

\begin_layout Plain Layout

	}else{
\end_layout

\begin_layout Plain Layout

		woodstock.remove();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento della funzione per aggiunta e rimozione del logo.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzione, tramite un selettore JQuery, aggiunge o rimuove un piccolo
 logo in fondo alla pagina.
 Il click sull'elemento 
\begin_inset Quotes eld
\end_inset

#footer
\begin_inset Quotes erd
\end_inset

 esegue la funzione e modifica di conseguenza il DOM.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Capybara è stato sviluppato sotto l'assunzione che nello sviluppo di applicazion
i web moderne potenzialmente ogni elemento potrebbe essere il risultato
 di un comportamento asincrono; per ogni operazione sul DOM è concesso che
 l'elemento debba ancora apparire.
 Capybara permette la configurazione di un parametro di attesa che specifica
 il tempo massimo, dopo il quale verrà sollevata un'eccezione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Given(/^non è presente il logo nell'intestazione$/) do
\end_layout

\begin_layout Plain Layout

	step 'è presente il pié di pagina'
\end_layout

\begin_layout Plain Layout

	expect(@footer.has_css?('img')).to be_falsy
\end_layout

\begin_layout Plain Layout

	expect(@footer.has_css?('#woodstock')).to be_falsy
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'implementazione dei passi non subisce alcuna modifica in funzione del
 tipo di comportamento dell'elemento sotto test.
 Non è quindi necessario specificare manualmente dei timeout o delle pause
 arbitrarie nei test, ma è Capybara stesso a gestire quest'aspetto.
\end_layout

\begin_layout Subsection
JQueryUI
\end_layout

\begin_layout Standard
JQuery UI
\begin_inset CommandInset citation
LatexCommand cite
key "JQueryUI"

\end_inset

 è una libreria grafica per l'introduzione di plugin grafici all'interno
 di applicazioni web.
 Attualmente alla versione 1.11, è sviluppata sfruttando JQuery e permette
 una rapida integrazione di widget, come menu con auto-completamento o selettori
 di date, ed effetti grafici.
 Le uniche dipendenze richieste sono JQuery e Javascript.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
All'interno di RBlog, ed in particolare nell'intestazione del sito, è stato
 introdotto un semplice form HTML per ricercare i post in funzione del titolo.
 La ricerca definisce un parametro HTTP che è analizzato dallo stesso controllo
 che popola la home page.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il comportamento tipico dei widget definiti in JQuery UI è intuitivo: le
 azioni eseguite in maniera asincrona modificano il DOM della pagina corrente,
 aggiungendo o modificando un insieme di nodi.
 Per ogni plugin è presente un foglio di stile che descrive l'aspetto grafico
 dell'elemento introdotto.
 Ad esempio il menu con auto-completamento aggiunge una lista in HTML, attravers
o i nodi 
\begin_inset Quotes eld
\end_inset

ul
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

il
\begin_inset Quotes erd
\end_inset

, come ultimi elementi del 
\begin_inset Quotes eld
\end_inset

body
\begin_inset Quotes erd
\end_inset

.
 La lista numerata e gli elementi sono però visualizzati immediatamente
 al di sotto del campo 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset

 a cui si riferiscono grazie ai fogli di stile.
\begin_inset Foot
status open

\begin_layout Plain Layout
JQuery UI definisce anche diversi temi per i plugin, garantendo una migliore
 integrazione estetica.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Ajax
\end_layout

\begin_layout Standard
I parametri che definiscono il widget del menu permettono di indicare quale
 sia la sorgente per auto-completare il testo immesso nel campo di 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset

.
 E' possibile dichiarare staticamente i dati oppure fornirli in maniera
 dinamica in funzione del testo inserito.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function autocomplete() {     
\end_layout

\begin_layout Plain Layout

	if ($("#search_input_text").length) {
\end_layout

\begin_layout Plain Layout

		$("#search_input_text").autocomplete({
\end_layout

\begin_layout Plain Layout

			source: function (request, response){
\end_layout

\begin_layout Plain Layout

				$.ajax({
\end_layout

\begin_layout Plain Layout

					url: "/posts/autocomplete_title",
\end_layout

\begin_layout Plain Layout

					data: {title: $("#search_input_text").val()}, 
\end_layout

\begin_layout Plain Layout

					success: function (data) {
\end_layout

\begin_layout Plain Layout

				         response(data);
\end_layout

\begin_layout Plain Layout

					},
\end_layout

\begin_layout Plain Layout

					failure: function () {
\end_layout

\begin_layout Plain Layout

				         console.log("Failure");
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				})
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			minLength: 2,
\end_layout

\begin_layout Plain Layout

			focus: function (event, ui) {
\end_layout

\begin_layout Plain Layout

				$("#search_input_text").val(ui.item.value);
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			select: function (event, ui) {
\end_layout

\begin_layout Plain Layout

				$("#search_input_text").val(ui.item.value);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		});
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Funzione di autocompletamento in JavaScript.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
AJAX, acronimo di Asynchronous JavaScript and XML, è una libreria in JavaScript
 per lo scambio di dati fra il web-browser ed il server che ospita l'applicazion
e web.
 Il comportamento è definito asincrono in quanto le informazioni che sono
 ottenute tramite la libreria, sono caricati in background senza interferire
 con il comportamento della pagina.
\end_layout

\begin_layout Standard
In RBlog la compilazione del campo per la ricerca di post effettua una chiamata
 AJAX ad un controllo che, ricevuto un parametro GET, restituisce un array
 di stringhe serializzate tramite Json contenente i titoli dei post per
 completare la ricerca.
\begin_inset Newline newline
\end_inset

La funzione 
\begin_inset Quotes eld
\end_inset

autocomplete
\begin_inset Quotes erd
\end_inset

 è associata alla pagina di RBlog tramite gli eventi di JQuery.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$(window).bind('page:change', autocomplete);
\end_layout

\begin_layout Plain Layout

$(document).ready(autocomplete);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Callback per la funzione 
\begin_inset Quotes eld
\end_inset

autocomplete
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scenari sull'auto-completamento
\end_layout

\begin_layout Standard
Rispetto alla funzionalità 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:05bx00 EasterEgg"

\end_inset

, dove il DOM è modificato tramite una chiamata Javascript in maniera praticamen
te istantanea, introdurre l'auto-completamento della ricerca introduce l'utilizz
o di AJAX ed un maggior ritardo nell'aggiornamento della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Ricerca fra i post
\end_layout

\begin_layout Plain Layout

	Come Lettore
\end_layout

\begin_layout Plain Layout

	Vorrei poter ricercare i post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter navigare fra i contenuti più velocemente
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Introduzione della ricerca.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'obbiettivo della funzionalità è verificare le potenzialità di Capybara
 nella gestione di chiamate AJAX e nell'utilizzo di widget di JQuery UI.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Fino alla versione 2.0 Capybara includeva il metodo 
\begin_inset Quotes eld
\end_inset

wait_until
\begin_inset Quotes erd
\end_inset

 per la verifica di elementi potenzialmenti asincroni.
 Il metodo nell'ultimo rilascio della libreria è stato integrato in tutte
 le funzionalità e rimosso, permettendo di definire test senza la necessità
 di definire timeout e attese.
\end_layout

\begin_layout Standard
E' ora presente una nuova funzionalità per verificare pagine web che espongono
 comportamenti asincroni.
 Il metodo 
\begin_inset Quotes eld
\end_inset

synchronize
\begin_inset Quotes erd
\end_inset

 esegue il blocco associato fino a che non ha successo, permettendo il corretto
 completamento delle funzioni AJAX.
 L'esecuzione del blocco dipende dal tempo di attesa definito in Capybara,
 configurabile in funzione delle necessità.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def finished_all_ajax_requests?(page)
\end_layout

\begin_layout Plain Layout

	page.document.synchronize do
\end_layout

\begin_layout Plain Layout

		page.find('#ui-id-1')
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def wait_for_ajax(page)
\end_layout

\begin_layout Plain Layout

	begin
\end_layout

\begin_layout Plain Layout

		Timeout.timeout(Capybara.default_wait_time)
\end_layout

\begin_layout Plain Layout

		do
\end_layout

\begin_layout Plain Layout

			loop until finished_all_ajax_requests?(page)
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

	rescue Timeout::Error
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

	yield if block_given?
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
Utilizzo del metodo 
\begin_inset Quotes eld
\end_inset

syncronize
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il vantaggio di utilizzare il metodo 
\begin_inset Quotes eld
\end_inset

synchronize
\begin_inset Quotes erd
\end_inset

 rispetto all'utilizzo classico della libreria, che non prevede l'introduzione
 di attese o polling, consiste nella verifica delle situazioni dove un elemento
 è presente sulla pagina, come la lista numerata del plugin di JQuery UI,
 ma è necessario dare il tempo al browser di completarne il rendering, in
 quanto le funzionalità di Capybara sono più veloci.
\begin_inset Newline newline
\end_inset

Lo svantaggio dell'utilizzo del metodo 
\begin_inset Quotes eld
\end_inset

synchronize
\begin_inset Quotes erd
\end_inset

 consiste nell'introduzione di stalli per l'esecuzione di test in cui gli
 elementi asincroni non debbano apparire, come una ricerca senza suggerimenti.
 Inoltre, l'attesa per un elemento potrebbe mascherare componenti lente
 all'interno del sito e un cattivo Look and Feel, richiedendo comunque una
 verifica manuale dell'applicazione web.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le difficoltà nella verifica di widget asincroni sono causate sia dalla
 necessità di prevedere ritardi nella visualizzazione sia nella simulazione
 dell'interazione con le componenti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Autocompletamento della ricerca
\end_layout

\begin_layout Plain Layout

	Dato nell'intestazione è presente la barra di ricerca
\end_layout

\begin_layout Plain Layout

	Dato il post "Lorem Ipsum" esiste
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "lor" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora viene proposto il post "Lorem Ipsum"
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "xyz" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora non è proposto alcun post
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'auto-completamento in RBlog prevede che la compilazione del campo di ricerca
 fornisca alcuni suggerimenti all'utente.
 Inoltre al passaggio del cursore su una delle voci suggerite o utilizzando
 la tastiera per selezionare un'opzione, il testo digitato dall'utente è
 sostituito dalla voce corrente.
\end_layout

\begin_layout Standard
Queste interazioni con il widget prevedono la definizione di passi che esplicita
no una successione di eventi sugli elementi del DOM.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^inserisco il testo "([^"]*)" da ricercare$/) do |searched_text|
\end_layout

\begin_layout Plain Layout

	page.fill_in 'search', :with => searched_text
\end_layout

\begin_layout Plain Layout

	search_input = page.find('#search_input_text')
\end_layout

\begin_layout Plain Layout

	search_input.trigger(:focus)
\end_layout

\begin_layout Plain Layout

	#search_input.trigger(:keydown)
\end_layout

\begin_layout Plain Layout

	page.execute_script %Q{ $('#search_input_text').trigger('keydown') }
\end_layout

\begin_layout Plain Layout

	steps_helper.wait_for_ajax page
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
Compilazione del menù con autocompletamento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel passo è inserito il valore del parametro 
\begin_inset Quotes eld
\end_inset

searched_text
\begin_inset Quotes erd
\end_inset

, eseguito il focus dell'elemento 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset

 tramite il quale effettuare la ricerca ed è invocata la pressione del tasto
 
\begin_inset Quotes eld
\end_inset

freccia giù
\begin_inset Quotes erd
\end_inset

 per selezionare il primo elemento.
 Il passo si conclude con l'attesa che il menù sia completamente renderizzato.
\end_layout

\begin_layout Standard
Poltergeist non implementa tutti i possibili eventi disponibili, è quindi
 necessario sfruttare script JQuery per colmare le mancanze del driver.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

When(/^ricerco "([^"]*)"$/) do |searched_text|
\end_layout

\begin_layout Plain Layout

	step "inserisco il testo 
\backslash
"#{searched_text}
\backslash
" da ricercare"
\end_layout

\begin_layout Plain Layout

	steps_helper.wait_for_ajax page do
\end_layout

\begin_layout Plain Layout

		regexp = Regexp.new(Regexp.escape(searched_text), 'i')
\end_layout

\begin_layout Plain Layout

		if page.has_css?('.ui-menu-item', :text => regexp)
\end_layout

\begin_layout Plain Layout

			post_hint = page.find(:xpath, "//li[@class = 'ui-menu-item']")
\end_layout

\begin_layout Plain Layout

			expect(post_hint.text).to match(%r{#{searched_text}}i)
\end_layout

\begin_layout Plain Layout

			post_hint.trigger(:mouseenter)
\end_layout

\begin_layout Plain Layout

			post_hint.click
\end_layout

\begin_layout Plain Layout

		end
\end_layout

\begin_layout Plain Layout

		find('#search_icon').click
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

end
\begin_inset Caption Standard

\begin_layout Plain Layout
Ricerca di un post tramite click di una delle opzioni proposte.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rispetto al passo precedente, dove il testo da ricercare veniva esclusivamente
 inserito, nell'implementazione del evento corrente viene completata la
 ricerca.
\end_layout

\begin_layout Standard
Invocando il passo precedente il form è compilato, mentre le azioni sono
 eseguite all'interno del blocco fornito al metodo 
\begin_inset Quotes eld
\end_inset

wait_for_ajax
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Con il metodo 
\begin_inset Quotes eld
\end_inset

has_css
\begin_inset Quotes erd
\end_inset

, che individua nel DOM l'elemento che coincide con selettore ed il cui
 testo soddisfa l'espressione regolare, si ottiene un riferimento al nodo
 sul quale spostare il cursore ed effettuare il click.
 Per completare la ricerca è eseguito un ulteriore click sull'immagine che
 effettua l'invio del form.
\begin_inset Newline newline
\end_inset

La difficoltà nell'utilizzo di plugin definiti tramite librerie grafiche
 come JQuery UI o Bootstrap, consiste nella razionalizzazione degli eventi
 che manualmente vengono compiuti per utilizzare le interfacce grafiche.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Then(/^viene proposto il post "([^"]*)"$/) do |hint|
\end_layout

\begin_layout Plain Layout

	ui_menu_items = page.all(:xpath, "//li[@class = 'ui-menu-item'][text() =
 
\backslash
"#{hint}
\backslash
"]")
\end_layout

\begin_layout Plain Layout

	expect(ui_menu_items.length).to be == 1 end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Avendo gestito l'asincronia ed utilizzato i giusti eventi, le asserzioni
 non presentano ulteriori accorgimenti.
\end_layout

\end_body
\end_document
