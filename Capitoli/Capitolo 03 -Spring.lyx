#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\use_default_options true
\master ../Relazione.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Spring 13/11/14
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:spring"

\end_inset


\end_layout

\begin_layout Section
Spring MVC
\end_layout

\begin_layout Standard
In questo capitolo è trattato lo sviluppo di SBlog con Spring, un framework
 per la definizione di applicazioni web scritto in Java, e l'implementazione
 della libreria di test di accettazione automatici utilizzata per RBlog
 con Cucumber JVM e Selenium Web Driver.
\end_layout

\begin_layout Standard
La struttura di questo capitolo su Spring è simile al precedente: le prime
 sezioni descrivono l'architettura del framework, introducendo gli strumenti
 più significati nella definizione di SBlog, dalla sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-SBlog!"

\end_inset

 è descritto il processo d'implementazione delle funzionalità e scenari
 già descritti nel precedente capitolo, documentando tramite esempi e frammenti
 di test lo sviluppo dei test di accettazione.
\end_layout

\begin_layout Subsection
Spring Tool Suite
\end_layout

\begin_layout Standard
Spring Tool Suite, STS, è una versione personalizzata di Eclipse per supportare
 lo sviluppo tramite il framework.
 I plugin presenti nell'ambiente di sviluppo forniscono supporto per i diversi
 linguaggi nello sviluppo web, come HTML, CSS o Javascript, l'integrazione
 con le componenti del framework, come la creazione di progetti guidata
 o la rappresentazione grafica delle componenti dell'applicazione, e le
 funzionalità già presenti nella versione di Eclipse per Java EE, Enterprise
 Edition.
\end_layout

\begin_layout Standard
Per lo sviluppo di SBlog è stata utilizzata la versione 3.6.2 di Spring Tool
 Suite, basata su Eclipse Luna 4.4.
 Oltre ad utilizzare il software disponibile sul sito di Spring, è possibile
 anche installare le funzionalità di STS in una versione già esistente di
 Eclipse tramite l'apposito plugin.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:L'interpretazione di Spring del pattern MVC"

\end_inset

L'interpretazione di Spring del pattern MVC
\end_layout

\begin_layout Standard
Nella sezione saranno descritti le componenti dell'architettura MVC in funzione
 dell'interpretazione data da Spring.
 Rispetto a RoR, come descritto in seguito, il framework Java necessita
 di una maggiore configurazione delle sue componenti, sono quindi inclusi
 numerosi esempi per dare un'indicazione del processo di sviluppo e alcuni
 riferimenti.
\end_layout

\begin_layout Subsection
Il modello
\end_layout

\begin_layout Standard
Per l'implementazione del modello in Spring è stato utilizzato JPA 
\begin_inset Foot
status open

\begin_layout Plain Layout
Rispetto a RoR, in Spring si gode di estrema libertà nella scelta delle
 librerie da utilizzare per la propria applicazione web.
 
\end_layout

\end_inset

, Java Persistence API, una specifica Java per l'accesso, la persistenza
 e la gestione dei dati di DBMS relazionali, nella quale sono descritti
 i criteri per mappare un POJO, Plain Old Java Object, su un database.
\end_layout

\begin_layout Standard
Il vantaggio nell'utilizzo di una libreria che implementi la specifica,
 JPA infatti non fornisce alcuna implementazione, consiste nel poter modellare
 il dominio attraverso classi Java.
 Un POJO, termine introdotto da Martin Fowler
\begin_inset CommandInset citation
LatexCommand cite
key "POJO"

\end_inset

, è un oggetto Java che rappresenta le informazioni di un'entità del dominio
 e le relazioni che intercorrono con altri elementi attraverso l'insieme
 dei suoi attributi.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
EclipseLink è una delle implementazioni esistenti per JPA, fornisce tutte
 le funzionalità previste dallo standard alla versione 2.1, e rispetto ad
 altre librerie come Hibernate, attualmente è leggermente più performante
 ed ha una miglior gestione del caricamento delle entità.
\end_layout

\begin_layout Standard
JPA 2.1, la versione attuale, fornisce agli sviluppatori sia strumenti per
 effettuare la definizione dello schema sia per effettuare interrogazioni
 senza utilizzare SQL puro, mantenendo parte dell'astrazione introdotta
 utilizzando la tecnica ORM.
\end_layout

\begin_layout Subsubsection*
DDL con JPA
\end_layout

\begin_layout Standard
Lo schema del modello di SBlog è stato definito esclusivamente tramite le
 annotazioni previste dalla specifica, JPA fa ampio uso del meccanismo della
 reflection
\begin_inset Foot
status open

\begin_layout Plain Layout
Il meccanismo della reflection in Java permette di ispezionare il codice
 compilato al fine individuare elementi di interesse.
\end_layout

\end_inset

 per analizzare a run-time le entità esistenti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il dominio di SBlog è composto da due entità 
\begin_inset Quotes eld
\end_inset

Author
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 che rispettivamente descrivono gli autori del blog e gli articoli presenti,
 tramite i propri attributi d'istanza.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Entity
\end_layout

\begin_layout Plain Layout

public class Post {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione dell'entità Post.
\end_layout

\end_inset


\end_layout

\end_inset

Per dichiarare una nuova entità è necessario definire una classe Java e
 utilizzare l'annotazione 
\begin_inset Quotes eld
\end_inset

@Entity
\begin_inset Quotes erd
\end_inset

, che presenta diversi overload per specificare parametri come il nome della
 tabella utilizzato nello schema.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Id
\end_layout

\begin_layout Plain Layout

@GeneratedValue(strategy = GenerationType.TABLE)
\end_layout

\begin_layout Plain Layout

Integer id;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@Column(nullable = false, unique = true)
\end_layout

\begin_layout Plain Layout

String title;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione di alcuni attributi per l'entità Post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rappresentata la tabella, per aggiungere delle colonne è sufficiente introdurre
 degli attributi d'istanza ed annotarli con 
\begin_inset Quotes eld
\end_inset

@Column
\begin_inset Quotes erd
\end_inset

 o altre annotazioni più specifiche.
\end_layout

\begin_layout Standard
Tramite i parametri è possibile dichiarare dei vincoli sui valori, ad esempio
 il titolo di un post deve essere sempre presente ed essere unico.
 Il tipo della colonna è inferito dal tipo Java, il tipo 
\begin_inset Quotes eld
\end_inset

Integer
\begin_inset Quotes erd
\end_inset

 corrisponde a 
\begin_inset Quotes eld
\end_inset

integer
\begin_inset Quotes erd
\end_inset

 in PostgreSQL e 
\begin_inset Quotes eld
\end_inset

String
\begin_inset Quotes erd
\end_inset

 a 
\begin_inset Quotes eld
\end_inset

varchar(255)
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per la definizione di colonne che rappresentano la chiave primaria della
 tabella è stata utilizzata l'annotazione 
\begin_inset Quotes eld
\end_inset

@Id
\begin_inset Quotes erd
\end_inset

 generando i valori in maniera univoca all'interno della tabella corrispondente
 all'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Temporal(TemporalType.TIMESTAMP)
\end_layout

\begin_layout Plain Layout

Date updatedAt;
\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione di un attributo temporale.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'annotazione 
\begin_inset Quotes eld
\end_inset

@Temporal
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
L'enumerazione 
\begin_inset Quotes eld
\end_inset

TemporalType
\begin_inset Quotes erd
\end_inset

 permette di specificare il tipo da mantere sul database, scegliendo fra
 
\begin_inset Quotes eld
\end_inset

java.sql.Date
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

java.sql.Time
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

java.sql.Timestamp
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 permette di rappresentare sul modello attributi di tipo 
\begin_inset Quotes eld
\end_inset

Date
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Calendar
\begin_inset Quotes erd
\end_inset

, non è ancora possibile utilizzare la classe 
\begin_inset Quotes eld
\end_inset

LocalDate
\begin_inset Quotes erd
\end_inset

 introdotta con Java 8 che fornisce diversi metodi per una migliore gestione
 delle fasce orarie.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre gli attributi primitivi che rappresentano le colonne delle tuple,
 sono presenti attributi composti: ogni articolo ha un solo autore ed ogni
 autore può scrivere più articoli, definendo una relazione uno a molti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Author {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	@OneToMany(..., fetch = FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

	Set<Post> posts;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public class Post {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

    @ManyToOne(..., fetch=FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

	Author author;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Le relazioni presenti fra le entità del modello.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con le annotazioni 
\begin_inset Quotes eld
\end_inset

OneToMany
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes erd
\end_inset

ManyToOne
\begin_inset Quotes erd
\end_inset

 e il parametro 
\begin_inset Quotes eld
\end_inset

fetch
\begin_inset Quotes erd
\end_inset

, è possibile caricare in maniera 
\begin_inset Quotes eld
\end_inset

lazy
\begin_inset Quotes erd
\end_inset

 le entità correlate, come i post scritti da un autore, posticipando l'operazion
e al momento dell'eventuale accesso.
 Al contrario, sfruttando il caricamento degli oggetti in maniera 
\begin_inset Quotes eld
\end_inset

eager
\begin_inset Quotes erd
\end_inset

, EclipseLink carica dal modello ogni attributo direttamente o indirettamente
 interessato dalla query, evitando successive interazioni con i database.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La definizione delle relazioni varia in funzione delle entità e di come
 è previsto che siano effettuati gli accessi ai POJO nell'applicazione.
 In JPA è possibile dichiarare relazioni unidirezionali, in cui l'associazione
 è mantenuta da un solo oggetto e non è possibile effettuare la navigazione
 in direzione contraria, oppure bidirezionali.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@ManyToOne(cascade = {CascadeType.MERGE, CascadeType.REFRESH},
\end_layout

\begin_layout Plain Layout

	fetch=FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

@JoinTable(name = AUTHOR_POST_JOIN_TABLE,
\end_layout

\begin_layout Plain Layout

	joinColumns = @JoinColumn(name = POST_JOIN_COLUMN),          	inverseJoinColumn
s = @JoinColumn(name = AUTHOR_JOIN_COLUMN),             uniqueConstraints
 = @UniqueConstraint(columnNames = {                     	AUTHOR_JOIN_COLUMN,
 POST_JOIN_COLUMN}))
\end_layout

\begin_layout Plain Layout

Author author;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Attributo author per la classe Post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@OneToMany(mappedBy = "author",
\end_layout

\begin_layout Plain Layout

	cascade = { CascadeType.ALL },
\end_layout

\begin_layout Plain Layout

	fetch = FetchType.LAZY)
\end_layout

\begin_layout Plain Layout

Set<Post> posts;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Attributo posts per la classe Author.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'attributo 
\begin_inset Quotes eld
\end_inset

fetch
\begin_inset Quotes erd
\end_inset

 specifica il comportamento di EclipseLink per il caricamento dei dati,
 
\begin_inset Quotes eld
\end_inset

cascade
\begin_inset Quotes erd
\end_inset

 definisce i vincoli di integrità referenziale di propagazione.
 A differenza di altre proprietà del DDL di JPA, la propagazione delle operazion
i non ha ripercussioni sullo schema dei database ed è gestita direttamente
 sui POJO; la mancanza di controlli sul DBMS obbliga a descrivere accuratamente
 la logica delle proprie operazioni CRUD, per mantenere la consistenza fra
 i record dei database e gli oggetti ed evitare errori.
\end_layout

\begin_layout Standard
Oltre alle relazioni utilizzate per SBlog sono ovviamente disponibili le
 annotazioni per implementare associazioni con altre cardinalità.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'annotazione 
\begin_inset Quotes eld
\end_inset

@JoinTable
\begin_inset Quotes erd
\end_inset

 dell'attributo 
\begin_inset Quotes eld
\end_inset

author
\begin_inset Quotes erd
\end_inset

 specifica la tabella ausiliaria in cui mantenere la relazione, che conterrà
 coppie formate da identificatori dell'autore e dell'articolo.
 
\begin_inset Quotes eld
\end_inset

@UniqueConstraint
\begin_inset Quotes erd
\end_inset

 introduce un vincolo di unicità.
 Inoltre scegliendo di rappresentare la relazione con un oggetto 
\begin_inset Quotes eld
\end_inset

Set
\begin_inset Quotes erd
\end_inset

 è possibile gestire la cardinalità dell'associazione direttamente al livello
 d'astrazione dei POJO.
\end_layout

\begin_layout Subsubsection*
Generazione dello schema
\end_layout

\begin_layout Standard
La configurazione di Spring avviene principalmente tramite DI, Dependency
 Injection, e la definizione di bean.
 I bean sono metodi factory che istanziano oggetti rappresentanti le diverse
 proprietà configurabili del framework; tramite la DI gli oggetti sono istanziat
i ed utilizzati quando opportuno.
\begin_inset Foot
status open

\begin_layout Plain Layout
La definizione dei bean può avvenire sia tramite factory method opportunamente
 annotati, sia utilizzando file XML.
\end_layout

\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Bean
\end_layout

\begin_layout Plain Layout

public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
\end_layout

\begin_layout Plain Layout

	LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFact
oryBean();
\end_layout

\begin_layout Plain Layout

	em.setDataSource(dataSource());
\end_layout

\begin_layout Plain Layout

	em.setPackagesToScan("sblog.orm");
\end_layout

\begin_layout Plain Layout

	JpaVendorAdapter vendorAdapter = new EclipseLinkJpaVendorAdapter(); 	em.setJpaVe
ndorAdapter(vendorAdapter);
\end_layout

\begin_layout Plain Layout

	em.setJpaProperties(additionalProperties());
\end_layout

\begin_layout Plain Layout

	em.setJpaDialect(new EclipseLinkJpaDialect());
\end_layout

\begin_layout Plain Layout

	return em;
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Configurazione Entity Manager"

\end_inset

Configurazione del metodo factory per la gestione delle entità del modello.
\end_layout

\end_inset


\end_layout

\end_inset

Per impostare la connessione ai database e configurare l'entity manager
 è necessario introdurre almeno due bean.
 In particolare il metodo factory 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Configurazione Entity Manager"

\end_inset

 specifica l'implementazione scelta per JPA e alcune proprietà attraverso
 un apposito metodo 
\begin_inset Quotes eld
\end_inset

additionalProperties
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Fra le proprietà configurabili di EclipseLink è possibile scegliere se generare
 direttamente il database o un script contenente il DDL, inoltre ad ogni
 avvio può essere verificato lo schema ed eventualmente apportate delle
 modiche se non stati fatti dei cambiamenti alle classi delle entità.
\end_layout

\begin_layout Subsubsection*
Query
\end_layout

\begin_layout Standard
Per semplificare la definizione di operazioni CRUD e effettuare delle interrogaz
ioni sul dominio, Spring include una gerarchia di interfacce Java generiche.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface PostRepository extends JpaRepository<Post, Integer> {
\end_layout

\begin_layout Plain Layout

	public Post findPostByTitle(String title); 
\end_layout

\begin_layout Plain Layout

	public List<Post> findPostByTitleContainingIgnoreCase(String title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:PostRepository"

\end_inset

Interfaccia PostRepository per la gestione e interrogazione dell'entità
 Post sul modello.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per utilizzare le funzionalità presenti nella libreria è stata creata un'interfa
ccia 
\begin_inset Quotes eld
\end_inset

PostRepository
\begin_inset Quotes erd
\end_inset

 che estende 
\begin_inset Quotes eld
\end_inset

JpaRepository
\begin_inset Quotes erd
\end_inset

.
 Come si può osservare nell'implementazione, l'interfaccia padre è generica
 sulla classe che rappresenta i post ed il tipo della chiave primaria.
\begin_inset Foot
status open

\begin_layout Plain Layout
L'uso di 
\begin_inset Quotes eld
\end_inset

Integer
\begin_inset Quotes erd
\end_inset

 come tipo della chiave primaria dell'entità Post, piuttosto che utilizzare
 il tipo primitivo 
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

, è stato dettato dalla necessità di usare il tipo come parametro generico
 di 
\begin_inset Quotes eld
\end_inset

JpaRepository
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'interfaccia 
\begin_inset Quotes eld
\end_inset

JpaRepository
\begin_inset Quotes erd
\end_inset

 estende le interfacce generiche 
\begin_inset Quotes eld
\end_inset

CrudRepository
\begin_inset Quotes erd
\end_inset

, che fornisce i metodi corrispondenti alle operazioni CRUD, 
\begin_inset Quotes eld
\end_inset

PagingAndSortingRepository
\begin_inset Quotes erd
\end_inset

 che definisce la possibilità di effettuare interrogazioni paginate
\begin_inset Foot
status open

\begin_layout Plain Layout
Data un'interrogazione, la paginazione restituisce un sottoinsieme delle
 entità risultato in funzione dei parametri di cardinalità e ordinalità,
 rispettivamente il numero di elementi del risultato e la pagina scelta.
\end_layout

\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Repository
\begin_inset Quotes erd
\end_inset

 che è la radice della gerarchia.
\begin_inset Newline newline
\end_inset

L'implementazione delle funzionalità dichiarate nelle interfaccia è fornita
 dalla libreria JPA Criteria, che inferisce dinamicamente dalla segnatura
 del metodo Java una query JPQL, Java Persistence query language.
\end_layout

\begin_layout Standard
JPQL è un linguaggio per la definizione di query che utilizza il paradigma
 ad oggetti, ad esempio le proiezioni SQL sono effettuate utilizzando la
 notazione puntata per l'accesso agli attributi.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
E' possibile estendere le numerose funzionalità presenti nella libreria
 dichiarando nuovi metodi, nell'interfaccia 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:PostRepository"

\end_inset

 sono stati introdotti due metodi che rispettano le convezioni introdotte
 dalla libreria Spring Data Repositories e generano interrogazioni sulle
 entità Post: il metodo 
\begin_inset Quotes eld
\end_inset

findPostByTitle
\begin_inset Quotes erd
\end_inset

 individua un singolo oggetto in funzione del parametro, mentre 
\begin_inset Quotes eld
\end_inset

findPostByTitleContainingIgnoreCase
\begin_inset Quotes erd
\end_inset

 interroga il modello per ottenere le entità il cui titolo soddisfi l'espression
e regolare.
\end_layout

\begin_layout Standard
Come si può intuire dal secondo metodo, l'implementazione di interrogazioni
 con un alto numero di condizioni di selezione comporta la dichiarazione
 di metodi con segnature eccessivamente lunghe e complicate, inoltre non
 è possibile utilizzare l'operazione di join fra entità.
 Per evitare a questi problema è possibile annotare i metodi del interfaccia
 repository con 
\begin_inset Quotes eld
\end_inset

@Query
\begin_inset Quotes erd
\end_inset

 specificando direttamente il testo dell'interrogazione in JPQL.
\end_layout

\begin_layout Subsection
I controlli
\end_layout

\begin_layout Standard
Rispetto a RoR, la cui configurazione dei controlli è principalmente inferita
 in funzione delle convenzioni del framework, in Spring è necessario utilizzare
 un discreto numero di annotazioni.
\end_layout

\begin_layout Standard
Come per RBlog, sono stati sviluppati tre controller per gestire le richieste
 riguardanti gli autori, i post e le procedure di autenticazione ed autorizzazio
ne.
 Un controller in Spring coincide con una classe, annotata con 
\begin_inset Quotes eld
\end_inset

@Controller
\begin_inset Quotes erd
\end_inset

 che ne definisce il ruolo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Controller
\end_layout

\begin_layout Plain Layout

@RequestMapping(value = "/posts")
\end_layout

\begin_layout Plain Layout

public class PostController extends AbstractController {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	@RequestMapping(value = "/{id}", method = RequestMethod.GET) 	public String
 show(@PathVariable Integer id, Model model) { 		Post post = /*...*/
\end_layout

\begin_layout Plain Layout

		model.addAttribute("page_title", post.getTitle());
\end_layout

\begin_layout Plain Layout

		model.addAttribute("content_template", "/posts/show");
\end_layout

\begin_layout Plain Layout

		model.addAttribute("posts", new Post[] { post });
\end_layout

\begin_layout Plain Layout

		return super.defaultMapping(model);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Dichiarazione metodo Show"

\end_inset

Dichiarazione di un controller per i Post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

PostController
\begin_inset Quotes erd
\end_inset

 è la classe che gestisce le richieste riguardanti gli articoli presenti
 sul blog.
 L'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestMapping
\begin_inset Quotes erd
\end_inset

 definisce i parametri delle richieste d'instradamento ed è utilizzabile
 sia per classi che singoli metodi.
 L'uso dell'annotazione per la classe specifica la radice delle richieste
 soddisfacibili dai metodi presenti.
\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

, che permette la lettura di un singolo post, soddisfa l'instradamento delle
 richieste HTTP del tipo 
\begin_inset Quotes eld
\end_inset

posts/42
\begin_inset Quotes erd
\end_inset

 concatenando gli attributi 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 dell'annotazione sulla classe e sul singolo metodo, semplificando la definizion
e di di controlli in stile REST.
\end_layout

\begin_layout Standard
Oltre a specificare gli URL delle richieste, tramite l'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestMapping
\begin_inset Quotes erd
\end_inset

 è possibile configurare quali tipi di connessioni HTTP sono accettati dal
 metodo, 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

 ad esempio accetta esclusivamente richieste in GET.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una particolarità del metodo 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

 è di essere parametrico sull'identificatore intero dei post, l'attributo
 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

/{id}
\begin_inset Quotes erd
\end_inset

 associa, previa conversione di tipo, il valore della stringa all'oggetto
 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 di tipo 
\begin_inset Quotes eld
\end_inset

Integer
\begin_inset Quotes erd
\end_inset

 annotato tramite 
\begin_inset Quotes eld
\end_inset

@PathVariable
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La struttura delle azioni a cui è associata una pagina web, come il metodo
 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

, prevede un oggetto di tipo 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

, utilizzato come parametro di output, al quale aggiungere coppie chiave-valore
 rappresentanti gli attributi dinamici necessari alla vista e una stringa
 come valore di ritorno per specificare l'elemento da renderizzare.
\end_layout

\begin_layout Standard
Per rendere più modulare SBlog, il ritorno delle azioni restituisce sempre
 una stringa che fa riferimento al layout del sito.
 Il parametro 
\begin_inset Quotes eld
\end_inset

content_template
\begin_inset Quotes erd
\end_inset

 utilizzato da un'apposita espressione in Thymeleaf, il template engine
 scelto per SBlog, definisce il contenuto della pagina, nell'esempio verrà
 visualizzata la vista 
\begin_inset Quotes eld
\end_inset

/posts/show
\begin_inset Quotes erd
\end_inset

.
 Maggiori dettagli su Thymeleaf sono presenti nella successiva sezione.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@RequestMapping(value = "/autocomplete_title", method = RequestMethod.GET)
\end_layout

\begin_layout Plain Layout

@ResponseBody
\end_layout

\begin_layout Plain Layout

public String[] autocompleteTitle(@RequestParam(value = "title", required
 = true) String title) {
\end_layout

\begin_layout Plain Layout

		return postService.queryByTitle(title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione di un metodo privo di interfaccia web.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per gestire le richieste HTTP di tipo GET, che includono i parametri direttament
e nell'URL, è utilizzata l'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestParam
\begin_inset Quotes erd
\end_inset

 che permette di ottenere un riferimento ai valori forniti e di introdurre
 anche dei vincoli, nell'esempio è richiesto che sia presente un parametro
 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

.
 Oltre agli attributi 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

required
\begin_inset Quotes erd
\end_inset

 è anche possibile definire un valore di default da applicare in assenza
 del dato.
\end_layout

\begin_layout Standard
Per ottenere un riferimento ad un parametro presente nel body di una richiesta
 HTTP è possibile utilizzare l'annotazione 
\begin_inset Quotes eld
\end_inset

@RequestBody
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La particolarità del metodo 
\begin_inset Quotes eld
\end_inset

autocompleteTitle
\begin_inset Quotes erd
\end_inset

 rispetto all'azione 
\begin_inset Quotes eld
\end_inset

show
\begin_inset Quotes erd
\end_inset

 descritta in precedenza è nel tipo di risposta che fornisce.
 Il metodo, definito per l'auto-completamento del widget di JQuery UI già
 presente in RBlog, restituisce la serializzazione di un array di stringhe
 invece che il riferimento ad una vista.
 L'annotazione 
\begin_inset Quotes eld
\end_inset

@ResponseBody
\begin_inset Quotes erd
\end_inset

 indica che il valore di ritorno dev'essere inserito all'interno di un 
\begin_inset Quotes eld
\end_inset

body
\begin_inset Quotes erd
\end_inset

 di una risposta web.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le azioni di Spring utilizzano ampiamente i parametri come output.
 Introducendo ulteriori parametri rispetto a quelli descritti finora negli
 esempi è possibile attivare e gestire funzionalità utili per le viste.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@RequestMapping(value = "/new", method = RequestMethod.POST) public String
 newPost(@Valid Post post, BindingResult bindingResult, 			Model model,
 RedirectAttributes redirectAttributes, 			HttpSession httpSession) {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ad esempio, la vista relativa alla scrittura di un nuovo articolo prevede
 la gestione di numerosi aspetti, a differenza di RoR che disaccoppia le
 azioni di gestione dei form e della persistenza dell'entità, in Spring
 i due comportamenti sono implementati insieme.
 I parametri utilizzati sono:
\end_layout

\begin_layout Itemize
un'istanza di tipo 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 che rappresenta l'articolo, l'oggetto può essere vuoto in quanto la pagina
 è appena stata visualizzata o contenente i dati dopo aver effettuato il
 salvataggio;
\end_layout

\begin_layout Itemize
un oggetto 
\begin_inset Quotes eld
\end_inset

BindingResult
\begin_inset Quotes erd
\end_inset

 che contiene i possibili messaggi di errore del processo di validazione
 per ogni elemento del form;
\end_layout

\begin_layout Itemize
un oggetto 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

 per fornire parametri alla vista;
\end_layout

\begin_layout Itemize
un oggetto 
\begin_inset Quotes eld
\end_inset

RedirectAttributes
\begin_inset Quotes erd
\end_inset

 per gestire la ridirezione in caso di salvataggio del post;
\end_layout

\begin_layout Itemize
un parametro 
\begin_inset Quotes eld
\end_inset

HttpSession
\begin_inset Quotes erd
\end_inset

 per la gestione della sessione e la verifica delle autorizzazioni;
\end_layout

\begin_layout Standard
La tecnica scelta da Spring per gestire i diversi aspetti comporta un'eccessiva
 mole di parametri e funzionalità da implementare in un singolo metodo.
 Sta allo sviluppatore intervenire fattorizzando le azioni e gestire manualmente
 le diverse casistiche, operazioni comodamente implementate di default in
 RoR alla creazione di un nuovo controllo.
\end_layout

\begin_layout Subsubsection*
I Service
\end_layout

\begin_layout Standard
Per fattorizzare la logica dei controller Spring definisce i service, classi
 Java annotate con 
\begin_inset Quotes eld
\end_inset

@Service
\begin_inset Quotes erd
\end_inset

 che hanno il compito di far interagire i controller con le classi repository
 definite dall'utente.
\end_layout

\begin_layout Standard
In SBlog è presente un 
\begin_inset Quotes eld
\end_inset

SessionService
\begin_inset Quotes erd
\end_inset

, che fornisce le funzionalità per l'autenticazione e la codifica delle
 password, e 
\begin_inset Quotes eld
\end_inset

PostService
\begin_inset Quotes erd
\end_inset

 che assicura la consistenza delle informazioni sul modello, ad esempio
 inizializzando la data di creazione e di aggiornamento un articolo alla
 creazione o alla modifica.
\end_layout

\begin_layout Standard
I service, così come gli helper in RoR, permettono di disaccoppiare la logica
 delle operazioni dalle azioni dei controller, permettendo un'implementazione
 più semplice delle componenti.
\end_layout

\begin_layout Subsubsection*
La dependecy injection
\end_layout

\begin_layout Standard
Per utilizzare al meglio le diverse componenti in SBlog è stato fatto ampio
 uso dell'annotazione 
\begin_inset Quotes eld
\end_inset

@AutoWired
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Controller
\end_layout

\begin_layout Plain Layout

@RequestMapping(value = "/posts")
\end_layout

\begin_layout Plain Layout

public class PostController extends AbstractController {
\end_layout

\begin_layout Plain Layout

	@Autowired 	
\end_layout

\begin_layout Plain Layout

	PostService postService;
\end_layout

\begin_layout Plain Layout

	@Autowired
\end_layout

\begin_layout Plain Layout

	AuthorService authorService;
\end_layout

\begin_layout Plain Layout

	@Autowired
\end_layout

\begin_layout Plain Layout

	SessionService sessionService;
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Uso dell'annotazione @Autowired.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per ogni componente esistente in Spring, sia essa un 
\begin_inset Quotes eld
\end_inset

@Repository
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

@Controller
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

@Service
\begin_inset Quotes erd
\end_inset

, è generato un corrispondente 
\begin_inset Quotes eld
\end_inset

bean
\begin_inset Quotes erd
\end_inset

.
 Grazie all'annotazione 
\begin_inset Quotes eld
\end_inset

@AutoWired
\begin_inset Quotes erd
\end_inset

 e alla dependency injection, le corrette istanze dei componenti sono 
\begin_inset Quotes eld
\end_inset

iniettate
\begin_inset Quotes erd
\end_inset

 quando necessario, semplificando notevolmente la risoluzione delle dipendenze.
\end_layout

\begin_layout Subsection
Le viste
\end_layout

\begin_layout Standard
Per l'implementazione delle viste di SBlog è stato utilizzato Thymeleaf,
 una libreria Java per la generazione dinamica di documenti web.
 La libreria, organizzata in due moduli contenenti le funzionalità standard
 e quelle specifiche per Spring, permette la definizione di pagine dinamiche
 utilizzando esclusivamente elementi sintattici esistenti nell'HTML.
 Al contrario ERB e Razor, il template engine di MVC 5 descritto nel prossimo
 capitolo, prevedono l'utilizzo di delimitatori per includere frammenti
 di codice non interpretabili da un browser ma da processare tramite un
 server web.
\end_layout

\begin_layout Standard
Dopo essermi documentato sui template engine comunemente utilizzati con
 Spring e Java, ho scelto di non implementare le viste tramite JSP, JavaServer
 Page.
 Il motivo principale della scelta sono i diversi problemi tecnici nella
 configurazione della libreria utilizzando Spring MVC 4 e Spring Boot, che
 verrà discusso in seguito.
\end_layout

\begin_layout Subsubsection*
Thymeleaf
\end_layout

\begin_layout Standard
Tutti gli attributi utilizzati dalla libreria sono presenti nel namespace
 
\begin_inset Quotes eld
\end_inset

http://www.thymeleaf.org
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
In eclipse è presente un plugin per assistere lo sviluppatore nella definizione
 delle viste tramite l'auto-completamento e la colorazione delle parole
 chiave.
\end_layout

\end_inset

; una vista definita con Thymeleaf ha estensione e struttura identica ad
 un documento HTML statico: senza il supporto di un server web i tag introdotti
 dalla libreria non vengono analizzati dai browser permettendo l'implementazione
 di prototipi offline, per sviluppare l'interfaccia dell'applicazione non
 è quindi necessario aver già un'architettura MVC funzionante.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<html xmlns:th="http://www.thymeleaf.org">
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Dichiarazione del namespace.
\end_layout

\end_inset


\end_layout

\end_inset

Come in RoR, uno degli obbiettivi nella definizione delle viste è individuare
 delle tecniche per fattorizzare gli elementi comuni.
 Tramite l'attributo 
\begin_inset Quotes eld
\end_inset

th:replace
\begin_inset Quotes erd
\end_inset

 è possibile sostituire il nodo corrente con un'intera vista.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<!DOCTYPE html>
\end_layout

\begin_layout Plain Layout

<html xmlns:th="http://www.thymeleaf.org">
\end_layout

\begin_layout Plain Layout

	<head th:replace="/layouts/head"/>
\end_layout

\begin_layout Plain Layout

	<body th:class="${class_name}">
\end_layout

\begin_layout Plain Layout

		<div id="header" th:replace="/layouts/header"></div>
\end_layout

\begin_layout Plain Layout

		<div th:replace="${content_template}"></div>
\end_layout

\begin_layout Plain Layout

		<div id="footer" th:replace="/layouts/footer"></div>
\end_layout

\begin_layout Plain Layout

	</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Struttura comune delle viste in SBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le viste in SBlog prevedono un elemento 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

, contenente i riferimenti alle risorse come fogli di stile
\begin_inset Foot
status open

\begin_layout Plain Layout
A differenza di RoR e RubyMine, nella definizione delle viste non è stato
 utilizzato Sass, o altre estensioni del CSS, per la mancanza di plugin
 in Eclipse che forniscano la compilazione automatica ed il supporto alla
 scrittura delle pagine di stile.
\end_layout

\end_inset

 e librerie JavaScript.
 Il 
\begin_inset Quotes eld
\end_inset

body
\begin_inset Quotes erd
\end_inset

 è suddiviso in tre principali aree: l'intestazione, il contenuto principale
 ed il piè di pagina.
\begin_inset Newline newline
\end_inset

Indicativamente, ogni attributo presente in HTML5 ha una controparte in
 Thymeleaf per la definizione di comportamenti dinamici, brevemente nelle
 prossime sezioni sono introdotte le funzionalità utilizzate ed alcuni frammenti
 delle viste che le contengono.
\end_layout

\begin_layout Subsubsection*
Visualizzazione dei post
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class='post' th:each="post : ${posts}">
\end_layout

\begin_layout Plain Layout

	<p class="post_title">
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:TL Iterazione sui post"

\end_inset

Iterazione su una collezione di post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'attributo 
\begin_inset Quotes eld
\end_inset

each
\begin_inset Quotes erd
\end_inset

 presente nel primo nodo della vista parziale permette di iterare su una
 collezione 
\begin_inset Quotes eld
\end_inset

posts
\begin_inset Quotes erd
\end_inset

 in maniera simile al costrutto 
\begin_inset Quotes eld
\end_inset

foreach
\begin_inset Quotes erd
\end_inset

 di Java.
 Gli oggetti presenti nella vista sono acceduti tramite l'istanza di 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

 presente nell'azione del controller che ha gestito la richiesta; l'espressione
 
\begin_inset Quotes eld
\end_inset

${id}
\begin_inset Quotes erd
\end_inset

 effettua l'accesso all'elemento associato alla chiave 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class="post_detail" th:text="${post.creationDetail()}"></div>
\end_layout

\begin_layout Plain Layout

<div class="post_detail" th:text="${post.author.authorDetail()}"></div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Iterazione sugli attributi di un post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'interno delle espressioni di Thymeleaf gli attributi forniti alla vista
 sono oggetti ed è quindi possibile accedere ai metodi d'istanza e ai valori.
 L'attributo 
\begin_inset Quotes eld
\end_inset

text
\begin_inset Quotes erd
\end_inset

 sostituisce il testo presente all'interno del nodo HTML con il valore dell'espr
essione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<a th:if="${post.body.length()} > 500" th:href="|/posts/${post.id}|">
\end_layout

\begin_layout Plain Layout

	Leggi 			il resto...
\end_layout

\begin_layout Plain Layout

</a>
\begin_inset Caption Standard

\begin_layout Plain Layout
Utilizzo di un'espressione if.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre all'attributo 
\begin_inset Quotes eld
\end_inset

each
\begin_inset Quotes erd
\end_inset

 sono presenti altre istruzioni, come 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

unless
\begin_inset Quotes erd
\end_inset

, per controllare il flusso dell'esecuzione.
 Nell'esempio il collegamento verrà visualizzato in funzione della guardia,
 in generale l'uso di costrutti come 
\begin_inset Quotes eld
\end_inset

if
\begin_inset Quotes erd
\end_inset

 condiziona la visita da parte di Thymeleaf di tutto il sotto-albero.
\end_layout

\begin_layout Subsubsection*
Gestione dei form
\end_layout

\begin_layout Standard
La gestione dei form è uno dei contesti per cui Thymeleaf è stata specializzato
 per integrarsi al meglio con le funzionalità di Spring.
 Per implementare la verifica dei dati inseriti nei form, in Spring è possibile
 utilizzare le annotazioni presenti nel package 
\begin_inset Quotes eld
\end_inset

javax.validation.constraints
\begin_inset Quotes erd
\end_inset

 di JPA per validare i valori dei singoli attributi, non è possibile ad
 esempio verificare che il titolo di un post non sia già presente nel dominio.
\end_layout

\begin_layout Standard
A differenza di RoR, dove la validazione dei form coincide con la validazione
 effettuata dai database, gli strumenti di Spring replicano i meccanismi
 esistenti a basso livello e permettono di anticipare tali verifiche.
 Questa scelta comporta la duplicazione dei vincoli sul dominio, esprimendoli
 sia a livello logico che di persistenza.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Size(min=5, max=100, message = "Il titolo deve essere compreso fra 5 e
 100 caratteri.")
\end_layout

\begin_layout Plain Layout

@NotNull(message = "Titolo mancante.")
\end_layout

\begin_layout Plain Layout

@Column(nullable = false, unique = true)
\end_layout

\begin_layout Plain Layout

String title;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Uso delle annotazioni di JPA per la validazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre alle annotazioni della libreria è possibile implementarne di personalizzat
e, ad esempio che verifichino l'unicità del titolo, definendo una nuova
 annotazione e una classe contenente la logica.
 Purtroppo nella definizione del vincolo di unicità, sono stati rilevati
 errori nell'uso dei repository istanziati tramite DI e ho dovuto implementarne
 la logica manualmente nel controllo dei post.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Gli errori del form sono forniti ai controller tramite un parametro di tipo
 
\begin_inset Quotes eld
\end_inset

BindingResult
\begin_inset Quotes erd
\end_inset

, già introdotto nella precedente sezione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<div class="error_explanation" th:if="${#fields.hasErrors('title')}">
\end_layout

\begin_layout Plain Layout

	<p id="error_description" th:errors="*{title}"></p>
\end_layout

\begin_layout Plain Layout

</div>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento della vista per la visualizzazione degli errori sul campo del
 titolo.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'interno delle viste di Thymeleaf sono state utilizzate le funzionalità
 della classe ausiliaria 
\begin_inset Quotes eld
\end_inset

fields
\begin_inset Quotes erd
\end_inset

, che implementa le funzionalità per la gestione della compilazione dei
 form HTML.
\begin_inset Foot
status open

\begin_layout Plain Layout
Sono presenti altre classi per il supporto di operazioni comuni nelle viste,
 come la formattazione di date.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rispetto a ERB e Razor, le viste sviluppate con Thymeleaf appaiono più semplici
 e leggibili.
 Utilizzando gli attributi per generare il contenuto dinamico si riduce
 sensibilmente la propensione ad introdurre logica all'interno delle viste,
 rispettando i ruoli delle componenti del pattern MVC.
 Tuttavia Thymeleaf introduce una sintassi articolata e non molto intuitiva
 che può costituire un ostacolo ad una rapida definizione della logica elementar
e di una vista, come la formattazione di una stringa o la generazione dinamica
 di collegamenti.
\end_layout

\begin_layout Subsection
Il testing
\end_layout

\begin_layout Standard
Spring implementa le funzionalità per definire unit ed integration test.
 Per SBlog non sono stati implementati test oltre a quelli di accettazione,
 la struttura e la logica è molto simile a quanto sviluppato su RoR, ma
 ritengo sia utile fornire qualche riferimento.
\begin_inset Newline newline
\end_inset

L'implementazione di unit-test in Spring è possibile grazie alla DI e a
 oggetti mock per poter testare in isolamento le singole funzionalità.
\end_layout

\begin_layout Standard
Per implementare i propri integration-test non è necessario effettuare il
 deploy dell'intera applicazione, infatti sfruttando le funzionalità presenti
 nel modulo 
\begin_inset Quotes eld
\end_inset

spring-test
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Spring Test-Framework"

\end_inset

 è possibile verificare l'interazione delle diverse componenti.
\begin_inset Newline newline
\end_inset

Tutti i test in Spring sono eseguibili tramite JUnit
\begin_inset CommandInset citation
LatexCommand cite
key "JUnit"

\end_inset

: l'annotazione 
\begin_inset Quotes eld
\end_inset

@RunWith
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "JUnit RunWith"

\end_inset

 permette di configurare quale runner utilizzare, è quindi possibile uniformare
 l'ambiente di testing e le funzionalità di supporto per tutti i differenti
 livelli di verifica dell'applicazione.
 Maggiori dettagli su JUnit sono presenti nella prossima sezione.
\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
Spring è estremamente modulare e consente all'utente piena libertà nella
 scelta degli strumenti, che comporta tuttavia la necessità di configurare
 i relativi bean.
 Per semplificare lo sviluppo dell'applicazione è stato utilizzato Spring
 Boot, un progetto degli stessi sviluppatori del framework.
\end_layout

\begin_layout Standard
Per ridurre al minimo la necessità di configurazione di una nuova applicazione,
 è possibile utilizzare i progetti 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

 esistenti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependencies>
\end_layout

\begin_layout Plain Layout

	<dependency>
\end_layout

\begin_layout Plain Layout

		<groupId>org.springframework.boot</groupId> 		<artifactId>spring-boot-starter-we
b</artifactId>
\end_layout

\begin_layout Plain Layout

	</dependency>
\end_layout

\begin_layout Plain Layout

	<dependency>
\end_layout

\begin_layout Plain Layout

		<groupId>org.springframework.boot</groupId>
\end_layout

\begin_layout Plain Layout

		<artifactId>spring-boot-starter-thymeleaf</artifactId>
\end_layout

\begin_layout Plain Layout

	</dependency>
\end_layout

\begin_layout Plain Layout

	<dependency>
\end_layout

\begin_layout Plain Layout

		<groupId>org.springframework.boot</groupId>
\end_layout

\begin_layout Plain Layout

		<artifactId>spring-boot-starter-data-jpa</artifactId>
\end_layout

\begin_layout Plain Layout

		<exclusions>
\end_layout

\begin_layout Plain Layout

			<exclusion> 				<artifactId>hibernate-entitymanager</artifactId>
\end_layout

\begin_layout Plain Layout

				<groupId>org.hibernate</groupId>
\end_layout

\begin_layout Plain Layout

			</exclusion>
\end_layout

\begin_layout Plain Layout

		</exclusions>
\end_layout

\begin_layout Plain Layout

	</dependency>
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Alcuni 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

 di Spring Boot utilizzati per SBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aggiungendo gli opportuni 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

 alle dipendenze del proprio progetto, nell'esempio è mostrato un frammento
 del POM
\begin_inset Foot
status open

\begin_layout Plain Layout
Un POM, Project Object Model, è un file XML utilizzato da Maven per la definizio
ne delle informazioni del progetto.
 All'interno del file è possibile definire diversi processi di compilazione,
 ad esempio includendo o meno le librerie per il testing, dichiarare le
 dipendenze del progetto e molto altro.
\end_layout

\end_inset

 di SBlog ma è possibile utilizzare anche Gradle, le maggior parte delle
 componenti e dei bean necessari sono configurati con le impostazioni più
 comuni.
 Ovviamente alcune proprietà specifiche, come le credenziali per la connessione
 ai database, sono da impostare manualmente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le componenti non configurabili tramite Spring Boot, sia perché troppo specifich
e sia perché riguardanti strumenti non presenti negli 
\begin_inset Quotes eld
\end_inset

starter
\begin_inset Quotes erd
\end_inset

, sono configurabili tramite i bean.
 Spring, attualmente alla versione 4.1, è retro-compatibile permettendo la
 definizione di bean attraverso file XML, definendo una gerarchia di classi
 o tramite l'annotazione 
\begin_inset Quotes eld
\end_inset

@Bean
\begin_inset Quotes erd
\end_inset

 ed i factory method, tecnica utilizzata in SBlog.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-SBlog!"

\end_inset

Hello SBlog!
\end_layout

\begin_layout Standard
Per effettuare un confronto il più attendibile possibile, la libreria di
 test di accettazione definita per RBlog e scritta in Gherkin è stata riutilizza
ta anche per la versione del blog in Spring.
 I due blog sono equivalenti nelle funzionalità e molto simili nelle nelle
 tecnologie utilizzate, in questa e nelle prossime sezioni è descritto il
 processo di definizione dei test, omettendo però la descrizione dei tool
 già utilizzati per RBlog.
\end_layout

\begin_layout Subsection
Cucumber-JVM
\end_layout

\begin_layout Standard
Cucumber-JVM, il porting in Java del framework per Cucumber, presenta differenze
 minime rispetto alla versione per Ruby, principalmente dovute alle diversità
 del linguaggio.
\end_layout

\begin_layout Paragraph
Le funzionalità
\end_layout

\begin_layout Standard
Nell'effettuare il porting dei test di accettazione in Gherkin non è stato
 rilevato alcun problema sintattico né relativo alle funzionalità supportate
 dalla versione Java di Cucumber.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La prima feature di SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Avendo già descritto la struttura di una funzionalità in Gherkin, è possibile
 concentrare l'attenzione sulla configurazione del framework.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>info.cukes</groupId> 	<artifactId>cucumber-junit</artifactId>
\end_layout

\begin_layout Plain Layout

	<version>1.1.8</version>
\end_layout

\begin_layout Plain Layout

	<scope>test</scope>
\end_layout

\begin_layout Plain Layout

</dependency>
\end_layout

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>info.cukes</groupId> 	<artifactId>cucumber-picocontainer</artifactId>
 	<version>1.1.8</version>
\end_layout

\begin_layout Plain Layout

	<scope>test</scope>
\end_layout

\begin_layout Plain Layout

</dependency>
\begin_inset Caption Standard

\begin_layout Plain Layout
Aggiunta delle dipendenze per il BDD in Maven.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per l'esecuzione dei test in Eclipse innanzitutto è necessario includere
 le dipendenze all'interno del POM di Maven.
 Oltre a 
\begin_inset Quotes eld
\end_inset

cucumber-junit
\begin_inset Quotes erd
\end_inset

 è necessario includere anche PicoContainer, una libreria per il supporto
 alla DI utilizzata per individuare le classi contenenti gli hook e le definizio
ne dei passi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@RunWith(Cucumber.class)
\end_layout

\begin_layout Plain Layout

@CucumberOptions(format = {tags = {"@cap1", "~@ignore"})
\end_layout

\begin_layout Plain Layout

public class RunCukesTest {}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Runner per Cucumber-JVM
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aggiunte le dipendenze e le funzionalità è sufficiente configurare un classe
 con le annotazioni di JUnit per eseguire i test.
 L'annotazione 
\begin_inset Quotes eld
\end_inset

@CucumberOptions
\begin_inset Quotes erd
\end_inset

 indica i tag degli scenari da eseguire.
\end_layout

\begin_layout Paragraph
Supporto a Cucumber in RubyMine
\end_layout

\begin_layout Standard
In Eclipse è disponibile un plugin per Cucumber
\begin_inset CommandInset citation
LatexCommand cite
key "Eclipse Cucumber JVM Plugin"

\end_inset

 che fornisce la formattazione del codice scritto in Gherkin, l'auto-completamen
to e l'evidenziatura della sintassi per tutte le lingue supportate.
\end_layout

\begin_layout Standard
Rispetto all'integrazione in RubyMine manca la possibilità di navigare dal
 passo all'implementazione, inoltre la funzionalità per eseguire i test
 tramite le risorse scritte in Gherkin sembra non funzionare, obbligando
 ad eseguire direttamente il runner di JUnit.
\end_layout

\begin_layout Subsection
Selenium
\end_layout

\begin_layout Standard
Selenium è una libreria per l'automazione la navigazione internet.
 Rispetto alle versioni precedenti della libreria, gli sviluppatori affermano
 di aver definito un'interfaccia più intuitiva e compatta.
\end_layout

\begin_layout Standard
Selenium WebDriver, la parte centrale della libreria che implementa le operazion
i per l'accesso alle pagine web, utilizza il supporto nativo di ogni browser
 per l'automazione.
 La prima differenza rispetto a Capybara è nella possibilità di utilizzare
 tutte le funzionalità di browser web, come la navigazione grazie alla cronologi
a e l'uso dei preferiti, piuttosto che limitarsi alla sola navigazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>org.seleniumhq.selenium</groupId> 	<artifactId>selenium-java</artifactId
>
\end_layout

\begin_layout Plain Layout

	<version>2.43.1</version>
\end_layout

\begin_layout Plain Layout

</dependency>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Aggiunta della dipendenza di Selenium a SBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per poter definire i test utilizzando le funzionalità di Selenium è sufficiente
 aggiungere la dipendenza del porting in Java al POM del progetto.
\end_layout

\begin_layout Subsubsection*
PhantomJS
\end_layout

\begin_layout Standard
Data la forte integrazione di Selenium con i browser web è stato scelto
 di adottare anche per i test su SBlog PhantomJS.
 Scegliendo di implementare i test di accettazione automatici con Cucumber,
 nelle varie versioni, ed utilizzando lo stesso software per la navigazione
 dei blog è più facile individuare per ogni problema tecnico la causan ed
 effettuare un'analisi più accurata.
\end_layout

\begin_layout Subsubsection*
Ghost Driver
\end_layout

\begin_layout Standard
Ghost Driver è un'implementazione JavaScript del protocollo WebDriver Web
 di PhantomJS che permette di eseguire i comandi contattando tramite richieste
 HTTP l'interfaccia REST del browser, che restituisce i risultati delle
 interazioni serializzati con JSon.
\end_layout

\begin_layout Standard
Per configurare Ghost Driver è sufficiente aggiungere la dipendenza al POM.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<dependency>
\end_layout

\begin_layout Plain Layout

	<groupId>com.github.detro.ghostdriver</groupId>
\end_layout

\begin_layout Plain Layout

	<artifactId>phantomjsdriver</artifactId>
\end_layout

\begin_layout Plain Layout

	<version>1.1.0</version>
\end_layout

\begin_layout Plain Layout

</dependency>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
L'implementazione di un passo in Cucumber-JVM è eseguita annotando un metodo
 pubblico
\begin_inset Foot
status open

\begin_layout Plain Layout
Non è necessario configurare in maniera particolare le classi contenenti
 le implementazioni dei passi.
\end_layout

\end_inset

 con una delle annotazioni corrispondenti ai passi e specificando il valore
 dell'espressione regolare.
 Inoltre è possibile specificare un parametro 
\begin_inset Quotes eld
\end_inset

timeout
\begin_inset Quotes erd
\end_inset

 per specificare il tempo massimo di esecuzione del passo.
\end_layout

\begin_layout Standard
Come per la versione in Ruby, non c'è corrispondenza fra il tipo dell'implementa
zione, in Java è rappresentato dall'annotazione, ed i tipi di passi applicabili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Dato("^apro SBlog$")
\end_layout

\begin_layout Plain Layout

public void apro_SBlog() {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro SBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro SBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per implementare passi parametrici è sufficiente aggiungere dei parametri
 al metodo; come in Ruby i valori estratti dall'espressione del passo hanno
 tipo stringa, ma è possibile annotare i parametri con 
\begin_inset Quotes eld
\end_inset

@Format
\begin_inset Quotes erd
\end_inset

 per effettuare eventuali conversioni.
\end_layout

\begin_layout Standard
Eventuali inconsistenze fra il numero di parametri del passo e del metodo
 sono segnalate tramite eccezione.
\end_layout

\begin_layout Paragraph
La struttura di Selenium
\end_layout

\begin_layout Standard
Rispetto alla struttura di Capybara, Selenium organizza le funzionalità
 in maniera articolata
\begin_inset CommandInset citation
LatexCommand cite
key "Selenium Hierarchy"

\end_inset

.
 La libreria è rappresentata attraverso più gerarchie di classi, interfacce
 ed enumerazioni.
 Di seguito sono introdotti gli elementi più importanti e maggiormente utilizzat
i per il testing su SBlog:
\end_layout

\begin_layout Itemize
l'interfaccia 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 rappresenta gli elementi HTML e include le principali operazioni eseguibili
 tramite Selenium.
 Le linee guida della libreria prevedono che ogni metodo effettui un controllo
 sulla validità del chiamante, verificando che sia presente nel DOM al momento
 dell'esecuzione dell'operazione;
\end_layout

\begin_layout Itemize
l'interfaccia 
\begin_inset Quotes eld
\end_inset

WebDriver
\begin_inset Quotes erd
\end_inset

 è la radice della gerarchia delle operazioni che descrivono le operazioni
 eseguibili durante i test.
 Le funzionalità dichiarate nell'interfaccia riguardano il controllo del
 browser stesso, la selezione degli elementi presenti nel DOM e il supporto
 al debug durante i test;
\end_layout

\begin_layout Itemize
la classe astratta 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

 implementa diversi factory metod per individuare elementi all'interno del
 DOM.
 Il metodo 
\begin_inset Quotes eld
\end_inset

findElement
\begin_inset Quotes erd
\end_inset

 dell'interfaccia 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 richiede un'istanza della classe 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

 per compiere la ricerca nel documento.
 Rispetto a Capybara le possibilità per implementare un selettore sono indicativ
amente equivalenti, ma Selenium offre metodi come 
\begin_inset Quotes eld
\end_inset

ByTagName
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

ByPartialLinkText
\begin_inset Quotes erd
\end_inset

, derivati rispettivamente da 
\begin_inset Quotes eld
\end_inset

ByCssSelector
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

ByLinkText
\begin_inset Quotes erd
\end_inset

, che semplificano lo sviluppo dei test;
\end_layout

\begin_layout Itemize
l'interfaccia 
\begin_inset Quotes eld
\end_inset

WebDriverException
\begin_inset Quotes erd
\end_inset

 rappresenta la gerarchia degli errori presenti nella libreria.
\end_layout

\begin_layout Paragraph
Navigare all'interno del sito
\end_layout

\begin_layout Standard
La navigazione in Selenium è effettuabile utilizzando tre tipologie di metodi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

driver.navigate().to(getSblogURL());
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Navigazione esplicita.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

navigate
\begin_inset Quotes erd
\end_inset

 restituisce un'istanza di tipo 
\begin_inset Quotes eld
\end_inset

Navigation
\begin_inset Quotes erd
\end_inset

 che permette al driver di accedere alle funzionalità del browser e di navigare,
 sia utilizzando la cronologia, sia indicando esplicitamente un URL da raggiunge
re.
 Il metodo 
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

 effettua richiesta in GET per l'URL specificato e blocca l'esecuzione fino
 al caricamento della nuova pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WebElement link = driver.findElement(By.linkText(linkText));
\end_layout

\begin_layout Plain Layout

link.click();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:evento naviga verso selenium"

\end_inset

Navigazione nel sito, sfruttando il testo visualizzato di un link.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre alla navigazione esplicita, è possibile compiere effettuare un azione,
 come il click di un collegamento, su un oggetto 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 individuato tramite un selettore.
 Nell'esempio è effettuata la navigazione ad una delle pagine statiche del
 blog presenti per la prima funzionalità, individuando il link attraverso
 il testo degli elementi 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

findElement
\begin_inset Quotes erd
\end_inset

 restituisce il primo elemento che soddisfa il selettore di tipo 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

.
 Per ogni ricerca all'interno del DOM è previsto un tempo massimo di attesa
 entro il quale l'elemento deve apparire ed una frequenza di polling.
 L'eccezione 
\begin_inset Quotes eld
\end_inset

NoSuchElementException
\begin_inset Quotes erd
\end_inset

 è sollevata nel caso l'elemento non sia presente.
\end_layout

\begin_layout Paragraph
Integrazione con JUnit
\end_layout

\begin_layout Standard
Per l'esecuzione degli scenari e la definizione delle asserzioni è stato
 utilizzato JUnit, una libreria Java per la definizione di test.
 Le asserzioni in JUnit sono metodi statici della classe 
\begin_inset Quotes eld
\end_inset

Assert
\begin_inset Quotes erd
\end_inset

 ed offrono le funzionalità per la verifica dello stato di uno o più oggetti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WebElement logo = driver.findElement(By.id("logo"));
\end_layout

\begin_layout Plain Layout

assertEquals(logo.getAttribute("href"), getSblogURL());
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica del attributo 
\begin_inset Quotes eld
\end_inset

href
\begin_inset Quotes erd
\end_inset

 del collegamento presente nell'intestazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

assertEquals(driver.getTitle(), pageTitle);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica del titolo della pagina.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
Per semplificare lo sviluppo delle applicazioni è stato scelto di riutilizzare
 sia la struttura delle pagine che i fogli di stile creati per RBlog.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Feature: Introducendo il CSS
\end_layout

\begin_layout Plain Layout

Per rendere l'esperienza di navigazione gradevole
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che il sito esponesse una grafica omogenea
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:02x00 Introducendo il CSS"

\end_inset

Seconda funzionalità per SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante sia sempre più diffusa la pratica di utilizzare linguaggi come
 Sass, che arricchiscono CSS 3 come già discusso nel precedente capitolo,
 non è ancora fornito il supporto in Eclipse.
 Per evitare la riscrittura manuale ho compilato i fogli di stile tramite
 il comando 
\begin_inset Quotes eld
\end_inset

sass *.scss
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Il processo di conversione non gestisce al meglio i commenti presenti nei
 file scss, generando dei fogli di stile non validi.
 Per sicurezza infatti ho verificato i documenti con il validatore disponibile
 sul sito del W3C.
\end_layout

\end_inset

 per convertirli al formato classico.
\end_layout

\begin_layout Subsection
Testare il css
\end_layout

\begin_layout Standard
SBlog presenta quindi un layout molto simile alla precedente versione, compresi
 i minimi effetti cromatici dell'intestazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: l'intestazione espone dei semplici effetti cromatici
\end_layout

\begin_layout Plain Layout

	Dato che è presente l'intestazione
\end_layout

\begin_layout Plain Layout

	E l'intestazione permette la navigazione
\end_layout

\begin_layout Plain Layout

	E i collegamenti non hanno sfondo
\end_layout

\begin_layout Plain Layout

	Quando il cursore si sposta sui collegamenti
\end_layout

\begin_layout Plain Layout

	Allora lo sfondo del collegamento cambia
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Variazione del colore del colore di background dei collegamenti nell'intestazion
e.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Analisi delle proprietà stilistiche dei nodi
\end_layout

\begin_layout Standard
La funzionalità 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:02x00 Introducendo il CSS"

\end_inset

 richiede di verificare alcuni elementi del layout di SBlog.
\end_layout

\begin_layout Standard
L'interfaccia 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 dichiara il metodo 
\begin_inset Quotes eld
\end_inset

getCssValue
\begin_inset Quotes erd
\end_inset

 per ottenere stringhe rappresentanti gli attributi stilistici di un elemento
 del DOM.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Dato("^l'intestazione ha un colore di sfondo$")
\end_layout

\begin_layout Plain Layout

public void l_intestazione_ha_un_colore_di_sfondo(){
\end_layout

\begin_layout Plain Layout

	String rgb = page.header.getCssValue("background-color");
\end_layout

\begin_layout Plain Layout

	assertNotNull(rgb);
\end_layout

\begin_layout Plain Layout

	assertNotEquals("rgba(0, 0, 0, 0)", rgb);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può osservare dall'implementazione, Selenium rispetto a Capybara
 ottiene il corretto valore di un elemento del DOM, anche se il parametro
 è attribuito tramite un foglio di stile incluso nell'header della pagina,
 grazie ad una migliore integrazione con le funzionalità del browser.
\end_layout

\begin_layout Standard
Purtroppo però, oltre alla classe 
\begin_inset Quotes eld
\end_inset

Color
\begin_inset Quotes erd
\end_inset

 che interpreta stringhe nel formato appena mostrato, non è presente nessuna
 funzionalità per semplificare l'utilizzo dei valori restituiti, lo sviluppatore
 deve quindi, tramite espressioni regolari e conversioni di tipo, analizzare
 manualmente le stringhe per effettuare operazioni più complesse.
\end_layout

\begin_layout Standard
Inoltre al metodo 
\begin_inset Quotes eld
\end_inset

getCssValue
\begin_inset Quotes erd
\end_inset

 è possibile fornire solo attributi validi per le specifiche del CSS 2,
 ad esempio l'attributo 
\begin_inset Quotes eld
\end_inset

margin
\begin_inset Quotes erd
\end_inset

, che attraverso una tupla di quattro valori definisce tutti i margini di
 un elemento HTML, non è sono supportato.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Allora("^intestazione e pié di pagina hanno lo stesso colore di sfondo$")
\end_layout

\begin_layout Plain Layout

public void intestazione_e_pié_di_pagina_hanno_lo_stesso_colore_di_sfondo(){
\end_layout

\begin_layout Plain Layout

	String headerBackgroundColor, footerBackgroundColor;
\end_layout

\begin_layout Plain Layout

	headerBackgroundColor = page.header.getCssValue("background-color");
\end_layout

\begin_layout Plain Layout

	footerBackgroundColor = page.footer.getCssValue("background-color");
\end_layout

\begin_layout Plain Layout

	assertEquals(headerBackgroundColor, footerBackgroundColor);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante le difficoltà nell'utilizzo dei risultati, il metodo 
\begin_inset Quotes eld
\end_inset

getCssValue
\begin_inset Quotes erd
\end_inset

 risponde in maniera consistente ai principi del CSS.
 Il valore di default dell'attributo 
\begin_inset Quotes eld
\end_inset

background-color
\begin_inset Quotes erd
\end_inset

 per i collegamenti dell'intestazione coincide con la trasparenza massima,
 come mostrato nel prossimo frammento.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Dato("^i collegamenti non hanno sfondo$") public void i_collegamenti_non_hanno_
sfondo(){
\end_layout

\begin_layout Plain Layout

	List<WebElement> bannerLinks = page.header.findElements(By.className("banner_link"
));
\end_layout

\begin_layout Plain Layout

	for (WebElement banner_link : bannerLinks) { 		String rgb = banner_link.getCssVa
lue("background-color");
\end_layout

\begin_layout Plain Layout

		assertNotNull(rgb);
\end_layout

\begin_layout Plain Layout

		assertEquals("rgba(0, 0, 0, 0)", rgb); 	}
\end_layout

\begin_layout Plain Layout

	page.setBannerLinks(bannerLinks);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Actions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Quando("^il cursore si sposta sui collegamenti$")
\end_layout

\begin_layout Plain Layout

public void il_cursore_si_sposta_sui_collegamenti() {
\end_layout

\begin_layout Plain Layout

	Actions action = new Actions(driver);
\end_layout

\begin_layout Plain Layout

	WebElement bannerLink = page.getBannerLinks().get(0);
\end_layout

\begin_layout Plain Layout

	action.moveToElement(bannerLink).perform();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Creazione di una macro azione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La classe 
\begin_inset Quotes eld
\end_inset

Actions
\begin_inset Quotes erd
\end_inset

 permette di emulare complicate operazioni effettuate sul browser, definendo
 delle macro.
 E' possibile definire azioni di due tipi:
\end_layout

\begin_layout Itemize
eventi eseguibili tramite tastiera, come la pressione di uno o più tasti
 combinati, ad esempio corrispondenti alle hotkeys implementate dal browser
 web;
\end_layout

\begin_layout Itemize
eventi eseguibili tramite il mouse, come il semplice click o azioni più
 complesse come il drag & drop;
\end_layout

\begin_layout Standard
Nell'esempio precedente è definita una macro azione, il costruttore con
 un solo parametro di tipo 
\begin_inset Quotes eld
\end_inset

WebDriver
\begin_inset Quotes erd
\end_inset

 utilizza le azioni implementate da Selenium di default; anche se descritta
 dal solo spostamento del cursore sopra l'elemento indicato, è utile per
 mostrarne il comportamento.
\end_layout

\begin_layout Standard
Gli eventi della classe 
\begin_inset Quotes eld
\end_inset

Actions
\begin_inset Quotes erd
\end_inset

 restituiscono un'istanza dello stesso tipo, permettendo quindi la concatenazion
i di più invocazioni di metodi.
 Per eseguire la macro è presente il metodo 
\begin_inset Quotes eld
\end_inset

perform
\begin_inset Quotes erd
\end_inset

.
 E' anche possibile disaccoppiare la generazione dell'azione complessa dall'esec
uzione tramite il metodo 
\begin_inset Quotes eld
\end_inset

build
\begin_inset Quotes erd
\end_inset

 di 
\begin_inset Quotes eld
\end_inset

Actions
\begin_inset Quotes erd
\end_inset

 che restituisce un'istanza di 
\begin_inset Quotes eld
\end_inset

Action
\begin_inset Quotes erd
\end_inset

, utile per eseguire più volte una stessa operazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Allora("^lo sfondo del collegamento cambia$") public void lo_sfondo_del_collega
mento_cambia() {
\end_layout

\begin_layout Plain Layout

	WebElement bannerLink = page.getBannerLinks().get(0);
\end_layout

\begin_layout Plain Layout

	String bannerLinkColor = bannerLink.getCssValue("background-color");
\end_layout

\begin_layout Plain Layout

	assertNotEquals("rgba(0, 0, 0, 0)", bannerLinkColor);
\end_layout

\begin_layout Plain Layout

	assertEquals("rgba(91, 168, 42, 1)", bannerLinkColor);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Cambiamento del colore di sfondo dei collegamenti.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può intuire dalle asserzioni presenti nel passo, lo spostamento
 del cursore modifica il colore dello sfondo, verificando lo scenario.
\end_layout

\begin_layout Subsubsection*
Selettori
\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

findElement
\begin_inset Quotes erd
\end_inset

 restituisce il primo elemento, in ordine di apparizione all'interno del
 DOM, che soddisfa il selettore specificato tramite i metodi statici di
 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

.
 Per ottenere tutti gli oggetti 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 validi è possibile utilizzare il metodo 
\begin_inset Quotes eld
\end_inset

findElements
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Allora("^ogni collegamento ha una descrizione testuale$")
\end_layout

\begin_layout Plain Layout

public void ogni_collegamento_ha_una_descrizione_testuale(){ 	List<WebElement>
 linkedImages = driver.findElements(By 				.cssSelector("a img"));
\end_layout

\begin_layout Plain Layout

	for (WebElement linkedImage : linkedImages) {
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fra i selettori offerti da 
\begin_inset Quotes eld
\end_inset

By
\begin_inset Quotes erd
\end_inset

 è presente anche la possibilità di utilizzare espressioni XPath.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

WebElement findByXPath(String xpathExpression){ 	return driver.findElement(By.xpat
h(xpathExpression));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Debug con Selenium
\end_layout

\begin_layout Standard
Come per Capybara, l'esecuzione di test in modalità debug non offre molte
 informazioni utili per individuare eventuali errori nell'applicazione o
 nell'implementazione dei test.
 Avendo utilizzato nuovamente PhantomJS, che in quanto browser headless
 non espone una GUI, è stato necessario combinare la possibilità di catturare
 le schermate e l'introduzione di breakpoint per valutare lo stato dell'esecuzio
ne.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Gestione dei post
\end_layout

\begin_layout Plain Layout

	Come Autore
\end_layout

\begin_layout Plain Layout

	Vorrei poter inserire, leggere, modificare e rimuovere dei post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter documentare la tesi
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:03x00 Modello"

\end_inset

Funzionalità dell'iterazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La funzionalità corrente introduce in SBlog le operazioni CRUD per i post.
 Introdurre la gestione delle entità in un'applicazione web in Spring coincide
 con l'implementazione delle componenti descritte all'interno del capitolo
 introduttivo sul framework MVC.
\end_layout

\begin_layout Subsection
Dipendenze
\end_layout

\begin_layout Standard
Come già riscontrato nell'implementazione della stessa funzionalità per
 RBlog, introdurre le entità e le relative operazioni richiede l'introduzione
 di meccanismi per garantire che i test di accettazione siano ripetibili
 ed indipendenti fra loro.
\end_layout

\begin_layout Paragraph
Hooks
\end_layout

\begin_layout Standard
Con gli hook presenti in Cucumber è possibile definire delle callback da
 associare ad un certo punto dell'esecuzione dei test.
 Rispetto alla precedente implementazione e grazie alle funzionalità di
 Selenium non è stato necessario effettuare la cancellazione delle sessioni
 HTTP create tramite l'autenticazione.
\end_layout

\begin_layout Standard
Sono stati definiti due metodi, 
\begin_inset Quotes eld
\end_inset

setUpWebDriver
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

releaseWebDriver
\begin_inset Quotes erd
\end_inset

, eseguiti rispettivamente prima e dopo ogni scenario.
 I metodi sono responsabili della creazione di una nuova finestra, per la
 quale è anche specificata una dimensione, ed la successiva chiusura.
 Questa pratica, sicuramente costosa in termini di tempo d'esecuzione, permette
 però di eliminare le sessioni esistenti del browser ed evitare l'esecuzione
 di test in finestre precedentemente utilizzate per altri scenari.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Before
\end_layout

\begin_layout Plain Layout

public void setUpWebDriver() { 		driver = new PhantomJSDriver(); 		assertNotNull
(driver); 	driver.manage().window().setPosition(new Point(0, 0)); 	driver.manage().wi
ndow().setSize(new Dimension(2048, 2048));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@After(order = 0)
\end_layout

\begin_layout Plain Layout

public void releaseWebDriver() {
\end_layout

\begin_layout Plain Layout

	driver.close();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Apertura e chiusura di una nuova 
\begin_inset Quotes eld
\end_inset

finestra
\begin_inset Quotes erd
\end_inset

 di PhantomJS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per implementare un hook in Cucumber JVM è necessario dichiarare un metodo
 pubblico ed utilizzare una o più delle annotazioni fornite.
 Le annotazioni utilizzabili forniscono le stesse funzionalità descritte
 per la versioni in Ruby e permettono di indicare sia per quali tag è necessario
 eseguire le callback, sia un attributo order che ne stabilisce la priorità
 d'esecuzione, nell'esempio il valore 0 specifica che il metodo 
\begin_inset Quotes eld
\end_inset

releaseWebDriver
\begin_inset Quotes erd
\end_inset

 verrà eseguito sempre come ultima operazione di uno scenario.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@After(value = "@clear")
\end_layout

\begin_layout Plain Layout

public void clearIpsums() {
\end_layout

\begin_layout Plain Layout

	driver.navigate().to(getSblogURL());
\end_layout

\begin_layout Plain Layout

	String loremIpsumPostTitle = "Lorem Ipsum";
\end_layout

\begin_layout Plain Layout

	try {
\end_layout

\begin_layout Plain Layout

		String xpathExpression =
\end_layout

\begin_layout Plain Layout

			String.format("//div[@class = 'post'][p/a[contains(text(),'%s')]]",
\end_layout

\begin_layout Plain Layout

				loremIpsumPostTitle);
\end_layout

\begin_layout Plain Layout

		List<WebElement> postDivs = driver.findElements(By 					.xpath(xpathExpression))
;
\end_layout

\begin_layout Plain Layout

		for (WebElement postDiv : postDivs){
\end_layout

\begin_layout Plain Layout

			postDiv.findElement(By.className("remove_post_button")).click();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} catch (NoSuchElementException e) {
\end_layout

\begin_layout Plain Layout

		//
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Rimozione dei post 
\begin_inset Quotes eld
\end_inset

Lorem Ipsum
\begin_inset Quotes erd
\end_inset

 creati nello scenario.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La callback 
\begin_inset Quotes eld
\end_inset

clearIpsums
\begin_inset Quotes erd
\end_inset

 effettua la rimozione dei post con titolo contenente la stringa 
\begin_inset Quotes eld
\end_inset

Lorem Ipsum
\begin_inset Quotes erd
\end_inset

 in maniera simile a quanto effettuato per RBlog.
 Il blocco 
\begin_inset Quotes eld
\end_inset

catch
\begin_inset Quotes erd
\end_inset

 per l'eccezione 
\begin_inset Quotes eld
\end_inset

NoSuchElementException
\begin_inset Quotes erd
\end_inset

 è stato introdotto per evitare che test non funzionanti, ad esempio che
 falliscono la creazione di un post, non interrompano la corretta esecuzione
 della libreria.
\end_layout

\begin_layout Subsection
Gestione dei form
\end_layout

\begin_layout Standard
Selenium fornisce un'interfaccia lineare ed intuitiva per l'utilizzo di
 form.
 Nel successivo metodo, che descrive una generica operazione di inserimento
 del testo, si può osservare come non sia necessario compiere operazioni
 particolari per individuare nel DOM e utilizzare i campi di input di un
 
\begin_inset Quotes eld
\end_inset

form
\begin_inset Quotes erd
\end_inset

 HTML.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

protected void insertPostTitle(String title) {
\end_layout

\begin_layout Plain Layout

	WebElement titleInput = driver.findElement(By.id("post_title"));
\end_layout

\begin_layout Plain Layout

	titleInput.clear();
\end_layout

\begin_layout Plain Layout

	titleInput.sendKeys(title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

insertPostTitle
\begin_inset Quotes erd
\end_inset

 inserisce il testo passato come parametro all'interno del form per la creazione
 o modifica di un articolo
\begin_inset Foot
status open

\begin_layout Plain Layout
Il metodo 
\begin_inset Quotes eld
\end_inset

clear
\begin_inset Quotes erd
\end_inset

 è necessario per gestire le operazioni di modifica, infatti il metodo 
\begin_inset Quotes eld
\end_inset

sendKeys
\begin_inset Quotes erd
\end_inset

 si limita ad aggiungere il testo al campo, concatenando le stringhe.
\end_layout

\end_inset

.Oltre alla compilazione testuale di un form, Selenium implementa le funzionalità
 per la spunta dei checkbox, selezionare le opzioni di menu a tendina ed
 effettuare il caricamento di file.
\end_layout

\begin_layout Subsubsection*
Verificare gli errori
\end_layout

\begin_layout Standard
A differenza di RSpec, la cui struttura prevede 4 moduli organizzati per
 funzionalità, JUnit ha una struttura monolitica.
 Per definire un test con JUnit è necessario annotare con 
\begin_inset Quotes eld
\end_inset

@Test
\begin_inset Quotes erd
\end_inset

 un metodo pubblico, utilizzando però Cucumber non è possibile far corrispondere
 a ciascun scenario un singolo test.
 I test infatti sono definiti dinamicamente tramite il runner di Cucumber
 che seleziona i metodi corrispondenti a ciascun passo e non rispetta quindi
 la struttura classica prevista da JUnit.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Test
\end_layout

\begin_layout Plain Layout

public void nomeDelTestInJUnit() {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione di un test con JUnit.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In assenza della corrispondenza 
\begin_inset Quotes eld
\end_inset

@Test
\begin_inset Quotes erd
\end_inset

 - scenario, non è possibile utilizzare le funzionalità di JUnit implementate
 tramite annotazione, come la verifica delle eccezioni o la definizione
 di 
\begin_inset Quotes eld
\end_inset

@Rule
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "JUnit Rule"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

	visitHomePage();
\end_layout

\begin_layout Plain Layout

	findPostDivByTitle(postTitle);
\end_layout

\begin_layout Plain Layout

	fail();
\end_layout

\begin_layout Plain Layout

} catch (NoSuchElementException e) {
\end_layout

\begin_layout Plain Layout

	//
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Un possibile 
\begin_inset Quotes eld
\end_inset

work-around
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per definire asserzioni che verifichino la presenza di errori, nell'esempio
 è verificato che nella home-page di SBlog non sia presente un post con
 titolo uguale al parametro, è possibile utilizzare una combinazione del
 metodo statico 
\begin_inset Quotes eld
\end_inset

fail
\begin_inset Quotes erd
\end_inset

 della classe 
\begin_inset Quotes eld
\end_inset

Assert
\begin_inset Quotes erd
\end_inset

 di JUnit e un blocco 
\begin_inset Quotes eld
\end_inset

try-catch
\begin_inset Quotes erd
\end_inset

 sull'errore desiderato.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Login & Autorizzazione
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Autenticazione su RBlog
\end_layout

\begin_layout Plain Layout

	Come Autore di RBlog
\end_layout

\begin_layout Plain Layout

	Vorrei che alcune operazioni sensibili siano permesse previa autenticazione
\end_layout

\begin_layout Plain Layout

	Per poter garantire l'autenticità dei contenuti
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Descrizione della funzionalità di autenticazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per introdurre la gestione dell'autenticazione in SBlog è stato introdotto
 un controllo ed una vista per effettuare il login.
 Come per RBlog, le azioni prevedono la verifica dell'autorizzazione, ad
 esempio non è possibile effettuare il logon se l'utente non è autenticato.
\end_layout

\begin_layout Standard
L'entità Session, per cui è stato definito il controllo, non è presente
 nel modello ma mantiene esclusivamente lo stato della navigazione, mantenedo
 all'interno della sessione HTTP un riferimento all'identificatore dell'utente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@RequestMapping(value = "/logout", method = RequestMethod.GET) public String
 destroy(Model model, RedirectAttributes redirectAttributes, 			HttpSession
 httpSession){
\end_layout

\begin_layout Plain Layout

	if(sessionService.isLogged(httpSession)){
\end_layout

\begin_layout Plain Layout

		redirectAttributes.addFlashAttribute("content_template", 					"/posts/index");
\end_layout

\begin_layout Plain Layout

		redirectAttributes.addFlashAttribute("notice", "Arrivederci!");
\end_layout

\begin_layout Plain Layout

		httpSession.invalidate();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return "redirect:/";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

destroy
\begin_inset Quotes erd
\end_inset

, dichiarato all'interno della classe SessionController, verifica il valore
 della sessione ed eventualmente invalida il contenuto.
 L'azione non restituisce un riferimento ad una vista, ma reindirizza la
 navigazione verso l'home-page di SBlog, tramite la concatenazione della
 stringa 
\begin_inset Quotes eld
\end_inset

redirect:
\begin_inset Quotes erd
\end_inset

 e l'indirizzo relativo di destinazione.
 Al contrario di RoR, che definisce i 
\begin_inset Quotes eld
\end_inset

Filter
\begin_inset Quotes erd
\end_inset

, non è previsto una funzionalità per applicare delle callback per le azioni
 dei controlli.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per poter sfruttare le funzionalità di Spring per la gestione della sessione,
 è necessario aggiungere un parametro HttpSession alla segnatura del metodo,
 che sarà opportunamente istanziato dal framework con i valori correnti
 della navigazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Dato("^mi autentico come 
\backslash
"(.*?)
\backslash
"$")
\end_layout

\begin_layout Plain Layout

public void mi_autentico_come(String email) {
\end_layout

\begin_layout Plain Layout

	WebElement loginLink = findById("log_in_link");
\end_layout

\begin_layout Plain Layout

	loginLink.click();
\end_layout

\begin_layout Plain Layout

	WebElement emailInputElement = driver.findElement(By.name("email"));
\end_layout

\begin_layout Plain Layout

	WebElement passwordInputElement = driver.findElement(By.name("password"));
\end_layout

\begin_layout Plain Layout

	emailInputElement.sendKeys(email); 	passwordInputElement.sendKeys("password");
 	emailInputElement.submit();
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout

Login tramite Selenium.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per effettuare il login in SBlog è sufficiente inserire email e password
 nell'apposito form, operazioni effettuate tramite il metodo 
\begin_inset Quotes eld
\end_inset

sendKeys
\begin_inset Quotes erd
\end_inset

 già mostrato in precedenza.
 Il metodo, invocabile tramite un numero variabile di 
\begin_inset Quotes eld
\end_inset

CharSequence
\begin_inset Quotes erd
\end_inset

, simula pressione dei tasti.
 Non è stato verificato nei test, ma la documentazione del metodo indica
 che gli eventi relativi alla pressione del tasto, 
\begin_inset Quotes eld
\end_inset

keyup
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

keydown
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

keypress
\begin_inset Quotes erd
\end_inset

, sono scatenati per ogni carattere della stringa.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una funzionalità interessante di Selenium è la possibilità di inviare il
 contenuto del form, invocando il metodo 
\begin_inset Quotes eld
\end_inset

submit
\begin_inset Quotes erd
\end_inset

 su uno qualunque degli elementi inclusi in esso, come mostrato nel passo
 precedente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
All'interno della libreria sono presenti due classi per la gestione dei
 cookie: 
\begin_inset Quotes eld
\end_inset

Cookie
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Cookie.Builder
\begin_inset Quotes erd
\end_inset

.
 Le funzionalità presenti permettono la creazione, la cancellazione, la
 ricerca e modifica dei cookie esistenti.
 Come per RBlog però, le sessioni in Spring non espongono i valori in chiaro
 e non sono state effettuate operazioni di codifica e decodifica, evidentemente
 in linea con lo stile dei black box test.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Asincronia
\end_layout

\begin_layout Standard
In questa sezione sono descritti i test di accettazione effettuati per verificar
e le funzionalità di Selenium nella gestione di comportamenti asincroni.
\end_layout

\begin_layout Subsection
JavaScript
\end_layout

\begin_layout Standard
L'obbiettivo della prima funzionalità è verificare il comportamento di Selenium
 con un comportamento asincrono ma estremamente rapido.
 Come per RBlog, è aggiunto, tramite una chiamata ad una funzione JavaScript
 associata, una piccola logo al piè di pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Easter Egging
\end_layout

\begin_layout Plain Layout

	Come Sviluppatore
\end_layout

\begin_layout Plain Layout

	Vorrei che nel blog fosse presente un mio logo
\end_layout

\begin_layout Plain Layout

	Per firmare il mio lavoro
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:05bx00 EasterEgg"

\end_inset

Introduzione di un breve script Javascript.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Selenium prevede un doppio meccanismo per ricercare un elemento all'interno
 del DOM, è infatti possibile implementare un meccanismo implicito di attesa,
 in maniera simile a Capybara, impostando un tempo massimo di attesa per
 ogni ricerca, non è però possibile impostare una frequenza di polling,
 oppure utilizzare delle attese esplicite.
\end_layout

\begin_layout Standard
Per l'implementazione dei test è stato scelto di utilizzare quest'ultima
 soluzione che prevede di impostare un'attesa massima ed una condizione
 da verificare.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Allora("^è presente il logo$")
\end_layout

\begin_layout Plain Layout

public void è_presente_il_logo() {
\end_layout

\begin_layout Plain Layout

	new WebDriverWait(driver, 2).until(ExpectedConditions 				.presenceOfElementLocat
ed(By.id("woodstock")));
\end_layout

\begin_layout Plain Layout

	page.footer.findElement(By.cssSelector("img"));
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout

Verifica della presenza del logo nel piè di pagina.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel listato precedente è descritta una condizione, corrispondente al metodo
 statico 
\begin_inset Quotes eld
\end_inset

presenceOfElementLocated
\begin_inset Quotes erd
\end_inset

 della classe 
\begin_inset Quotes eld
\end_inset

ExpectedConditions
\begin_inset Quotes erd
\end_inset

, che effettua la verifica della presenza di un certo identificatore all'interno
 del DOM
\begin_inset Foot
status open

\begin_layout Plain Layout
Non è possibile attualmente definire una condizione che verifichi l'esistenza
 di un selettore all'interno di un particolare elemento del DOM.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
La classe 
\begin_inset Quotes eld
\end_inset

ExpectedConditions
\begin_inset Quotes erd
\end_inset

 include diversi metodi per esprimere le attese esplicite in funzione di
 diverse condizioni, dalle più semplici che verificano la presenza di un
 elemento o di una stringa, fino all'attesa per una finestra di dialogo
 o elemento cliccabile.
\end_layout

\begin_layout Subsection
Scenari sull'auto-completamento con JQuery UI
\end_layout

\begin_layout Standard
Rispetto alla risoluzione della funzione Javascript della precedente funzionalit
à, come già descritto per RBlog, l'utilizzo di un widget di JQuery UI, che
 sfrutta anche una chiamata AJAX, rappresenta un sensibile incremento di
 tempi di esecuzione, suddiviso fra tempo di completamente della richiesta
 HTTP, completamento delle operazioni con JQuery e visualizzazione del component
e grafico nel browser web.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Autocompletamento della ricerca
\end_layout

\begin_layout Plain Layout

	Dato nell'intestazione è presente la barra di ricerca
\end_layout

\begin_layout Plain Layout

	Dato il post "Lorem Ipsum" esiste
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "lor" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora viene proposto il post "Lorem Ipsum"
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "xyz" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora non è proposto alcun post
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Scenario riguardante l'auto-completamento della ricerca.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All'interno dell'implementazione del passo è utilizzato nuovamente un metodo
 per l'attesa esplicita e la verifica della visibilità all'interno della
 pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Allora("^viene proposto il post 
\backslash
"(.*?)
\backslash
"$") public void viene_proposto_il_post(String postTitle) {
\end_layout

\begin_layout Plain Layout

	String xpathExpression = String.format("//li[@class = 'ui-menu-item']",
 postTitle);
\end_layout

\begin_layout Plain Layout

	List<WebElement> lis = new WebDriverWait(driver, 4).until(ExpectedConditions.pres
enceOfAllElementsLocatedBy(By.xpath(xpathExpression)));
\end_layout

\begin_layout Plain Layout

	boolean isPostProposed = false;
\end_layout

\begin_layout Plain Layout

	for (WebElement li : lis) { 		isPostProposed |= li.getText().equals(postTitle)
 &&  li.isDisplayed();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	assertTrue(isPostProposed);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Verifica dei titoli suggeriti.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

presenceOfAllElementsLocatedBy
\begin_inset Quotes erd
\end_inset

 restituisce una collezione di elementi identificati dal selettore, descritto
 tramite un'espressione XPath.
 Il metodo attende entro il tempo massimo fissato fino a che almeno un elemento
 non appare nella pagina.
\end_layout

\begin_layout Standard
L'implementazione del menu di auto-completamento di JQuery prevede che la
 collezione degli elementi che costituiscono i suggerimenti sia definita
 a priori.
 Al contrario, se il widget prevedesse la popolazione del menu dinamicamente
 scorrendo nella lista, sarebbe necessario invocare più volte il metodo
 
\begin_inset Quotes eld
\end_inset

presenceOfAllElementsLocatedBy
\begin_inset Quotes erd
\end_inset

 non risulterebbe attendibile per verificare la presenza di nuove entry.
\end_layout

\begin_layout Standard
Ottenuti gli elementi, durante le iterazioni del ciclo for, è verificata
 la corrispondenza fra il testo del suggerimento e il titolo passato come
 parametro, e l'effettiva visualizzazione dell'elemento nel browser.
\end_layout

\end_body
\end_document
