#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\use_default_options true
\master ../Relazione.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Spring 13/11/14
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:spring"

\end_inset


\end_layout

\begin_layout Section
ASP.NET MVC 5
\end_layout

\begin_layout Standard
In questo capitolo è trattato lo sviluppo di CSBlog, un'applicazione web
 sviluppata tramite il framework ASP.NET MVC 5 e implementando la libreria
 di test di accettazione già mostrata nei precedenti capitoli utilizzando
 Specflow, una libreria per il BDD ispirata a Cucumber, e Coypu per automatizzar
e la navigazione del browser web.
\end_layout

\begin_layout Standard
In questo capitolo saranno descritte le particolarità del framework, dell'implem
entazione delle diverse componenti e degli strumenti utilizzati per implementare
 l'applicazione web.
 Dalla sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-CSBlog!"

\end_inset

 sono documentate le diverse funzionalità presenti nella libreria dei test
 di accettazione e descritto il processo di testing, includendo esempi e
 frammenti di codice.
\end_layout

\begin_layout Subsection
Visual Studio 2013
\end_layout

\begin_layout Standard
Per lo sviluppo di CSBlog, dei test di accettazione e la gestione del modello
 è stato utilizzato Visual Studio 2013 Ultimate, VS, che integra le diverse
 funzionalità per lo sviluppo web, la configurazione della propria applicazione
 e l'implementazione delle diverse componenti del pattern.
\end_layout

\begin_layout Standard
Tutti i plugin necessari, per il supporto a Specflow o l'installazione di
 PhantomJS, sono stati installati tramite NuGet, il gestore di pacchetti
 per il mondo .NET direttamente tramite l'ambiente di sviluppo.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:L'interpretazione di Spring del pattern MVC"

\end_inset

L'interpretazione di
\end_layout

\begin_layout Subsection
Il modello
\end_layout

\begin_layout Standard
Per definire il modello con RoR e Spring è stato scelto di definire prima
 le entità, rispettivamente tramite gli ActiveRecord e JPA, ed utilizzare
 le classi per effettuare la generazione dei database su PostgreSql.
 RoR genera di default tre database e le tabelle delle migrazioni, ed anche
 JPA implementa ad alto livello molte funzionalità dei database relazioni,
 come i vincoli di integrità.
 E' quindi molto conveniente per lo sviluppatore progettare la persistenza
 partendo dalle classi che rappresentano il dominio.
\end_layout

\begin_layout Standard
Per MVC5 è stato scelto invece di definire il modello in maniera 
\begin_inset Quotes eld
\end_inset

classica
\begin_inset Quotes erd
\end_inset

 utilizzando il DDL di SQL, utilizzando SQL Server Express, la versione
 gratuita del database sviluppato da Microsoft.
 Utilizzando la generazione guidata e gli strumenti grafici per la gestione
 dei database, la creazione delle tabelle 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

Autore
\begin_inset Quotes erd
\end_inset

 e la relazione presente fra le due entità, è stata compiuta in breve tempo.
\end_layout

\begin_layout Subsubsection*
Entity Framework
\end_layout

\begin_layout Standard
La definizione dell'interfaccia del modello per un'applicazione web di MVC5
 non è una scelta vincolata ed è possibile individuare diverse opzioni.
 Per CSBlog è stato scelto l'Entity Framework, attualmente alla versione
 6, che implementa l'astrazione del modello attraverso la tecnica ORM in
 maniera simile a quanto già visto per RoR e Spring.
\end_layout

\begin_layout Standard
L'Entity Framework rappresenta l'interfaccia del modello definito per CSBlog
 e si integra con ADO.NET, il framework responstabile per l'interazione con
 i sistemi di persistenza esistenti e del mantenimento della consistenza
 fra le entry e gli oggetti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le classi che descrivono le entità sono estendono 
\begin_inset Quotes eld
\end_inset

DbContext
\begin_inset Quotes erd
\end_inset

, che fornisce le funzionalità per applicare la tecnica ORM, permettendo
 di eseguire interrogazioni, di tener traccia dei cambiamenti allo stato
 delle istanze ed invocare le operazioni di creazione, aggiornamento e cancellaz
ione.
 Visual Studio include un wizard per la configurazione del modello, che
 provvede a definire la connessione al database, a generare le classi parziali
\begin_inset Foot
status open

\begin_layout Plain Layout
Una classe parziale in C# rappresenta una parte di una classe intera.
 La definizione completa è suddivisa in più fine che saranno unite a tempo
 di compilazione.
\end_layout

\end_inset

 rappresentanti le entità e a configurare le risorse necessarie per il funzionam
ento dell'EF.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public partial class CSBlogEntities : DbContext{
\end_layout

\begin_layout Plain Layout

	public CSBlogEntities() : base("name=CSBlogEntities"){}         	protected
 override void OnModelCreating(DbModelBuilder modelBuilder){
\end_layout

\begin_layout Plain Layout

		throw new UnintentionalCodeFirstException();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Author> Authors { get; set; }
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Post> Posts { get; set; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Il contesto di CSBlog generato da VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le proprietà 
\begin_inset Quotes eld
\end_inset

Authors
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Posts
\begin_inset Quotes erd
\end_inset

 rappresentano le entità presenti nel database e sono utilizzate dall'EF
 per effettuare le query.
 Per implementare le interrogazioni necessarie per CSBlog è stato utilizzato
 LINQ, Language-Integrated Query.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

var postTitles = db.Posts.Select(p => p.title).ToList();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Proiezione dei titoli dei post in CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
LINQ permette di definire le proprie query attraverso un insieme di metodi
 che rispecchiano le funzionalità di SQL e permettono di utilizzare il paradigma
 ad oggetti, ad esempio nell'operazione di proiezione dell'esempio precedente
 per ottenere i titoli dei post esistenti è stato effettuato un'accesso
 all'attributo 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

 dell'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
 Utilizzando una libreria che fornisce una tale astrazione del modello e
 delle entità è possibile definire le proprie interrogazioni sfruttando
 tutte le funzionalità esistenti per C# in VS, come l'auto-completamento
 e l'evidenziatura dei diversi elementi sintattici.
 Inoltre LINQ definisce query utilizzando metodi generici che permettono
 di verificare a compile-time il corretto utilizzo delle entità e degli
 attributi presenti nelle interrogazioni.
\begin_inset Newline newline
\end_inset

In maniera simile all'interfaccia per la definizione delle query con gli
 Active Record di RoR, lo sviluppatore può sfruttare l'astrazione introdotta
 dall'uso dell'EF e definire le proprie query in maniera veloce ed intuitiva.
 Rispetto però alla controparte in Ruby, LINQ è più completo permettendo
 la definizione di interrogazioni anche su altri sistemi per la persistenza,
 come documenti XML, ed anche su collezioni di tipo 
\begin_inset Quotes eld
\end_inset

IEnumerable
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La semplice query di proiezione dell'esempio è suddivisibile in tre elementi:
 l'ottenimento del contesto tramite le classi dell'EF, rappresentato dall'oggett
o 
\begin_inset Quotes eld
\end_inset

db
\begin_inset Quotes erd
\end_inset

, per specificare quale sia l'entità utilizzata nell'interrogazione, la
 specifica delle operazioni, come il metodo 
\begin_inset Quotes eld
\end_inset

Select
\begin_inset Quotes erd
\end_inset

, e l'esecuzione che coincide con l'invocazione del metodo 
\begin_inset Quotes eld
\end_inset

ToList
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
In generale ogni invocazione che comporta un accesso esplicito agli oggetti
 coincide con l'esecuzione della query.
 Ad esempio utilizzando il metodo 
\begin_inset Quotes eld
\end_inset

ToList
\begin_inset Quotes erd
\end_inset

, le funzionalità di LINQ 
\begin_inset Quotes eld
\end_inset

First
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

Any
\begin_inset Quotes erd
\end_inset

 o l'iterazione tramite il costrutto 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
 L'oggetto 
\begin_inset Quotes eld
\end_inset

postTitles
\begin_inset Quotes erd
\end_inset

 ha tipo IQueryable, interfaccia generica sul tipo dell'interrogazione,
 che estende IEnumerable e dichiara le funzionalità per compiere la valutazione
 della query.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre alla generazione dell'interfaccia del modello, VS include un browser
 del modello che rappresenta la struttura delle entità esistenti e le relazioni
 che intercorrono fra loro.
 Direttamente nell'ambiente di sviluppo è possibile visualizzare e aggiornare
 la struttura del modello, sincronizzando gli schemi dei database utilizzati,
 ed anche gestire associazioni e relazioni di ereditarietà.
\end_layout

\begin_layout Subsection
I controlli
\end_layout

\begin_layout Standard
Come per la definizione del modello, anche per i controlli e le relative
 azioni, sono stati utilizzati gli strumenti di VS per la generazione automatica
 delle componenti.
 Il wizard per la configurazione è ben strutturato e permette di indicare
 quali azioni sia necessario generare, ad esempio è possibile creare un
 controllo contenente le operazioni CRUD oppure vuoto, e se utilizzare l'EF
 per associare il nuovo controllo ad una delle entità e generare dei metodi
 opportunamente connessi al modello.
\end_layout

\begin_layout Standard
Durante il processo di configurazione del nuovo controllo è anche generato
 insieme di viste corrispondenti alle azioni create.
 In maniera simile a RubyMine, gli strumenti dell'ambiente di sviluppo facilitan
o lo sviluppo fornendo una struttura esistente per le nuove applicazioni
 e preziose indicazioni sulla struttura del framework e di come le componenti
 interagiscano fra loro.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per semplificare la risoluzione delle richieste HTTP all'applicazione, MVC5
 definisce un file 
\begin_inset Quotes eld
\end_inset

RouteConfig.cs
\begin_inset Quotes erd
\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

AppData
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    public class RouteConfig     {         public static void RegisterRoutes(Rou
teCollection routes)         {             /*...*/            routes.MapRoute(
                 name: "Default",                 url: "{controller}/{action}/{i
d}",                 defaults: new { controller = "Post", action = "Index",
 id = UrlParameter.Optional }             );         }     }
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Definizione del pattern per la risoluzione delle richieste.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

RegisterRoutes
\begin_inset Quotes erd
\end_inset

 si occupa di registrare la convenzione scelta per la risoluzione delle
 richieste effettuate dagli utenti.
 Come si può osservare dal metodo, anche per CSBlog l'applicazione rispecchia
 l'organizzazione di un'architettura REST: ad esempio l'URL relativo 
\begin_inset Quotes eld
\end_inset

/Post/Create/
\begin_inset Quotes erd
\end_inset

 è suddiviso in due elementi, il nome del controllo e l'azione corrispondente.
 Inoltre è specificato quale sia l'homepage tramite il parametro 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

namespace Blog.Controllers {     public class PostController : Controller
     {
\end_layout

\begin_layout Plain Layout

        private CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

       public ActionResult Details(Guid? id)         {             if (id
 == null)             {                 return new HttpStatusCodeResult(HttpStat
usCode.BadRequest);             }             Post post = db.Posts.Find(id);
             if (post == null)             {                 return HttpNotFound
();             }             return View(post);         }
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Visualizzazione di un singolo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per implementare un nuovo controllo, è sufficiente creare una nuova classe
 pubblica all'interno del namespace del progetto ed estendere la classe
 astratta 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

.
 Nel frammento della classe 
\begin_inset Quotes eld
\end_inset

PostController
\begin_inset Quotes erd
\end_inset

 è mostrata l'implementazione di una singola azione che, in funzione del
 parametro 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 carica tramite LINQ ed EF l'entità corrispondente e restituisce un riferimento
 alla vista 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

.
 Come in RoR per ogni azione, se non specificato diversamente, è prevista
 una vista con ugual nome, in particolare, dopo aver individuato il corretto
 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 all'interno del modello, il server web fornirà all'utente la vista corrisponden
te al file 
\begin_inset Quotes eld
\end_inset

Views/Details.cshtml
\begin_inset Quotes erd
\end_inset

.
 L'azione 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

 accetta richieste HTTP di qualsiasi tipo, per applicare delle limitazioni
 è sufficiente annotare il metodo con attributi come 
\begin_inset Quotes eld
\end_inset

HttpGet
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

HttpPost
\begin_inset Quotes erd
\end_inset

 presenti in MVC5.
\end_layout

\begin_layout Standard
Il tipo 
\begin_inset Quotes eld
\end_inset

ActionResult
\begin_inset Quotes erd
\end_inset

 utilizzato come risultato dell'azione ha il compito di incapsulare il risultato
 e permettere al framework fornire una risposta, nel frammento il metodo
 
\begin_inset Quotes eld
\end_inset

View
\begin_inset Quotes erd
\end_inset

 della classe padre 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

 istanzia un'oggetto 
\begin_inset Quotes eld
\end_inset

ViewResult
\begin_inset Quotes erd
\end_inset

 che specifica la vista da renderizzare.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Rispetto a Spring e RoR, non è prevista all'interno dell'architettura una
 componente con il ruolo di disaccoppiare i controlli dalla logica per l'accesso
 al modello, sta quindi all'utente introdurre il pattern che meglio si presta
 allo scopo ed implementarlo.
\end_layout

\begin_layout Subsection
Le viste
\end_layout

\begin_layout Standard
Per l'implementazione delle viste di CSBlog è stato utilizzato Razor, un
 linguaggio ASP.NET per l'implementazione di pagine dinamiche che introduce
 una sintassi basata sul C# ed integrata in VS tramite, ad esempio è previsto
 l'IntelliSense e la possibilità di creare nuove pagine sfruttando i wizard
 presenti nell'ambiente di sviluppo.
\end_layout

\begin_layout Standard
Razor rappresenta la scelta di default per lo sviluppo di una nuova applicazione
 web, introdotto dalla versione 4 del framework, introduce una sintassi
 per ottimizzare la generazione di pagine HTML, definenendo un insieme di
 costrutti per permettere allo sviluppatore di distinguere facilmente le
 porzioni di codice dinamico.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{     var helloRazor = "Benvenuto su CSBlog!";     var weekDay = DateTime.Now.Day
OfWeek;     var greetingMessage = greeting + " Oggi è: " + weekDay; } <p>@helloR
azor</p>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Hello Razor!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il design delle istruzioni è essenziale ed è paragonabile ad ERB, sono infatti
 presenti anche in Razor dei dei delimitatori per includere all'interno
 delle viste codice.
 Nel frammento d'esempio è introdotto un blocco contente istruzioni C#,
 che utilizzano le librerie di sistema, all'interno del quale è creato un
 messaggio di benvenuto.
 Tramite la notazione 
\begin_inset Quotes eld
\end_inset

@variabile
\begin_inset Quotes erd
\end_inset

 è possibile accedere utilizzare all'interno della struttura del documento
 per utilizzare l'espressione concatenata nel blocco.
\end_layout

\begin_layout Standard
La distinzione fra la sintassi 
\begin_inset Quotes eld
\end_inset

@{...}
\begin_inset Quotes erd
\end_inset

 e l'operatore 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

 che permette di accedere ai valori e di utilizzarne le espressioni per
 generare le viste dinamiche, permette di dichiarare viste in cui sono distinte
 in maniera chiara le porzioni di codice che includono l'implementazione
 della logica dalle istruzioni che esclusivamente utilizzano le funzionalità
 in lettura.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ul> @for (int i = 0; i < 10; i++) { <li>@i</li> } </ul>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Il ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 in Razor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La sintassi di Razor include anche i più comuni costrutti sintattici, nell'esemp
io è mostrato l'utilizzo di un ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 le cui iterazioni generano nuovi elementi della lista 
\begin_inset Quotes eld
\end_inset

ul
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'organizzazione e le convenzioni utilizzate da MVC5 semplifica la definizione
 dell'intera applicazione, ed anche per la definizione delle viste è previsto
 un meccanismo per fattorizzare al meglio il proprio codice.
\end_layout

\begin_layout Standard
Per ogni vista da processare e visualizzare in risposta ad una richiesta
 HTTP, viene ricercato il file 
\begin_inset Quotes eld
\end_inset

_ViewStart.cshtml
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

cshtml
\begin_inset Quotes erd
\end_inset

 è l'estensione delle viste in Razor.
\end_layout

\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

Views
\begin_inset Quotes erd
\end_inset

.
 Per CSBlog è stato utilizzata per indicare quale sia il file Razor contenente
 il layout delle pagine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{     Layout = "~/Views/Shared/_Layout.cshtml"; }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A differenza delle altre piattaforme, anche la scelta del layout può essere
 effettuata dinamicamente, permettendo di aver maggior controllo sull'aspetto
 delle proprie pagine semplicemente cambiando il percorso della risorsa
 o aggiungendo della logica all'assegnazione.
 Ad esempio è possibile definire più versioni del proprio sito, ottimizzandone
 l'uso in funzione del tipo di device che sta effettuando la navigazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<!DOCTYPE html> <html xmlns:th="http://www.thymeleaf.org"> @Html.Partial("_HeadPart
ial") <body>     @Html.Partial("_HeaderPartial")     <div id="content"> 
        @RenderBody()     </div>     @Html.Partial("_FooterPartial")    
  </body> </html>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per definire un layout è sufficiente creare una nuova vista con Razor ed
 utilizzare funzionalità come 
\begin_inset Quotes eld
\end_inset

Partial
\begin_inset Quotes erd
\end_inset

, per espandere il contenuto di una vista parziale, o 
\begin_inset Quotes eld
\end_inset

RenderBody
\begin_inset Quotes erd
\end_inset

 per espandere la vista restituita dall'azione che ha gestito la richiesta.
 Nell'esempio è mostrato com'è costituita la struttura di una pagina di
 CSBlog.
\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
Visual Studio, ASP.NET e l'EF sono software estremamente ampi, ricchi di
 funzionalità e professionali ma la creazione di una nuova applicazione
 per MVC5 definisce un progetto nel quale sono utilizzate la maggior parte
 delle componenti presenti nel framework.
 Navigando fra i sorgenti del progetto è possibile approfondirne le funzionalità
, intuirne le potenzialità e osservare le soluzioni proposte dal team di
 VS.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre ad includere un esempio di applicazione funzionante per ogni nuovo
 progetto, VS fornisce agli sviluppatori numerosi wizard per generare e
 configurare le nuove funzionalità.
 Durante il progetto non è mai stato necessario modificare manualmente i
 file XML per la configurazione dell'applicazione e l'introduzione di nuovi
 controlli, viste o entità non ha richiesto uno studio approfondito del
 framework per una singola funzionalità, come ad esempio per la definizione
 del modello con JPA.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Inoltre VS integra all'interno dell'ambiente di sviluppo tutte le diverse
 categorie di strumenti e linguaggi necessari per lo sviluppo di un'applicazione
 web.
 Oltre ai classici HTML, CSS e Javascript, è supportato di default lo sviluppo
 tramite Sass e Boostrap
\begin_inset Foot
status open

\begin_layout Plain Layout
Bootstrap è un'interessante framework, sviluppato originariamente da Twitter,
 per la definizione di pagine web responsive.
 E' particolarmente apprezzato per la definizione di siti facilmente navigabili
 da device mobile in quanto non prevede l'utilizzo di fogli di stile per
 definire la disposizione degli elementi nella pagina.
\end_layout

\end_inset

, tecnologie innovative per lo sviluppo di applicazioni Web.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-CSBlog!"

\end_inset

Hello CSBlog!
\end_layout

\begin_layout Standard
Nella sezione sono introdotti gli strumenti per effettuare la definizione
 dei test di accettazione automatici per CSBlog.
 Nella prima parte è descritto il processo di configurazione di Coypu, la
 libreria per l'automazione scelta per .NET, e di SpecFlow, il framework
 per il BDD.
 Successivamente sono introdotti i primi test e le funzionalità utilizzate
 per l'implementazione.
\end_layout

\begin_layout Subsection
SpecFlow
\end_layout

\begin_layout Standard
SpecFlow è un framework per .NET.
 Nonostante utilizzi Gherkin, non è un porting di Cucumber in C#, al momento
 esistono le versioni Java, Ruby e JavaScript, bensì si limita ad utilizzarne
 alcune componenti come il DSL e il relativo parser, entrambe presenti pubblicam
ente su GitHub.
\end_layout

\begin_layout Paragraph
Le funzionalità
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La prima feature di SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Grazie all'utilizzo di SpecFlow è possibile riutilizzare la stessa libreria
 utilizzata per lo sviluppo di RBlog e SBlog.
 Nell'importazione e nello sviluppo dei post non sono state rilevate problemi
 legati al linguaggio ed alle costrutti sintattici utilizzati, sono però
 presenti delle differenze nell'implementazione, come verrà descritto nelle
 successive sezioni.
\end_layout

\begin_layout Paragraph
Supporto a Specflow in VS
\end_layout

\begin_layout Standard
Per utilizzare SpecFlow in VS è sufficiente installare tramite il gestore
 dei pacchetti il relativo plugin.
 Per eseguire le funzionalità e gli scenari tramite il runner di NUnit è
 necessario installare un pacchetto aggiuntivo tramite la console di NuGet,
 utilizzando il comando seguente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Install-Package SpecFlow.NUnit
\begin_inset Caption Standard

\begin_layout Plain Layout

Installazione del plugin per SpecFlow in VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Completate l'installazione del software non è necessario compiere alcuna
 operazione di configurazione.
 Il plugin estende il funzionamento di VS aggiungendo il completo supporto
 a Gherkin, evidenziando la sintassi nelle diverse lingue esistenti, introducend
o l'autocompletamento all'interno dei file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, permettendo la navigazione da passo ad implementazione, permettendo la
 generazione automatica degli stub rappresentanti i passi e aggiungendo
 le funzionalità in Gherkin nei menù rapidi per la creazione delle risorse.
\end_layout

\begin_layout Standard
Per l'esecuzione delle funzionalità è possibile selezionare direttamente
 i file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, eventualmente utilizzando il tag 
\begin_inset Quotes eld
\end_inset

@ignore
\begin_inset Quotes erd
\end_inset

 per saltare alcuni scenari, oppure sfruttare l'integrazione con NUnit per
 eseguire scegliere quale sotto-insieme di scenari eseguire.
 E' anche possibile sfruttare i diversi ordinamenti di NUnit per eseguire
 gli scenari in funzione di durata di esecuzione, risultato del test, tag
 utilizzati o namespace.
\end_layout

\begin_layout Subsection
Coypu
\end_layout

\begin_layout Standard
I parametri della scelta di una libreria per l'automazione della navigazione
 via browser prevede che questa sia preferibilmente scritta nel linguaggio
 utilizzato per implementare l'applicazione web, il cui sviluppo sia attivo,
 che possibilmente sia open-source e che abbia una comunità attiva per poter
 avere un riscontro in caso di difficoltà e problemi.
\end_layout

\begin_layout Standard
L'individuazione di una libreria per .NET che soddisfasse questi parametri
 non è stato semplice.
 Oltre a Selenium, già utilizzato per Java, sono stati valutati Watin, il
 cui sviluppo è fermo dal 2011, e Telerick Testing Framework, che per quanto
 sia un progetto attivo e ben documentato, sembra non essere utilizzato
 ed essere privo di una propria comunità di utilizzatori.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Viste le diverse difficoltà nella scelta di una libreria è stata effettuata
 una scelta sperimentale utilizzando Coypu, un wrapper di Selenium Web Driver,
 scritto in C# che nella propria implementazione si ispira al DSL di Capybara.
\end_layout

\begin_layout Standard
Il progetto è stato rilasciato la prima volta 2011, 2 anni prima del rilascio
 della prima versione beta di Selenium 2.0 ed è attualmente sviluppato, anche
 se il supporto è principalmente effettuato dal un singolo autore.
 Nonostante si tratti di una libreria open-source utilizzata da una ridotta
 comunità, che comunque è attiva e presente in diversi canali, presenta
 un'interessante prospettiva dell'automazione della navigazione web che
 merita di essere approfondita.
\end_layout

\begin_layout Standard
I principali obbiettivi di Coypu riguardano la semplificazione e razionalizzazio
ne delle funzionalità della libreria di Selenium e la definizione di una
 libreria che, come Capybara, permetta di descrivere i propri test nella
 maniera più vicina possibile a come un utente descriverebbe le proprie
 azioni sul browser.
\end_layout

\begin_layout Subsubsection*
Configurazione di una sessione di testing
\end_layout

\begin_layout Standard
Come effettuato per Selenium in SBlog, anche per Coypu è stato scelto di
 utilizzare un nuovo ambiente di testing per ogni scenario, aprendo una
 nuova finestra prima prima dell'esecuzione e rilasciando le risorse al
 termine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[BeforeScenario]
\end_layout

\begin_layout Plain Layout

public void Before(){
\end_layout

\begin_layout Plain Layout

	var sessionConfiguration = new SessionConfiguration             	{
\end_layout

\begin_layout Plain Layout

		Port = 1448,
\end_layout

\begin_layout Plain Layout

		Driver = typeof(SeleniumWebDriver),
\end_layout

\begin_layout Plain Layout

		Browser = Coypu.Drivers.Browser.PhantomJS,
\end_layout

\begin_layout Plain Layout

		Timeout = TimeSpan.FromSeconds(5)
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	_browser = new BrowserSession(sessionConfiguration);            	_browser.Maximi
seWindow();             	_objectContainer.RegisterInstanceAs(_browser);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout

Creazione della sessione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche in SpecFlow è possibile definire delle callback, nell'esempio è definito
 un hook 
\begin_inset Quotes eld
\end_inset

BeforeScenario
\begin_inset Quotes erd
\end_inset

 da eseguire prima di ogni scenario, contenente le istruzioni per la definizione
 di una sessione.
 In particolare tramite la classe 
\begin_inset Quotes eld
\end_inset

SessionConfigurazion
\begin_inset Quotes erd
\end_inset

 è impostata la porta del server web, il driver ed il browser utilizzato
 ed il tempo massimo di esecuzione di ricerca per un selettore all'interno
 della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AfterScenario]
\end_layout

\begin_layout Plain Layout

public void AfterScenario(){
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	_browser.Dispose();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Chiusura del browser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per completare la gestione della sessione di testing è invocato il metodo
 dispone al termine di ogni scenario.
\end_layout

\begin_layout Subsubsection*
PhantomJS
\end_layout

\begin_layout Standard
Per utilizzare PhantomJS per come browser, è necessario mantenere l'eseguibile
 all'interno del path del proprio sistema o all'interno della cartella 
\begin_inset Quotes eld
\end_inset

bin
\begin_inset Quotes erd
\end_inset

 del progetto in VS.
 Per installare il browser localmente è possibile utilizzare la console
 di Nuget ed eseguire il seguente comando.
\end_layout

\begin_layout Standard
install-package phantomjs.exe
\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@Dato("^apro SBlog$")
\end_layout

\begin_layout Plain Layout

public void apro_SBlog() {
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro SBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro SBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dipendenza tipo passo con implementazione, più annotazioni
\end_layout

\begin_layout Paragraph
La struttura di Coypu
\end_layout

\begin_layout Standard
struttura
\end_layout

\begin_layout Paragraph
Navigare all'interno del sito
\end_layout

\begin_layout Standard
timeout globale
\end_layout

\begin_layout Paragraph
Integrazione con NUnit
\end_layout

\begin_layout Standard
Matcher
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Feature: Introducendo il CSS
\end_layout

\begin_layout Plain Layout

Per rendere l'esperienza di navigazione gradevole
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che il sito esponesse una grafica omogenea
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:02x00 Introducendo il CSS"

\end_inset

Seconda funzionalità per SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
possibilità di usare funzionalità native
\end_layout

\begin_layout Standard
esempio
\end_layout

\begin_layout Standard
menne
\end_layout

\begin_layout Subsection
Testare il css
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: l'intestazione espone dei semplici effetti cromatici
\end_layout

\begin_layout Plain Layout

	Dato che è presente l'intestazione
\end_layout

\begin_layout Plain Layout

	E l'intestazione permette la navigazione
\end_layout

\begin_layout Plain Layout

	E i collegamenti non hanno sfondo
\end_layout

\begin_layout Plain Layout

	Quando il cursore si sposta sui collegamenti
\end_layout

\begin_layout Plain Layout

	Allora lo sfondo del collegamento cambia
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Variazione del colore del colore di background dei collegamenti nell'intestazion
e.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Actions
\end_layout

\begin_layout Subsubsection*
Selettori
\end_layout

\begin_layout Subsection
Debug con Specflow
\end_layout

\begin_layout Standard
problemi deploy
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Gestione dei post
\end_layout

\begin_layout Plain Layout

	Come Autore
\end_layout

\begin_layout Plain Layout

	Vorrei poter inserire, leggere, modificare e rimuovere dei post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter documentare la tesi
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:03x00 Modello"

\end_inset

Funzionalità dell'iterazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dipendenze
\end_layout

\begin_layout Paragraph
Hooks
\end_layout

\begin_layout Subsection
Gestione dei form
\end_layout

\begin_layout Subsubsection*
Verificare gli errori
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Login & Autorizzazione
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Asincronia
\end_layout

\begin_layout Subsection
JavaScript
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Easter Egging
\end_layout

\begin_layout Plain Layout

	Come Sviluppatore
\end_layout

\begin_layout Plain Layout

	Vorrei che nel blog fosse presente un mio logo
\end_layout

\begin_layout Plain Layout

	Per firmare il mio lavoro
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:05bx00 EasterEgg"

\end_inset

Introduzione di un breve script Javascript.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scenari sull'auto-completamento con JQuery UI
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Autocompletamento della ricerca
\end_layout

\begin_layout Plain Layout

	Dato nell'intestazione è presente la barra di ricerca
\end_layout

\begin_layout Plain Layout

	Dato il post "Lorem Ipsum" esiste
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "lor" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora viene proposto il post "Lorem Ipsum"
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "xyz" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora non è proposto alcun post
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario riguardante l'auto-completamento della ricerca.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
