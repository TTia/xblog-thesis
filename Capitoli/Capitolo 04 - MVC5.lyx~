#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\use_default_options true
\master ../Relazione.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
MVC 5 17/11/14
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ch:spring"

\end_inset


\end_layout

\begin_layout Section
ASP.NET MVC 5
\end_layout

\begin_layout Standard
In questo capitolo è trattato lo sviluppo di CSBlog, un'applicazione web
 sviluppata tramite il framework ASP.NET MVC 5 e implementando la libreria
 di test di accettazione già mostrata nei precedenti capitoli utilizzando
 Specflow, una libreria per il BDD ispirata a Cucumber, e Coypu per automatizzar
e la navigazione del browser web.
\end_layout

\begin_layout Standard
In questo capitolo saranno descritte le particolarità del framework, dell'implem
entazione delle diverse componenti e degli strumenti utilizzati per implementare
 l'applicazione web.
 Dalla sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-CSBlog!"

\end_inset

 sono documentate le diverse funzionalità presenti nella libreria dei test
 di accettazione e descritto il processo di testing, includendo esempi e
 frammenti di codice.
\end_layout

\begin_layout Subsection
Visual Studio 2013
\end_layout

\begin_layout Standard
Per lo sviluppo di CSBlog, dei test di accettazione e la gestione del modello
 è stato utilizzato Visual Studio 2013 Ultimate, VS, che integra le diverse
 funzionalità per lo sviluppo web, la configurazione della propria applicazione
 e l'implementazione delle diverse componenti del pattern.
\end_layout

\begin_layout Standard
Tutti i plugin necessari, per il supporto a Specflow o l'installazione di
 PhantomJS, sono stati installati tramite NuGet, il gestore di pacchetti
 per il mondo .NET direttamente tramite l'ambiente di sviluppo.
 VS è un ambiente di sviluppo con enormi potenzialità, articolato e complesso,
 nel corso delle prossime sezioni sono descritte le funzionalità utilizzate
 per la definizione del progetto e dei test.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:L'interpretazione di MVC5"

\end_inset

L'interpretazione di ASP.NET del pattern MVC
\end_layout

\begin_layout Standard
Nelle prossime sezioni è descritto il processo di definizione dell'architettura
 di CSBlog, caratterizzato da un uso costante degli strumenti di VS per
 la definizione delle varie componenti.
 Al termine della sezione risulterà evidente come, nonostante il framework
 MVC5 e l'intero progetto ASP.NET sia estremamente articolato, lo sviluppo
 non risente delle grandi potenzialità messe a disposizione.
\end_layout

\begin_layout Subsection
Il modello
\end_layout

\begin_layout Standard
Per definire il modello con RoR e Spring è stato scelto di definire prima
 le entità, rispettivamente tramite gli ActiveRecord e JPA, ed utilizzare
 le classi per effettuare la generazione dei database su PostgreSql.
 RoR genera di default tre database e le tabelle delle migrazioni, ed anche
 JPA implementa ad alto livello molte funzionalità dei database relazioni,
 come i vincoli di integrità.
 E' quindi molto conveniente per lo sviluppatore progettare la persistenza
 partendo dalle classi che rappresentano il dominio.
\end_layout

\begin_layout Standard
Per MVC5 è stato scelto invece di definire il modello in maniera 
\begin_inset Quotes eld
\end_inset

classica
\begin_inset Quotes erd
\end_inset

 utilizzando il DDL di SQL, utilizzando SQL Server Express la versione gratuita
 del database sviluppato da Microsoft, la generazione guidata e gli strumenti
 grafici per la gestione dei database che hanno permesso la creazione delle
 tabelle 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

Autore
\begin_inset Quotes erd
\end_inset

 e della relazione presente fra le due entità in breve tempo.
\end_layout

\begin_layout Subsubsection*
Entity Framework
\end_layout

\begin_layout Standard
Per implementare l'interfaccia del modello di MVC5 è stato scelto l'Entity
 Framework, attualmente alla versione 6, che implementa l'astrazione del
 modello attraverso la tecnica ORM in maniera simile a quanto già visto
 per RoR e Spring.
 Il framework si integra con ADO.NET, responstabile dell'interazione con
 i sistemi di persistenza esistenti e del mantenimento della consistenza
 fra le entry e gli oggetti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Le classi che descrivono le entità dell'EF estendono 
\begin_inset Quotes eld
\end_inset

DbContext
\begin_inset Quotes erd
\end_inset

, che fornisce le funzionalità per eseguire interrogazioni, tener traccia
 dei cambiamenti allo stato delle istanze ed invocare le operazioni di creazione
, aggiornamento e cancellazione.
 Visual Studio include un wizard per la configurazione del modello, che
 provvede a definire la connessione al database, a generare le classi parziali
\begin_inset Foot
status open

\begin_layout Plain Layout
Una classe parziale in C# rappresenta una parte di una classe intera.
 La definizione completa è suddivisa in più fine che saranno unite a tempo
 di compilazione.
\end_layout

\end_inset

 rappresentanti le entità e a configurare le risorse necessarie per il funzionam
ento dell'EF.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public partial class CSBlogEntities : DbContext{
\end_layout

\begin_layout Plain Layout

	public CSBlogEntities() : base("name=CSBlogEntities"){}         	protected
 override void OnModelCreating(DbModelBuilder modelBuilder){
\end_layout

\begin_layout Plain Layout

		throw new UnintentionalCodeFirstException();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Author> Authors { get; set; }
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Post> Posts { get; set; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Il contesto di CSBlog generato da VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Le proprietà 
\begin_inset Quotes eld
\end_inset

Authors
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Posts
\begin_inset Quotes erd
\end_inset

 rappresentano le entità presenti nel database e sono utilizzate dall'EF
 per effettuare le query.
 Per implementare le interrogazioni necessarie per CSBlog è stato utilizzato
 LINQ, Language-Integrated Query.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

var postTitles = db.Posts.Select(p => p.title).ToList();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Proiezione dei titoli dei post in CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
LINQ permette di definire le proprie query attraverso un insieme di metodi
 che rispecchiano le funzionalità di SQL e permettono di utilizzare il paradigma
 ad oggetti, ad esempio nell'operazione di proiezione dell'esempio precedente
 per ottenere i titoli dei post esistenti è stato effettuato un'accesso
 all'attributo 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

 dell'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
 Utilizzando una libreria che fornisce una tale astrazione del modello e
 delle entità è possibile definire le proprie interrogazioni sfruttando
 tutte le funzionalità esistenti per C# in VS, come l'auto-completamento
 e l'evidenziatura dei diversi elementi sintattici.
 Inoltre LINQ definisce query utilizzando metodi generici che permettono
 di verificare a compile-time il corretto utilizzo delli tipi e degli attributi
 presenti nelle interrogazioni.
\begin_inset Newline newline
\end_inset

In maniera simile all'interfaccia per la definizione delle query con gli
 Active Record di RoR, lo sviluppatore può sfruttare l'astrazione introdotta
 dall'uso dell'EF e definire le proprie query in maniera veloce ed intuitiva.
 Rispetto però alla controparte in Ruby, LINQ è più completo permettendo
 la definizione di interrogazioni anche su altri sistemi per la persistenza,
 come documenti XML, ed anche su collezioni di tipo 
\begin_inset Quotes eld
\end_inset

IEnumerable
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La semplice query di proiezione dell'esempio è suddivisibile in tre elementi:
 l'ottenimento del contesto tramite le classi dell'EF, rappresentato dall'oggett
o 
\begin_inset Quotes eld
\end_inset

db
\begin_inset Quotes erd
\end_inset

, per specificare quale sia l'entità utilizzata nell'interrogazione, la
 specifica delle operazioni, come il metodo 
\begin_inset Quotes eld
\end_inset

Select
\begin_inset Quotes erd
\end_inset

, e l'esecuzione che coincide con l'invocazione del metodo 
\begin_inset Quotes eld
\end_inset

ToList
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
In generale ogni invocazione che comporta un accesso esplicito agli oggetti
 coincide con l'esecuzione della query.
 Ad esempio utilizzando il metodo 
\begin_inset Quotes eld
\end_inset

ToList
\begin_inset Quotes erd
\end_inset

, le funzionalità di LINQ 
\begin_inset Quotes eld
\end_inset

First
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

Any
\begin_inset Quotes erd
\end_inset

 o l'iterazione tramite il costrutto 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

.
 L'oggetto 
\begin_inset Quotes eld
\end_inset

postTitles
\begin_inset Quotes erd
\end_inset

 ha tipo IQueryable, interfaccia generica sul tipo dell'interrogazione,
 che estende IEnumerable e dichiara le funzionalità per compiere la valutazione
 della query.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre alla generazione dell'interfaccia del modello, VS include un browser
 del modello che rappresenta la struttura delle entità esistenti e le relazioni
 che intercorrono fra loro.
 Direttamente nell'ambiente di sviluppo è possibile visualizzare e aggiornare
 la struttura del modello, sincronizzando gli schemi dei database utilizzati,
 ed anche gestire associazioni e relazioni di ereditarietà.
\end_layout

\begin_layout Subsection
I controlli
\end_layout

\begin_layout Standard
Come per la definizione del modello, anche per i controlli e le relative
 azioni, sono stati utilizzati gli strumenti di VS per la generazione automatica
 delle componenti.
 Il wizard per la configurazione è ben strutturato e permette di indicare
 quali azioni sia necessario generare, ad esempio è possibile creare un
 controllo contenente le operazioni CRUD oppure vuoto, e se utilizzare l'EF
 per associare il nuovo controllo ad una delle entità e generare dei metodi
 opportunamente connessi al modello.
\end_layout

\begin_layout Standard
Durante il processo di configurazione del nuovo controllo è anche generato
 insieme di viste corrispondenti alle azioni create.
 In maniera simile a RubyMine, gli strumenti dell'ambiente di sviluppo facilitan
o lo sviluppo fornendo una struttura esistente per le nuove applicazioni
 e preziose indicazioni sulla struttura del framework e di come le componenti
 interagiscano fra loro.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per semplificare la risoluzione delle richieste HTTP all'applicazione, MVC5
 definisce un file 
\begin_inset Quotes eld
\end_inset

RouteConfig.cs
\begin_inset Quotes erd
\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

AppData
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class RouteConfig{
\end_layout

\begin_layout Plain Layout

	public static void RegisterRoutes(RouteCollection routes){
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	routes.MapRoute(
\end_layout

\begin_layout Plain Layout

		name: "Default",
\end_layout

\begin_layout Plain Layout

		url: "{controller}/{action}/{id}",
\end_layout

\begin_layout Plain Layout

		defaults: new {
\end_layout

\begin_layout Plain Layout

			controller = "Post",
\end_layout

\begin_layout Plain Layout

			action = "Index",
\end_layout

\begin_layout Plain Layout

			id = UrlParameter.Optional
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Definizione del pattern per la risoluzione delle richieste.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

RegisterRoutes
\begin_inset Quotes erd
\end_inset

 si occupa di registrare la convenzione scelta per la risoluzione delle
 richieste effettuate dagli utenti.
 Come si può osservare dal metodo, anche per CSBlog l'applicazione rispecchia
 l'organizzazione di un'architettura REST: ad esempio l'URL relativo 
\begin_inset Quotes eld
\end_inset

/Post/Create/
\begin_inset Quotes erd
\end_inset

 è suddiviso in due elementi, il nome del controllo e l'azione corrispondente.
 Inoltre è specificato quale sia l'homepage tramite il parametro 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

namespace Blog.Controllers {
\end_layout

\begin_layout Plain Layout

	public class PostController : Controller     {
\end_layout

\begin_layout Plain Layout

	    private CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

	    public ActionResult Details(Guid? id){
\end_layout

\begin_layout Plain Layout

		if (id == null){
\end_layout

\begin_layout Plain Layout

			return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		Post post = db.Posts.Find(id);
\end_layout

\begin_layout Plain Layout

		if (post == null){
\end_layout

\begin_layout Plain Layout

			return HttpNotFound();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		return View(post);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Visualizzazione di un singolo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per implementare un nuovo controllo, è sufficiente creare una nuova classe
 pubblica all'interno del namespace del progetto ed estendere la classe
 astratta 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

.
 Nel frammento della classe 
\begin_inset Quotes eld
\end_inset

PostController
\begin_inset Quotes erd
\end_inset

 è mostrata l'implementazione di una singola azione che, in funzione del
 parametro 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 carica tramite LINQ ed EF l'entità corrispondente e restituisce un riferimento
 alla vista 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

.
 Come in RoR per ogni azione, se non specificato diversamente, è prevista
 una vista con ugual nome, in particolare, dopo aver individuato il corretto
 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 all'interno del modello, il server web fornirà all'utente la vista corrisponden
te al file 
\begin_inset Quotes eld
\end_inset

Views/Details.cshtml
\begin_inset Quotes erd
\end_inset

.
 L'azione 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

 accetta richieste HTTP di qualsiasi tipo, per applicare delle limitazioni
 è sufficiente annotare il metodo con attributi come 
\begin_inset Quotes eld
\end_inset

HttpGet
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

HttpPost
\begin_inset Quotes erd
\end_inset

 presenti in MVC5.
\end_layout

\begin_layout Standard
Il tipo 
\begin_inset Quotes eld
\end_inset

ActionResult
\begin_inset Quotes erd
\end_inset

 utilizzato come risultato dell'azione ha il compito di incapsulare il risultato
 e permettere al framework fornire una risposta, nel frammento il metodo
 
\begin_inset Quotes eld
\end_inset

View
\begin_inset Quotes erd
\end_inset

 della classe padre 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

 istanzia un'oggetto 
\begin_inset Quotes eld
\end_inset

ViewResult
\begin_inset Quotes erd
\end_inset

 che specifica la vista da renderizzare.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Rispetto a Spring e RoR, non è prevista all'interno dell'architettura una
 componente con il ruolo di disaccoppiare i controlli dalla logica per l'accesso
 al modello, sta quindi all'utente introdurre il pattern che meglio si presta
 allo scopo ed implementarlo.
\end_layout

\begin_layout Subsection
Le viste
\end_layout

\begin_layout Standard
Per l'implementazione delle viste di CSBlog è stato utilizzato Razor, un
 linguaggio ASP.NET per l'implementazione di pagine dinamiche che introduce
 una sintassi basata sul C# ed integrata in VS tramite, ad esempio è previsto
 l'IntelliSense e la possibilità di creare nuove pagine sfruttando i wizard
 presenti nell'ambiente di sviluppo.
\end_layout

\begin_layout Standard
Razor rappresenta la scelta di default per lo sviluppo di una nuova applicazione
 web, introdotto dalla versione 4 del framework, introduce una sintassi
 per ottimizzare la generazione di pagine HTML, definenendo un insieme di
 costrutti per permettere allo sviluppatore di distinguere facilmente le
 porzioni di codice dinamico.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{
\end_layout

\begin_layout Plain Layout

	var helloRazor = "Benvenuto su CSBlog!";
\end_layout

\begin_layout Plain Layout

	var weekDay = DateTime.Now.DayOfWeek;
\end_layout

\begin_layout Plain Layout

	var greetingMessage = greeting + " Oggi è: " + weekDay;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

<p>@helloRazor</p>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Hello Razor!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il design delle istruzioni è essenziale ed è paragonabile ad ERB, sono infatti
 presenti anche in Razor dei dei delimitatori per includere all'interno
 delle viste codice.
 Nel frammento d'esempio è introdotto un blocco contente istruzioni C#,
 che utilizzano le librerie di sistema, all'interno del quale è creato un
 messaggio di benvenuto.
 Tramite la notazione 
\begin_inset Quotes eld
\end_inset

@variabile
\begin_inset Quotes erd
\end_inset

 è possibile accedere utilizzare all'interno della struttura del documento
 per utilizzare l'espressione concatenata nel blocco.
\end_layout

\begin_layout Standard
La distinzione fra la sintassi 
\begin_inset Quotes eld
\end_inset

@{...}
\begin_inset Quotes erd
\end_inset

 e l'operatore 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

 che permette di accedere ai valori e di utilizzarne le espressioni per
 generare le viste dinamiche, permette di dichiarare viste in cui sono distinte
 in maniera chiara le porzioni di codice che includono l'implementazione
 della logica dalle istruzioni che esclusivamente utilizzano le funzionalità
 in lettura.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ul>
\end_layout

\begin_layout Plain Layout

@for (int i = 0; i < 10; i++){
\end_layout

\begin_layout Plain Layout

	<li>@i</li>
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

</ul>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Il ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 in Razor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La sintassi di Razor include anche i più comuni costrutti sintattici, nell'esemp
io è mostrato l'utilizzo di un ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 le cui iterazioni generano nuovi elementi della lista 
\begin_inset Quotes eld
\end_inset

ul
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'organizzazione e le convenzioni utilizzate da MVC5 semplifica la definizione
 dell'intera applicazione, ed anche per la definizione delle viste è previsto
 un meccanismo per fattorizzare al meglio il proprio codice.
\end_layout

\begin_layout Standard
Per ogni vista da processare e visualizzare in risposta ad una richiesta
 HTTP, viene ricercato il file 
\begin_inset Quotes eld
\end_inset

_ViewStart.cshtml
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

cshtml
\begin_inset Quotes erd
\end_inset

 è l'estensione delle viste in Razor.
\end_layout

\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

Views
\begin_inset Quotes erd
\end_inset

.
 Per CSBlog è stato utilizzata per indicare quale sia il file Razor contenente
 il layout delle pagine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{
\end_layout

\begin_layout Plain Layout

	Layout = "~/Views/Shared/_Layout.cshtml";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Il contenuto della vista _ViewStart.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A differenza delle altre piattaforme, anche la scelta del layout può essere
 effettuata dinamicamente, permettendo di aver maggior controllo sull'aspetto
 delle proprie pagine semplicemente cambiando il percorso della risorsa
 o aggiungendo della logica all'assegnazione.
 Ad esempio è possibile definire più versioni del proprio sito, ottimizzandone
 l'uso in funzione del tipo di device che sta effettuando la navigazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<!DOCTYPE html>
\end_layout

\begin_layout Plain Layout

<html xmlns:th="http://www.thymeleaf.org">
\end_layout

\begin_layout Plain Layout

	@Html.Partial("_HeadPartial")
\end_layout

\begin_layout Plain Layout

	<body>
\end_layout

\begin_layout Plain Layout

		@Html.Partial("_HeaderPartial")
\end_layout

\begin_layout Plain Layout

		<div id="content">
\end_layout

\begin_layout Plain Layout

		@RenderBody()
\end_layout

\begin_layout Plain Layout

		</div>
\end_layout

\begin_layout Plain Layout

		@Html.Partial("_FooterPartial")
\end_layout

\begin_layout Plain Layout

	</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La struttura delle viste in CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per definire un layout è sufficiente creare una nuova vista con Razor ed
 utilizzare funzionalità come 
\begin_inset Quotes eld
\end_inset

Partial
\begin_inset Quotes erd
\end_inset

, per espandere il contenuto di una vista parziale, o 
\begin_inset Quotes eld
\end_inset

RenderBody
\begin_inset Quotes erd
\end_inset

 per espandere la vista restituita dall'azione che ha gestito la richiesta.
 Nell'esempio è mostrato com'è costituita la struttura di una pagina di
 CSBlog.
\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
Visual Studio, ASP.NET e l'EF sono software estremamente ampi, ricchi di
 funzionalità e professionali ma la creazione di una nuova applicazione
 per MVC5 definisce un progetto nel quale sono utilizzate la maggior parte
 delle componenti presenti nel framework.
 Navigando fra i sorgenti del progetto è possibile approfondirne le funzionalità
, intuirne le potenzialità e osservare le soluzioni proposte dal team di
 VS.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre ad includere un esempio di applicazione funzionante per ogni nuovo
 progetto, VS fornisce agli sviluppatori numerosi wizard per generare e
 configurare le nuove funzionalità.
 Durante il progetto non è mai stato necessario modificare manualmente i
 file XML per la configurazione dell'applicazione e l'introduzione di nuovi
 controlli, viste o entità non ha richiesto uno studio approfondito del
 framework per una singola funzionalità, come ad esempio per la definizione
 del modello con JPA.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Inoltre VS integra all'interno dell'ambiente di sviluppo tutte le diverse
 categorie di strumenti e linguaggi necessari per lo sviluppo di un'applicazione
 web.
 Oltre ai classici HTML, CSS e Javascript, è supportato di default lo sviluppo
 tramite Sass e Boostrap
\begin_inset Foot
status open

\begin_layout Plain Layout
Bootstrap è un'interessante framework, sviluppato originariamente da Twitter,
 per la definizione di pagine web responsive.
 E' particolarmente apprezzato per la definizione di siti facilmente navigabili
 da device mobile in quanto non prevede l'utilizzo di fogli di stile per
 definire la disposizione degli elementi nella pagina.
\end_layout

\end_inset

, tecnologie innovative per lo sviluppo di applicazioni Web.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-CSBlog!"

\end_inset

Hello CSBlog!
\end_layout

\begin_layout Standard
Nella sezione sono introdotti gli strumenti per effettuare la definizione
 dei test di accettazione automatici per CSBlog.
 Nella prima parte è descritto il processo di configurazione di Coypu, la
 libreria per l'automazione scelta per .NET, e di SpecFlow, il framework
 per il BDD.
 Successivamente sono introdotti i primi test e le funzionalità utilizzate
 per l'implementazione.
\end_layout

\begin_layout Subsection
SpecFlow
\end_layout

\begin_layout Standard
SpecFlow è un framework per .NET che utilizza alcune componenti di Cucumber
 come il DSL e il relativo parser, entrambe presenti pubblicamente su GitHub.
 Nonostante utilizzi Gherkin, non è un porting dell'intero framework in
 C# di cui al momento esistono le versioni Java, Ruby e JavaScript.
\end_layout

\begin_layout Paragraph
Le funzionalità
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La prima feature di SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Grazie all'utilizzo di SpecFlow è possibile riutilizzare la stessa libreria
 utilizzata per lo sviluppo di RBlog e SBlog.
 Nell'importazione e nello sviluppo dei post non sono state rilevate problemi
 legati al linguaggio ed ai costrutti sintattici utilizzati, sono però presenti
 delle differenze nell'implementazione, come verrà descritto nelle successive
 sezioni.
\end_layout

\begin_layout Paragraph
Supporto a Specflow in VS
\end_layout

\begin_layout Standard
Per utilizzare SpecFlow in VS è sufficiente installare tramite il gestore
 dei pacchetti il relativo plugin.
 Per eseguire le funzionalità e gli scenari tramite il runner di NUnit è
 necessario anche un pacchetto aggiuntivo, installabile tramite la console
 di NuGet utilizzando il comando seguente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Install-Package SpecFlow.NUnit
\begin_inset Caption Standard

\begin_layout Plain Layout
Installazione del plugin per SpecFlow in VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Completata l'installazione del software non è necessario compiere alcuna
 operazione di configurazione.
 Il plugin estende il funzionamento di VS aggiungendo il completo supporto
 a Gherkin, evidenziando la sintassi nelle diverse lingue esistenti, introducend
o l'autocompletamento all'interno dei file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, permettendo la navigazione da passo ad implementazione, permettendo la
 generazione automatica degli stub rappresentanti i passi e aggiungendo
 le funzionalità in Gherkin nei menù rapidi per la creazione delle risorse.
\end_layout

\begin_layout Standard
Per l'esecuzione delle funzionalità è possibile selezionare direttamente
 i file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, eventualmente utilizzando il tag 
\begin_inset Quotes eld
\end_inset

@ignore
\begin_inset Quotes erd
\end_inset

 per saltare alcuni scenari, oppure sfruttare l'integrazione con NUnit per
 scegliere quale sotto-insieme di scenari eseguire, è possibile sfruttare
 i diversi ordinamenti di NUnit per eseguire gli scenari in funzione di
 durata di esecuzione, risultato del test, tag utilizzati o namespace.
\end_layout

\begin_layout Subsection
Coypu
\end_layout

\begin_layout Standard
I parametri utilizzati per scegliere la libreiria per l'automazione della
 navigazione via browser favoriscono strumenti preferibilmente scritti nel
 linguaggio utilizzato per implementare l'applicazione web, il cui sviluppo
 sia attivo, che possibilmente siano open-source e che abbiano una comunità
 attiva per poter avere un riscontro in caso di difficoltà.
\end_layout

\begin_layout Standard
L'individuazione di una libreria per .NET che soddisfasse questi parametri
 non è stato semplice.
 Oltre a Selenium, già utilizzato per Java, sono stati valutati Watin, il
 cui sviluppo è fermo dal 2011, e Telerick Testing Framework, che per quanto
 sia un progetto attivo e ben documentato, sembra non essere utilizzato
 ed essere privo di una propria comunità di utenti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Viste le diverse difficoltà nella scelta di una libreria è stata effettuata
 una scelta sperimentale utilizzando Coypu, un wrapper di Selenium Web Driver,
 scritto in C# che nella propria implementazione si ispira al DSL di Capybara.
\end_layout

\begin_layout Standard
Il progetto è stato rilasciato la prima volta 2011, 2 anni prima del rilascio
 della versione beta di Selenium 2.0 ed è attualmente sviluppato, anche se
 il supporto è principalmente effettuato dal un singolo autore.
 Nonostante si tratti di una libreria open-source utilizzata da una ridotta
 comunità, presenta un'interessante prospettiva dell'automazione della navigazio
ne web che merita di essere approfondita.
\end_layout

\begin_layout Standard
I principali obbiettivi di Coypu riguardano la semplificazione e razionalizzazio
ne delle funzionalità della libreria di Selenium e la definizione di una
 libreria che, come Capybara, permetta di descrivere i propri test nella
 maniera più vicina possibile a come un utente descriverebbe le proprie
 azioni sul browser.
\end_layout

\begin_layout Subsubsection*
Configurazione di una sessione di testing
\end_layout

\begin_layout Standard
Come effettuato per Selenium in SBlog, anche per Coypu è stato scelto di
 utilizzare un nuovo ambiente di testing per ogni scenario, aprendo una
 nuova finestra prima prima dell'esecuzione e rilasciando le risorse al
 termine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[BeforeScenario]
\end_layout

\begin_layout Plain Layout

public void Before(){
\end_layout

\begin_layout Plain Layout

	var sessionConfiguration = new SessionConfiguration             	{
\end_layout

\begin_layout Plain Layout

		Port = 1448,
\end_layout

\begin_layout Plain Layout

		Driver = typeof(SeleniumWebDriver),
\end_layout

\begin_layout Plain Layout

		Browser = Coypu.Drivers.Browser.PhantomJS,
\end_layout

\begin_layout Plain Layout

		Timeout = TimeSpan.FromSeconds(5)
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	_browser = new BrowserSession(sessionConfiguration);            	_browser.Maximi
seWindow();             	_objectContainer.RegisterInstanceAs(_browser);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Creazione-della-sessione."

\end_inset

Creazione della sessione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche in SpecFlow è possibile definire delle callback, nell'esempio è definito
 un hook 
\begin_inset Quotes eld
\end_inset

BeforeScenario
\begin_inset Quotes erd
\end_inset

 da eseguire prima di ogni scenario, contenente le istruzioni per la definizione
 di una sessione.
 In particolare tramite la classe 
\begin_inset Quotes eld
\end_inset

SessionConfigurazion
\begin_inset Quotes erd
\end_inset

 è impostata la porta del server web, il driver ed il browser utilizzato
 ed il tempo massimo di esecuzione di ricerca per un selettore all'interno
 della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AfterScenario]
\end_layout

\begin_layout Plain Layout

public void AfterScenario(){
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	_browser.Dispose();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Chiusura del browser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per rilasciare la sessione di testing è invocato il metodo 
\begin_inset Quotes eld
\end_inset

dispose
\begin_inset Quotes erd
\end_inset

 al termine di ogni scenario.
\end_layout

\begin_layout Subsubsection*
PhantomJS
\end_layout

\begin_layout Standard
Per utilizzare PhantomJS per come browser per i propri test, è necessario
 mantenere l'eseguibile all'interno del path del proprio sistema o all'interno
 della cartella 
\begin_inset Quotes eld
\end_inset

bin
\begin_inset Quotes erd
\end_inset

 del progetto in VS.
 Per installare il browser localmente è possibile utilizzare la console
 di Nuget ed eseguire il seguente comando.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

install-package phantomjs.exe
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Installazione locale di PhantomJS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"apro CSBlog")]
\end_layout

\begin_layout Plain Layout

public void DatoAproCSBlog(){
\end_layout

\begin_layout Plain Layout

	/*..*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro SBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro SBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In maniera paragonabile a Cucumber e Cucumber-JVM, l'implementazione di
 un passo coincide con la definizione di un metodo pubblico annotato con
 un attributo, come Given nell'esempio, per indicare tramite l'espressione
 regolare quale sia il passo implementato.
 I passi devono essere inseriti all'interno di classi annotate con l'attributo
 
\begin_inset Quotes eld
\end_inset

Binding
\begin_inset Quotes erd
\end_inset

.
 Rispetto però ai framework BDD utilizzati finora, Specflow è più rigido
 per quanto riguarda l'implementazione dei passi, per eseguire i passi degli
 scenari è obbligatorio che il tipo dichiarato in Gherkin coincida con l'attribu
to utilizzato.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Binding]
\end_layout

\begin_layout Plain Layout

public class Constraints : BaseStep     {
\end_layout

\begin_layout Plain Layout

	[Given(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

	[When(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

	public void DatoMiAutenticoCome(string email){
\end_layout

\begin_layout Plain Layout

		/*..*/
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*..*/
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Implementazione valida per una pre-condizione ed un evento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre è possibile definire lo scope per ogni metodo o classe che implementi
 le funzionalità scritte in Gherkin tramite l'attributo 
\begin_inset Quotes eld
\end_inset

Scope
\begin_inset Quotes erd
\end_inset

.
 E' possibile definire un comportamento più o meno vincolante in funzione
 del diverso posizionamento dell'attributo, annotando l'intera classe o
 il singolo metodo.
 Il codice del prossimo listato vincola la visibilità esprimendo le diverse
 condizioni disponibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Scope(Tag = "xyz", Feature = "Funzionalità", Scenario = "Prova")]
\begin_inset Caption Standard

\begin_layout Plain Layout
Definizione dello scope per 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Navigare all'interno del sito
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"apro CSBlog")]
\end_layout

\begin_layout Plain Layout

public void DatoAproCSBlog(){
\end_layout

\begin_layout Plain Layout

	browser.Visit("/");
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("CSBlog", browser.Title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come in Selenium, Coypu fornisce all'utente diverse funzionalità per navigare
 all'interno del browser.
 Tramite l'istanza di 
\begin_inset Quotes eld
\end_inset

BrowserSession
\begin_inset Quotes erd
\end_inset

, che include le funzionalità per la gestione del browser come il ridimensioname
nto della finestra, il refresh della pagina e la navigazione attraverso
 la cronologia, è possibile navigare esplicitamente ad un URL passato come
 parametro, nell'esempio è mostrato come sia anche possibile utilizzare
 un percorso relativo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void AcceptModalDialog(Options options = null);
\end_layout

\begin_layout Plain Layout

public void CancelModalDialog(Options options = null);
\end_layout

\begin_layout Plain Layout

public bool HasDialog(string withText, Options options = null);
\end_layout

\begin_layout Plain Layout

public bool HasNoDialog(string withText, Options options = null);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Alcune delle funzionalità presenti nella classe BrowserWindow.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Approfondendo le funzionalità incluse nella classe 
\begin_inset Quotes eld
\end_inset

BrowserWindow
\begin_inset Quotes erd
\end_inset

, si intuisce la propensione di Coypu per la definizione di metodi che rappresen
tino le normali iterazioni di un'utente con il browser durante la navigazione
 web e siano il più intuitivi possibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[When(@"navigo verso ""(.*)""")]
\end_layout

\begin_layout Plain Layout

public void QuandoNavigoVerso(string pageName){
\end_layout

\begin_layout Plain Layout

	Assert.True(browser.FindLink(pageName).Exists());             	browser.ClickLink(pa
geName);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
La particolarità di Coypu è di organizzare la libreria in maniera che le
 funzionalità utilizzate di frequente siano facilmente accessibili.
 Ad esempio per utilizzare un collegamento presente nella pagina per navigare
 all'interno del sito è sufficiente utilizzare il metodo 
\begin_inset Quotes eld
\end_inset

ClickLink
\begin_inset Quotes erd
\end_inset

 esistente all'interno della classe 
\begin_inset Quotes eld
\end_inset

BrowserWindow
\begin_inset Quotes erd
\end_inset

 che rappresenta la sessione di navigazione ed è quindi già istanziata al
 momento dell'esecuzione dei test.
\end_layout

\begin_layout Standard
Inoltre il metodo 
\begin_inset Quotes eld
\end_inset

ClickLink
\begin_inset Quotes erd
\end_inset

 effettua il click dell'elemento in funzione del testo che appare e non
 di un selettore CSS o XPath, facilitando la definizione di test che mantengono
 la stessa prospettiva di un utente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

FindLink
\begin_inset Quotes erd
\end_inset

 permette la ricerca all'interno di un DOM di un collegamento in funzione
 del testo fornito come parametro.
 Il metodo restituisce un'istanza di 
\begin_inset Quotes eld
\end_inset

ElementScope
\begin_inset Quotes erd
\end_inset

 che rappresenta un tag presente nel DOM, in maniera simile a Capybara,
 sono presenti numerose proprietà per ottenere informazioni sull'elemento
 ed i metodi per eseguire le azioni.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Al fine di semplificare la definizione dei test, include in tutte le funzionalit
à che effettuano analizzano il DOM un meccanismo di attesa implicito.
 Assumendo che ogni elemento possa essere il risultato di un'operazione
 asincrona, presente in Capybara e solo recentemente in Selenium, permette
 all'utente di definire test più semplici e mantenibili.
 Come definito nel metodo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Creazione-della-sessione."

\end_inset

, che rappresenta la creazione e configurazione di una nuova sessione per
 la verifica di uno scenario, è possibile impostare sia il valore di attesa
 massimo che la frequenza di pooling desiderata.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una carenza riscontrata nelle prime fasi di sviluppo è l'assenza di una
 documentazione che chiarisca il funzionamento della libreria.
 Nonostante Coypu permetta di intuire il funzionamento delle proprie funzionalit
à direttamente dalla segnatura dei metodi, la definizione di qualche esempio
 ne semplificherebbe l'utilizzo.
\end_layout

\begin_layout Paragraph
Definire asserzioni con NUnit
\end_layout

\begin_layout Standard
NUnit è una libreria per la definizione di unit-test in C# nata dal porting
 di JUnit, attualmente è alla versione 2.6 e lo sviluppo è svolto in maniera
 separata dalla versione Java.
\end_layout

\begin_layout Standard
Nonostante i due progetti non siano più sviluppati dallo stesso team, utilizzand
o le asserzioni di NUnit è facile riconoscere l'origine comune.
 Ad esempio nel successivo passo, sono utilizzati i metodi 
\begin_inset Quotes eld
\end_inset

AssertThat
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

AreEqual
\begin_inset Quotes erd
\end_inset

, che rispettivamente verificano la presenza di un elemento con identificatore
 HTML 
\begin_inset Quotes eld
\end_inset

logo
\begin_inset Quotes erd
\end_inset

 e effetua un confronto sul titolo della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Then(@"posso tornare alla pagina iniziale")]
\end_layout

\begin_layout Plain Layout

public void AlloraPossoTornareAllaPaginaIniziale(){
\end_layout

\begin_layout Plain Layout

	var logoLink = browser.FindId("logo");
\end_layout

\begin_layout Plain Layout

	Assert.That(logoLink.Exists());
\end_layout

\begin_layout Plain Layout

	logoLink.Click();
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("CSBlog", browser.Title);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uno degli obbiettivi degli autori di NUnit è di definire dei metodi che,
 attraverso la propria segnatura, descrivano il proprio funzionamento e
 siano facilmente leggibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Assert.That(myString, Is.EqualTo("Hello"));
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

Un possibile uso dell'asserzione 
\begin_inset Quotes eld
\end_inset

That
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

That
\begin_inset Quotes erd
\end_inset

 nell'esempio è utilizzato per verificare un valore booleano, in generale
 però è utilizzato per la sua caratteristica di accettare parametri 
\begin_inset Quotes eld
\end_inset

IConstraint
\begin_inset Quotes erd
\end_inset

.
 L'interfaccia definisce un insieme di metodi per rappresentare una condizione
 e, oltre alle classi esistenti nella libreria come mostrato nell'esempio,
 permette la definizione di classi personalizzate.
 In Coypu è presente una classe 
\begin_inset Quotes eld
\end_inset

Shows
\begin_inset Quotes erd
\end_inset

 che implementa diverse condizioni e esalta la leggibilità delle asserzioni,
 come sarà mostrato nelle prossime sezioni.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
Le funzionalità presenti nella libreria di Coypu non includono le funzionalità
 per leggere le proprietà di stile degli elementi presenti nel DOM di una
 pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Feature: Introducendo il CSS
\end_layout

\begin_layout Plain Layout

Per rendere l'esperienza di navigazione gradevole
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che il sito esponesse una grafica omogenea
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:02x00 Introducendo il CSS"

\end_inset

Seconda funzionalità per CSBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella funzionalità corrente dovrebbero essere verificati alcuni scenari
 relativi all'aspetto della pagina, in particolare gli effetti cromatici
 ampiamenti descritti nei precedenti capitoli e altre proprietà legate alla
 corretta visualizzazione degli elementi.
\end_layout

\begin_layout Standard
Nonostante gli sforzi dell'autore e dei numerosi sviluppatori, che frequentement
e propongono le loro pull-request su GitHub, Coypu non può mantenere il
 livello di sviluppo di Selenium.
 Per fornire comunque pieno supporto ai propri utenti è possibile sfruttare
 la libreria nativa, utilizzata dalle stesse funzionalità di Coypu, come
 mostrato nel passo del listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Uso-delle-funzionalità"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"l'intestazione ha un colore di sfondo")]
\end_layout

\begin_layout Plain Layout

public void DatoLIntestazioneHaUnColoreDiSfondo(){
\end_layout

\begin_layout Plain Layout

	var selenium = ((OpenQA.Selenium.Remote.RemoteWebDriver)browser.Native);
\end_layout

\begin_layout Plain Layout

	var color = selenium.FindElementById("header").GetCssValue("background-color");
\end_layout

\begin_layout Plain Layout

	Assert.NotNull(color);
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("rgba(46, 47, 48, 1)", color);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:Uso-delle-funzionalità"

\end_inset

Uso delle funzionalità native di Selenium.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel metodo è descritto l'utilizzo delle funzionalità di Selenium ed in particola
re l'invocazione del metodo 
\begin_inset Quotes eld
\end_inset

GetCssValue
\begin_inset Quotes erd
\end_inset

 per ottenere la rappresentazione 
\begin_inset Quotes eld
\end_inset

rgba
\begin_inset Quotes erd
\end_inset

 del colore di sfondo dell'intestazione.
\end_layout

\begin_layout Standard
La versione per C# di Selenium è estremamente simile a quella per Java,
 sintassi permettendo, e per questo motivo non è stata completata l'implementazi
one degli scenari per la funzionalità corrente.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Gestione dei post
\end_layout

\begin_layout Plain Layout

	Come Autore
\end_layout

\begin_layout Plain Layout

	Vorrei poter inserire, leggere, modificare e rimuovere dei post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter documentare la tesi
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:03x00 Modello"

\end_inset

Funzionalità dell'iterazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dipendenze
\end_layout

\begin_layout Paragraph
Hooks
\end_layout

\begin_layout Subsection
Gestione dei form
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Given(@"mi autentico come ""(.*)""")]         [When(@"mi autentico
 come ""(.*)""")]         public void DatoMiAutenticoCome(string email) 
        {             string password = "password";             browser.ClickLink
("Login");             browser.FillIn("Email").With(email);             browser.Fil
lIn("Password").With(password);             browser.ClickButton("Login");
         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [When(@"cancello il post ""(.*)""")]         public void QuandoCancelloIl
Post(string title)         {             var post = findPostByTitle(title);
             post.FindCss(".remove_post_button").Click();             browser.ClickB
utton("Confermi la rimozione?");         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        public void AlloraIlContenutoDelPostEUn_AnteprimaDell_InteroPost(string
 title)         {             var post = base.findPostByTitle(title);   
          string body = post.FindCss(".post_body").Text;             Assert.IsNotEmp
ty(body);             Assert.Less(body.Length, 550);             Assert.That(post,
 Shows.Content("Leggi il resto"));         }
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Verificare gli errori
\end_layout

\begin_layout Standard
errore unicità titolo
\end_layout

\begin_layout Standard
form
\end_layout

\begin_layout Subsubsection*
Selettori
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 public void DatoIlPostNonELeggibileSuCSBlog(string title)         {   
          browser.Visit("/");             var posts = browser.FindAllCss(".post");
\end_layout

\begin_layout Plain Layout

            foreach (var post in posts) {                 Assert.That(!post.FindLi
nk(title).Exists());             }         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

            browser.FindCss(".post_title a", text: title).Exists();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        protected ElementScope header {get{return browser.FindId("header");}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        [Then(@"l_intestazione è posizionata all_inizio")]         public
 void AlloraLInizio()         {             var first = browser.FindXPath("//body
/*[1]");             Assert.True(first.Exists());             Assert.True(header.Exi
sts());             Assert.AreEqual(first.Id, header.Id);         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

        protected ElementScope FindNotice(string noticeMessage)        
 {             var notice = browser.FindId("notice", new Options { TextPrecision=
 TextPrecision.Exact});             Assert.That(notice.Exists());         
    return notice;         }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Options class
\end_layout

\begin_layout Subsection
Debug con Specflow
\end_layout

\begin_layout Standard
problemi deploy
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Login & Autorizzazione
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Asincronia
\end_layout

\begin_layout Subsection
JavaScript
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Easter Egging
\end_layout

\begin_layout Plain Layout

	Come Sviluppatore
\end_layout

\begin_layout Plain Layout

	Vorrei che nel blog fosse presente un mio logo
\end_layout

\begin_layout Plain Layout

	Per firmare il mio lavoro
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:05bx00 EasterEgg"

\end_inset

Introduzione di un breve script Javascript.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scenari sull'auto-completamento con JQuery UI
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Autocompletamento della ricerca
\end_layout

\begin_layout Plain Layout

	Dato nell'intestazione è presente la barra di ricerca
\end_layout

\begin_layout Plain Layout

	Dato il post "Lorem Ipsum" esiste
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "lor" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora viene proposto il post "Lorem Ipsum"
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "xyz" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora non è proposto alcun post
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario riguardante l'auto-completamento della ricerca.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
