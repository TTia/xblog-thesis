#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\use_default_options true
\master ../Relazione.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:MVC-5"

\end_inset

MVC 5
\end_layout

\begin_layout Section
ASP.NET MVC 5
\end_layout

\begin_layout Standard
In questo capitolo è trattato lo sviluppo di CSBlog, lo sviluppo tramite
 il framework ASP.NET MVC 5 del nostro caso di studio.
 L'implementazione dei test di accettazione già mostrata nei precedenti
 capitoli utilizzando Specflow, una libreria per il BDD ispirata a Cucumber,
 e Coypu per automatizzare la navigazione del browser web.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
In questo capitolo saranno descritte le particolarità del framework, l'implement
azione delle diverse componenti e gli strumenti utilizzati.
 Dalla sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hello-CSBlog!"

\end_inset

 in poi sono documentate le diverse funzionalità presenti nella libreria
 dei test di accettazione e viene descritto il processo di testing, includendo
 esempi e frammenti di codice.
\end_layout

\begin_layout Subsection
Visual Studio 2013
\end_layout

\begin_layout Standard
Per lo sviluppo di CSBlog, dei test di accettazione e la gestione del modello
 è stato utilizzato Visual Studio 2013 Ultimate, nel seguito VS, che integra
 le diverse funzionalità per lo sviluppo web, la configurazione della propria
 applicazione e l'implementazione delle diverse componenti del pattern.
\end_layout

\begin_layout Standard
Tutti i plugin necessari, come ad esempio quello per Specflow, sono stati
 installati tramite NuGet, il gestore di pacchetti per il mondo .NET, direttament
e tramite l'ambiente di sviluppo.
 VS è un ambiente di sviluppo con enormi potenzialità, articolato e complesso,
 con numerose funzionalità per il supporto alla configurazione e generazione
 del progetto, come sarà mostrato nelle prossime sezioni.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:L'interpretazione di MVC5"

\end_inset

L'interpretazione di ASP.NET del pattern MVC
\end_layout

\begin_layout Standard
In questa sezione è descritto il processo di definizione dell'architettura
 di CSBlog, caratterizzato da un uso costante degli strumenti di VS per
 la definizione delle varie componenti.
 Al termine della sezione risulterà evidente come, nonostante il framework
 MVC5 e l'intero progetto ASP.NET sia estremamente articolato, la presentazione
 delle grandi potenzialità messe a disposizione è sufficientemente accessibile
 così che lo sviluppo non ne risente.
\end_layout

\begin_layout Subsection
Il modello
\end_layout

\begin_layout Standard
Per implementare l'interfaccia del modello di MVC5 è stato scelto l'Entity
 Framework, attualmente alla versione 6, che implementa l'astrazione del
 modello attraverso la tecnica ORM in maniera simile a quanto già visto
 per RoR e Spring.
 Il framework si integra con ADO.NET, responsabile dell'interazione con i
 sistemi di persistenza esistenti e del mantenimento della consistenza fra
 le entry dei database e gli oggetti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'EF supporta sia l'approccio 
\begin_inset Quotes eld
\end_inset

code-first
\begin_inset Quotes erd
\end_inset

, in cui si definiscono le classi che rappresentano le entità e da esse
 si genera il database corrispondente, in maniera analoga a quanto già visto
 per RoR e JPA, sia l'approccio 
\begin_inset Quotes eld
\end_inset

db-first
\begin_inset Quotes erd
\end_inset

, in cui si generano le classi a partire dal DB.
\end_layout

\begin_layout Standard
Per CSBlog è stato scelto quest'ultimo approccio, utilizzando il DDL di
 SQL -come database è stato scelto SQL Server Express, la versione gratuita
 del database sviluppato da Microsoft-, la generazione guidata e gli strumenti
 grafici per la gestione disponibili per creare le tabelle 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 ed 
\begin_inset Quotes eld
\end_inset

Autore
\begin_inset Quotes erd
\end_inset

 e la relazione presente fra le due entità in breve tempo.
\end_layout

\begin_layout Standard
Visual Studio include un wizard per la configurazione del modello, che provvede
 a definire la connessione al database, a generare le classi parziali
\begin_inset Foot
status open

\begin_layout Plain Layout
Una classe parziale in C# rappresenta una parte di una classe intera.
 La definizione completa è suddivisa in più fine che saranno unite a tempo
 di compilazione.
\end_layout

\end_inset

 rappresentanti le entità e a configurare le risorse necessarie per il funzionam
ento dell'EF.
\end_layout

\begin_layout Standard
Le classi che descrivono le entità dell'EF sono gestite attraverso un'estensione
 della classe 
\begin_inset Quotes eld
\end_inset

DbContext
\begin_inset Quotes erd
\end_inset

, che fornisce le funzionalità per eseguire interrogazioni, tener traccia
 dei cambiamenti allo stato delle istanze ed invocare le operazioni di creazione
, aggiornamento e cancellazione.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public partial class CSBlogEntities : DbContext{
\end_layout

\begin_layout Plain Layout

	public CSBlogEntities() : base("name=CSBlogEntities"){}         	protected
 override void OnModelCreating(DbModelBuilder modelBuilder){
\end_layout

\begin_layout Plain Layout

		throw new UnintentionalCodeFirstException();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Author> Authors { get; set; }
\end_layout

\begin_layout Plain Layout

	public virtual DbSet<Post> Posts { get; set; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Il-contesto-di"

\end_inset

Il contesto di CSBlog generato da VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Il-contesto-di"

\end_inset

, le proprietà 
\begin_inset Quotes eld
\end_inset

Authors
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

Posts
\begin_inset Quotes erd
\end_inset

 rappresentano le entità presenti nel database per i rispettivi tipi, rappresent
ando quindi a livello OO le corrispondenti tabelle e sono utilizzate dall'EF
 per effettuare le query.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per implementare le interrogazioni necessarie per CSBlog è stato utilizzato
 LINQ, Language-Integrated Query.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

IQueryable<Post> qTitles = db.Posts.Select(p => p.title)
\end_layout

\begin_layout Plain Layout

var postTitles = qTitles.ToList();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Proiezione-dei-titoli"

\end_inset

Proiezione dei titoli dei post con LINQ.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
LINQ permette di definire le proprie query attraverso un insieme di metodi
 che rispecchiano le funzionalità di SQL e permettono di utilizzare il paradigma
 ad oggetti, ad esempio la proiezione per ottenere i titoli dei post esistenti
 è definita effettuato un accesso all'attributo 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

 dell'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
 Utilizzando una libreria che fornisce una tale astrazione del modello e
 delle entità è possibile definire le proprie interrogazioni sfruttando
 tutte le funzionalità esistenti per C# in VS, come l'auto-completamento
 e l'evidenziatura dei diversi elementi sintattici.
 Inoltre LINQ definisce query utilizzando metodi generici che permettono
 di verificare a compile-time il corretto utilizzo dei tipi e degli attributi
 presenti nelle interrogazioni.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una query LINQ non viene eseguita al momento della sua definizione, ma solo
 quando è necessario accedere ai suoi elementi, ad esempio per iterarvi
 sopra, accedere al primo elemento (metodo 
\begin_inset Quotes eld
\end_inset

First
\begin_inset Quotes erd
\end_inset

) o verificare che ne esista almeno uno (metodo 
\begin_inset Quotes eld
\end_inset

Any
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
In maniera simile all'interfaccia per la definizione delle query con gli
 Active Record di RoR, lo sviluppatore può sfruttare l'astrazione introdotta
 dall'uso dell'EF e definire le proprie query in maniera veloce ed intuitiva.
 Rispetto però alla controparte in Ruby, LINQ è più completo permettendo
 la definizione di interrogazioni anche su altri sistemi per la persistenza,
 come documenti XML, ed anche su collezioni di tipo 
\begin_inset Quotes eld
\end_inset

IEnumerable
\begin_inset Quotes erd
\end_inset

 in memoria.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La semplice query 
\begin_inset Quotes eld
\end_inset

qTitles
\begin_inset Quotes erd
\end_inset

, in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Proiezione-dei-titoli"

\end_inset

, di proiezione dell'esempio è suddivisibile in tre elementi: l'ottenimento
 del contesto tramite le classi dell'EF, rappresentato dall'oggetto 
\begin_inset Quotes eld
\end_inset

db
\begin_inset Quotes erd
\end_inset

 e corrispondente alla sorgente di dati o del DB, la selezione della proprietà
 Posts, per specificare quale sia l'entità utilizzata nell'interrogazione,
 la specifica delle operazioni, come il metodo 
\begin_inset Quotes eld
\end_inset

Select
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
L'esecuzione della query coincide con l'invocazione del metodo 
\begin_inset Quotes eld
\end_inset

ToList
\begin_inset Quotes erd
\end_inset

.
 L'oggetto 
\begin_inset Quotes eld
\end_inset

qTitles
\begin_inset Quotes erd
\end_inset

 ha tipo IQueryable, interfaccia generica sul tipo dell'interrogazione che
 estende IEnumerable e dichiara le funzionalità per compiere la valutazione
 della query.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre alla generazione dell'interfaccia del modello, VS include un browser
 per visualizzare lo schema delle entità esistenti e le relazioni presenti.
 Tramite questo strumento, direttamente nell'ambiente di sviluppo, è possibile
 visualizzare e aggiornare la struttura del modello, sincronizzare gli schemi
 dei database utilizzati, ed anche gestire associazioni e relazioni di ereditari
età.
\end_layout

\begin_layout Subsection
I controlli
\end_layout

\begin_layout Standard
Come per la definizione del modello, anche per i controlli e le relative
 azioni, sono stati utilizzati gli strumenti di VS per la generazione automatica
 delle componenti.
 Il wizard per la configurazione è ben strutturato e permette di indicare
 quali azioni sia necessario generare, ad esempio è possibile creare un
 controllo contenente le operazioni CRUD oppure vuoto, e se utilizzare l'EF
 per associare il nuovo controllo ad una delle entità e generare delle azioni
 opportunamente connesse al modello.
\end_layout

\begin_layout Standard
Durante il processo di configurazione del nuovo controllo è anche generato
 un'insieme di viste corrispondenti alle azioni create.
 In maniera simile a RubyMine, gli strumenti dell'ambiente di sviluppo facilitan
o lo sviluppo fornendo un'implementazione funzionante per le nuove applicazioni
 e preziose indicazioni sulla struttura del framework e di come le componenti
 interagiscano fra loro.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per semplificare la risoluzione delle richieste HTTP per l'applicazione,
 MVC5 definisce un file 
\begin_inset Quotes eld
\end_inset

RouteConfig.cs
\begin_inset Quotes erd
\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

AppData
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class RouteConfig{
\end_layout

\begin_layout Plain Layout

	public static void RegisterRoutes(RouteCollection routes){
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	routes.MapRoute(
\end_layout

\begin_layout Plain Layout

		name: "Default",
\end_layout

\begin_layout Plain Layout

		url: "{controller}/{action}/{id}",
\end_layout

\begin_layout Plain Layout

		defaults: new {
\end_layout

\begin_layout Plain Layout

			controller = "Post",
\end_layout

\begin_layout Plain Layout

			action = "Index",
\end_layout

\begin_layout Plain Layout

			id = UrlParameter.Optional
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Definizione del pattern per la risoluzione delle richieste.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

RegisterRoutes
\begin_inset Quotes erd
\end_inset

 si occupa di registrare la convenzione scelta per la risoluzione delle
 richieste effettuate dagli utenti.
 Come si può osservare dal metodo, il pattern scelto rispecchia l'organizzazione
 di un'architettura REST: ad esempio l'URL relativo 
\begin_inset Quotes eld
\end_inset

/Post/Details/id
\begin_inset Quotes erd
\end_inset

, per visualizzare il contenuto di un singolo post, è suddiviso in tre elementi,
 il nome del controllo, l'azione corrispondente e l'identificatore dell'elemento.
 Inoltre è specificato quale sia l'homepage tramite il parametro 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

namespace Blog.Controllers {
\end_layout

\begin_layout Plain Layout

	public class PostController : Controller     {
\end_layout

\begin_layout Plain Layout

		private CSBlogEntities db = new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

		public ActionResult Details(Guid? id){
\end_layout

\begin_layout Plain Layout

			if (id == null){
\end_layout

\begin_layout Plain Layout

				return new HttpStatusCodeResult(HttpStatusCode.BadRequest);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			Post post = db.Posts.Find(id);
\end_layout

\begin_layout Plain Layout

			if (post == null){
\end_layout

\begin_layout Plain Layout

				return HttpNotFound();
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			return View(post);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		/*...*/
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Details"

\end_inset

Visualizzazione di un singolo post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per implementare un nuovo controllo, è sufficiente creare una nuova classe
 pubblica all'interno del namespace del progetto ed estendere la classe
 astratta 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

.
 Nel frammento della classe 
\begin_inset Quotes eld
\end_inset

PostController
\begin_inset Quotes erd
\end_inset

 in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Details"

\end_inset

 è mostrata l'implementazione di una singola azione che, in funzione del
 parametro 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 carica tramite LINQ ed EF l'entità corrispondente e restituisce un riferimento
 alla vista 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Infatti il tipo 
\begin_inset Quotes eld
\end_inset

ActionResult
\begin_inset Quotes erd
\end_inset

 utilizzato come risultato dell'azione ha il compito di rappresentare il
 risultato e permettere al framework di fornire una risposta; nel frammento
 il metodo 
\begin_inset Quotes eld
\end_inset

View
\begin_inset Quotes erd
\end_inset

 della classe padre 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

 istanzia un'oggetto 
\begin_inset Quotes eld
\end_inset

ViewResult
\begin_inset Quotes erd
\end_inset

 che specifica la vista da renderizzare.
\end_layout

\begin_layout Standard
Ad ogni azione, se non specificato diversamente, corrisponde una vista con
 ugual nome.
 Nel nostro esempio, dopo aver individuato il corretto 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 all'interno del modello, il server web fornirà all'utente la vista corrisponden
te al file 
\begin_inset Quotes eld
\end_inset

Views/Details.cshtml
\begin_inset Quotes erd
\end_inset

.
 L'azione 
\begin_inset Quotes eld
\end_inset

Details
\begin_inset Quotes erd
\end_inset

 accetta richieste HTTP di qualsiasi tipo, per applicare delle limitazioni
 è sufficiente annotare il metodo con attributi come 
\begin_inset Quotes eld
\end_inset

HttpGet
\begin_inset Quotes erd
\end_inset

 o 
\begin_inset Quotes eld
\end_inset

HttpPost
\begin_inset Quotes erd
\end_inset

 presenti in MVC5.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Rispetto a Spring e RoR, rispettivamente con i Service e gli Helper, non
 è prevista all'interno dell'architettura una componente con il ruolo di
 disaccoppiare i controlli dalla logica per l'accesso al modello, sta quindi
 all'utente introdurre il pattern che meglio si presta allo scopo ed implementar
lo.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:MVC5 Viste"

\end_inset

Le viste
\end_layout

\begin_layout Standard
Per l'implementazione delle viste di CSBlog è stato utilizzato Razor, un
 linguaggio ASP.NET per l'implementazione di pagine dinamiche che introduce
 un DSL basato su C# ed integrato in VS, ad esempio è previsto l'IntelliSense
 e la possibilità di creare nuove pagine sfruttando i wizard presenti nell'ambie
nte di sviluppo.
\end_layout

\begin_layout Standard
Razor rappresenta la scelta di default per lo sviluppo di una nuova applicazione
 web, introdotto dalla versione 4 del framework, introduce una sintassi
 per ottimizzare la generazione di pagine HTML, definendo un insieme di
 costrutti per permettere allo sviluppatore di distinguere facilmente le
 porzioni di codice dinamico dal resto del documento statico.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{
\end_layout

\begin_layout Plain Layout

	var helloRazor = "Benvenuto su CSBlog!";
\end_layout

\begin_layout Plain Layout

	var weekDay = DateTime.Now.DayOfWeek;
\end_layout

\begin_layout Plain Layout

	var greetingMessage = greeting + " Oggi è: " + weekDay;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

<p>@helloRazor</p>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Hello Razor!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il design delle istruzioni è essenziale ed è paragonabile ad ERB, sono infatti
 presenti anche in Razor dei delimitatori per includere all'interno delle
 viste codice.
 Nel frammento d'esempio è introdotto un blocco contente istruzioni C#,
 all'interno del quale è creato un messaggio di benvenuto.
 Tramite la notazione 
\begin_inset Quotes eld
\end_inset

@variabile
\begin_inset Quotes erd
\end_inset

 è possibile ottenere il valore della stringa definita nel blocco.
\end_layout

\begin_layout Standard
La distinzione fra la sintassi 
\begin_inset Quotes eld
\end_inset

@{...}
\begin_inset Quotes erd
\end_inset

 e l'operatore 
\begin_inset Quotes eld
\end_inset

@
\begin_inset Quotes erd
\end_inset

, che consente di accedere ai valori e di utilizzarne le espressioni per
 generare le viste dinamiche, permette di dichiarare viste in cui sono distinte
 in maniera chiara le porzioni di codice che includono l'implementazione
 della logica delle istruzioni che esclusivamente utilizzano le variabili
 in lettura.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<ul>
\end_layout

\begin_layout Plain Layout

@for (int i = 0; i < 10; i++){
\end_layout

\begin_layout Plain Layout

	<li>@i</li>
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

</ul>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Il-ciclo-for"

\end_inset

Il ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 in Razor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Il-ciclo-for"

\end_inset

, la sintassi di Razor include anche i più comuni costrutti sintattici,
 è mostrato l'utilizzo di un ciclo 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 le cui iterazioni generano nuovi elementi della lista 
\begin_inset Quotes eld
\end_inset

ul
\begin_inset Quotes erd
\end_inset

.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
L'organizzazione e le convenzioni utilizzate da MVC5 semplificano la definizione
 dell'intera applicazione, ed anche per la definizione delle viste è previsto
 un meccanismo per fattorizzare al meglio il proprio codice.
\end_layout

\begin_layout Standard
Per ogni vista da processare e visualizzare in risposta ad una richiesta
 HTTP, viene ricercato il file 
\begin_inset Quotes eld
\end_inset

_ViewStart.cshtml
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

cshtml
\begin_inset Quotes erd
\end_inset

 è l'estensione delle viste in Razor.
\end_layout

\end_inset

 all'interno della cartella 
\begin_inset Quotes eld
\end_inset

Views
\begin_inset Quotes erd
\end_inset

.
 In CSBlog è stato utilizzata questa risorsa per indicare quale sia il file
 Razor contenente il layout delle pagine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@{
\end_layout

\begin_layout Plain Layout

	Layout = "~/Views/Shared/_Layout.cshtml";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:ViewStart"

\end_inset

Il contenuto della vista _ViewStart.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La scelta del layout può essere effettuata dinamicamente come in listato
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:ViewStart"

\end_inset

, permettendo di aver maggior controllo sull'aspetto delle proprie pagine
 semplicemente cambiando il percorso della risorsa o aggiungendo della logica
 all'assegnazione.
 Ad esempio è possibile definire più versioni del proprio sito, ottimizzandone
 l'uso in funzione del tipo di device che sta effettuando la navigazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<!DOCTYPE html>
\end_layout

\begin_layout Plain Layout

<html xmlns:th="http://www.thymeleaf.org">
\end_layout

\begin_layout Plain Layout

	@Html.Partial("_HeadPartial")
\end_layout

\begin_layout Plain Layout

	<body>
\end_layout

\begin_layout Plain Layout

		@Html.Partial("_HeaderPartial")
\end_layout

\begin_layout Plain Layout

		<div id="content">
\end_layout

\begin_layout Plain Layout

		@RenderBody()
\end_layout

\begin_layout Plain Layout

		</div>
\end_layout

\begin_layout Plain Layout

		@Html.Partial("_FooterPartial")
\end_layout

\begin_layout Plain Layout

	</body>
\end_layout

\begin_layout Plain Layout

</html>
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La struttura delle viste in CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per definire un layout è sufficiente creare una nuova vista con Razor ed
 utilizzare funzionalità come 
\begin_inset Quotes eld
\end_inset

Partial
\begin_inset Quotes erd
\end_inset

, per espandere il contenuto di una vista parziale, o 
\begin_inset Quotes eld
\end_inset

RenderBody
\begin_inset Quotes erd
\end_inset

 per espandere la vista restituita dall'azione che ha gestito la richiesta.
 Nell'esempio è mostrato com'è organizzata una pagina di CSBlog.
\end_layout

\begin_layout Subsection
Peculiarità
\end_layout

\begin_layout Standard
Visual Studio, ASP.NET e l'EF sono software estremamente ricchi di funzionalità
 e professionali, ma il loro utilizzo è semplificato da VS che, alla creazione
 di una nuova applicazione, definisce un progetto nel quale sono utilizzate
 la maggior parte delle componenti presenti nel framework.
 Navigando fra i sorgenti appena creati è possibile approfondirne le funzionalit
à, intuirne le potenzialità e osservare le soluzioni proposte dal team di
 VS.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Oltre ad includere un esempio di applicazione funzionante per ogni nuovo
 progetto, VS fornisce agli sviluppatori numerosi wizard per generare e
 configurare le nuove funzionalità.
 Durante lo sviluppo non è mai stato necessario modificare manualmente i
 file XML per la configurazione dell'applicazione e l'introduzione di nuovi
 controlli, viste o entità non ha richiesto uno studio approfondito del
 framework per una singola funzionalità, come ad esempio è successo per
 la definizione del modello con JPA.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Inoltre VS integra all'interno dell'ambiente di sviluppo tutte le diverse
 categorie di strumenti e linguaggi necessari per lo sviluppo di un'applicazione
 web.
 Oltre ai classici HTML, CSS e Javascript, è supportato di default lo sviluppo
 con tecnologie innovative come Sass e Boostrap
\begin_inset Foot
status open

\begin_layout Plain Layout
Bootstrap è un'interessante framework, sviluppato originariamente da Twitter,
 per la definizione di pagine web responsive.
 E' particolarmente apprezzato per la definizione di siti facilmente navigabili
 da device mobile in quanto non prevede l'utilizzo di fogli di stile per
 definire la disposizione degli elementi nella pagina.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Hello-CSBlog!"

\end_inset

Hello CSBlog!
\end_layout

\begin_layout Standard
In questa sezione sono introdotti gli strumenti per effettuare la definizione
 dei test di accettazione automatici per CSBlog.
 Nella sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:SpecFlow"

\end_inset

 è descritto il processo di configurazione di SpecFlow, il framework per
 il BDD, e nella sezione 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Coypu"

\end_inset

 quello di Coypu, la libreria per l'automazione della navigazione web scelta
 per .NET.
 Successivamente sono introdotti i primi test e le funzionalità utilizzate
 per l'implementazione.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:SpecFlow"

\end_inset

SpecFlow
\end_layout

\begin_layout Standard
SpecFlow è un framework per .NET che sfrutta alcune componenti di Cucumber
 come il DSL e il relativo parser, entrambe presenti pubblicamente su GitHub.
 Nonostante utilizzi Gherkin, non è un porting dell'intero framework in
 C#, al momento disponibile solo nelle versioni Java, Ruby e JavaScript.
\end_layout

\begin_layout Subsubsection*
Le funzionalità
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap1
\end_layout

\begin_layout Plain Layout

Funzionalità: Hello RBlog!
\end_layout

\begin_layout Plain Layout

Per leggere i post e visitare il blog
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che RBlog permettesse la navigazione
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
La prima feature di SBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Grazie all'utilizzo di SpecFlow è possibile riutilizzare gli stessi acceptance
 test utilizzati per lo sviluppo di RBlog e SBlog.
 Nell'importazione e nello sviluppo dei test non sono state rilevate problemi
 legati al linguaggio ed ai costrutti sintattici utilizzati, sono però presenti
 delle differenze nell'implementazione, come verrà descritto nelle successive
 sezioni.
\end_layout

\begin_layout Subsubsection*
Supporto a Specflow in VS
\end_layout

\begin_layout Standard
Per utilizzare SpecFlow in VS è sufficiente installare tramite il gestore
 dei pacchetti il relativo plugin.
 Per eseguire le funzionalità e gli scenari tramite il runner di NUnit è
 necessario anche un pacchetto aggiuntivo, installabile tramite la console
 di NuGet utilizzando il comando seguente.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Install-Package SpecFlow.NUnit
\begin_inset Caption Standard

\begin_layout Plain Layout
Installazione del plugin per SpecFlow in VS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Completata l'installazione del software non è necessario compiere alcuna
 operazione di configurazione.
 Il plugin estende il funzionamento di VS aggiungendo il completo supporto
 a Gherkin, evidenziando la sintassi nelle diverse lingue esistenti, introducend
o l'auto-completamento all'interno dei file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, permettendo la navigazione da passo ad implementazione, permettendo la
 generazione automatica degli stub rappresentanti i passi e aggiungendo
 le funzionalità in Gherkin nei menù rapidi per la creazione delle risorse.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per l'esecuzione delle funzionalità è possibile selezionare direttamente
 i file 
\begin_inset Quotes eld
\end_inset

.feature
\begin_inset Quotes erd
\end_inset

, eventualmente utilizzando il tag 
\begin_inset Quotes eld
\end_inset

@ignore
\begin_inset Quotes erd
\end_inset

 per saltare alcuni scenari, oppure sfruttare l'integrazione con NUnit per
 scegliere quale sotto-insieme di scenari eseguire.
 E' possibile utilizzare i diversi ordinamenti di NUnit per eseguire gli
 scenari in funzione di durata di esecuzione, risultato del test, tag utilizzati
 o namespace.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Coypu"

\end_inset

Coypu
\end_layout

\begin_layout Standard
I criteri utilizzati per scegliere la libreria per l'automazione della navigazio
ne via browser in questa tesi, favoriscono strumenti scritti nel linguaggio
 utilizzato per implementare l'applicazione web, il cui sviluppo sia attivo,
 open-source e che abbiano una comunità attiva per poter avere un riscontro
 in caso di difficoltà.
\end_layout

\begin_layout Standard
L'individuazione di una libreria per .NET che soddisfacesse questi parametri
 non è stato semplice.
 Oltre a Selenium, già utilizzato per Java, sono stati valutati Watin, il
 cui sviluppo è fermo dal 2011, e Telerick Testing Framework, che per quanto
 sia un progetto attivo e ben documentato, sembra non essere utilizzato
 ed essere privo di una propria comunità di utenti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Viste le diverse difficoltà nella scelta di una libreria è stata effettuata
 una scelta sperimentale utilizzando Coypu, un wrapper di Selenium Web Driver,
 scritto in C# che nella propria implementazione si ispira al DSL di Capybara.
\end_layout

\begin_layout Standard
Il progetto è stato rilasciato la prima volta 2011, 2 anni prima della versione
 beta di Selenium 2.0, il cui sviluppo è ancora attivo, anche se il supporto
 è principalmente effettuato dal un singolo autore.
 Nonostante si tratti di una libreria open-source utilizzata da una ridotta
 comunità, presenta un'interessante prospettiva dell'automazione della navigazio
ne web che merita di essere approfondita.
\end_layout

\begin_layout Standard
I principali obbiettivi di Coypu riguardano la semplificazione e razionalizzazio
ne delle funzionalità della libreria di Selenium e la definizione di una
 libreria che, come Capybara, permetta di descrivere i propri test nella
 maniera più vicina possibile a come un utente descriverebbe le proprie
 azioni in termini di interazioni con il browser.
\end_layout

\begin_layout Subsubsection*
Configurazione di una sessione di testing
\end_layout

\begin_layout Standard
Come effettuato per Selenium in SBlog, anche per Coypu è stato scelto di
 utilizzare un nuovo ambiente di testing per ogni scenario, aprendo una
 nuova finestra prima prima dell'esecuzione e rilasciando le risorse al
 termine.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[BeforeScenario]
\end_layout

\begin_layout Plain Layout

public void Before(){
\end_layout

\begin_layout Plain Layout

	var sessionConfiguration = new SessionConfiguration             	{
\end_layout

\begin_layout Plain Layout

		Port = 1448,
\end_layout

\begin_layout Plain Layout

		Driver = typeof(SeleniumWebDriver),
\end_layout

\begin_layout Plain Layout

		Browser = Coypu.Drivers.Browser.PhantomJS,
\end_layout

\begin_layout Plain Layout

		Timeout = TimeSpan.FromSeconds(5),
\end_layout

\begin_layout Plain Layout

		RetryInterval = TimeSpan.FromSeconds(0.1)
\end_layout

\begin_layout Plain Layout

	};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	_browser = new BrowserSession(sessionConfiguration);            	_browser.Maximi
seWindow();             	_objectContainer.RegisterInstanceAs(_browser);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Creazione-della-sessione."

\end_inset

Creazione della sessione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Anche in SpecFlow è possibile definire delle callback, nell'esempio 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Creazione-della-sessione."

\end_inset

 è definito un hook 
\begin_inset Quotes eld
\end_inset

BeforeScenario
\begin_inset Quotes erd
\end_inset

 da eseguire prima di ogni scenario, contenente le istruzioni per la definizione
 di una sessione.
 In particolare tramite la classe 
\begin_inset Quotes eld
\end_inset

SessionConfigurazion
\begin_inset Quotes erd
\end_inset

 è impostata la porta del server web, il driver ed il browser utilizzato
 ed il tempo massimo di esecuzione di ricerca per un selettore all'interno
 della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AfterScenario]
\end_layout

\begin_layout Plain Layout

public void AfterScenario(){
\end_layout

\begin_layout Plain Layout

	/*...*/
\end_layout

\begin_layout Plain Layout

	_browser.Dispose();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Chiusura-del-browser."

\end_inset

Chiusura del browser.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per rilasciare la sessione di testing è invocato il metodo 
\begin_inset Quotes eld
\end_inset

dispose
\begin_inset Quotes erd
\end_inset

 al termine di ogni scenario, come si vede in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Chiusura-del-browser."

\end_inset

.
\end_layout

\begin_layout Subsubsection*
PhantomJS
\end_layout

\begin_layout Standard
Per utilizzare PhantomJS come browser per i propri test, è necessario mantenere
 l'eseguibile all'interno del 
\begin_inset Quotes eld
\end_inset

path
\begin_inset Quotes erd
\end_inset

 del proprio sistema o all'interno della cartella 
\begin_inset Quotes eld
\end_inset

bin
\begin_inset Quotes erd
\end_inset

 del progetto in VS.
 Per installare il browser localmente è possibile utilizzare la console
 di Nuget ed eseguire il seguente comando.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

install-package phantomjs.exe
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Installazione locale di PhantomJS.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementazione dei passi
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"apro CSBlog")]
\end_layout

\begin_layout Plain Layout

public void DatoAproCSBlog(){
\end_layout

\begin_layout Plain Layout

	/*..*/
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Implementazione \"apro CSBlog\""

\end_inset

Implementazione del passo 
\begin_inset Quotes eld
\end_inset

apro SBlog
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In maniera paragonabile a Cucumber e Cucumber-JVM, l'implementazione di
 un passo coincide con la definizione di un metodo pubblico annotato con
 un attributo, come Given in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Implementazione \"apro CSBlog\""

\end_inset

, per indicare tramite l'espressione regolare quale sia il passo implementato.
 I passi devono essere inseriti all'interno di classi annotate con l'attributo
 
\begin_inset Quotes eld
\end_inset

Binding
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Rispetto ai framework per il BDD utilizzati finora, Specflow è più rigido
 per quanto riguarda l'implementazione dei passi.
 Infatti obbligatorio che il tipo dichiarato in Gherkin coincida con l'attributo
 utilizzato.
 Quindi se la stessa espressione viene utilizzata in due tipi di passi,
 si deve annotare il metodo che li implementa con entrambe gli attributi,
 come in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Doppio attributo SpecFlow"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Binding]
\end_layout

\begin_layout Plain Layout

public class Constraints : BaseStep     {
\end_layout

\begin_layout Plain Layout

	[Given(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

	[When(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

	public void DatoMiAutenticoCome(string email){
\end_layout

\begin_layout Plain Layout

		/*..*/
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*..*/
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Doppio attributo SpecFlow"

\end_inset

Implementazione valida per una pre-condizione ed un evento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre è possibile definire lo scope per ogni metodo o classe che implementi
 le funzionalità scritte in Gherkin tramite l'attributo 
\begin_inset Quotes eld
\end_inset

Scope
\begin_inset Quotes erd
\end_inset

.
 E' possibile impostare la visibilità dei passi in funzione del diverso
 posizionamento dell'attributo, annotando l'intera classe o il singolo metodo.
 Il codice in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Definizione-dell'attributo-Scope"

\end_inset

 vincola la visibilità esprimendo le diverse condizioni disponibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Scope(Tag = "xyz", Feature = "Funzionalità", Scenario = "Prova")]
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Definizione-dell'attributo-Scope"

\end_inset

Definizione dell'attributo Scope.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Navigare all'interno del sito
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"apro CSBlog")]
\end_layout

\begin_layout Plain Layout

public void DatoAproCSBlog(){
\end_layout

\begin_layout Plain Layout

	browser.Visit("/");
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("CSBlog", browser.Title);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Apertura-di-CSBlog."

\end_inset

Apertura di CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come in Selenium, Coypu fornisce all'utente diverse funzionalità per navigare
 all'interno del browser.
 Tramite l'istanza di 
\begin_inset Quotes eld
\end_inset

BrowserSession
\begin_inset Quotes erd
\end_inset

, che include le funzionalità per la gestione del browser come il ridimensioname
nto della finestra, il refresh della pagina e la navigazione attraverso
 la cronologia, è possibile navigare esplicitamente ad un URL passato come
 parametro, nell'esempio in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Apertura-di-CSBlog."

\end_inset

 è mostrato come sia anche possibile utilizzare un percorso relativo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void AcceptModalDialog(Options options = null);
\end_layout

\begin_layout Plain Layout

public void CancelModalDialog(Options options = null);
\end_layout

\begin_layout Plain Layout

public bool HasDialog(string withText, Options options = null);
\end_layout

\begin_layout Plain Layout

public bool HasNoDialog(string withText, Options options = null);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:BrowserWindow"

\end_inset

Alcune delle funzionalità presenti nella classe 
\begin_inset Quotes eld
\end_inset

BrowserWindow
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Approfondendo le funzionalità incluse nella classe 
\begin_inset Quotes eld
\end_inset

BrowserWindow
\begin_inset Quotes erd
\end_inset

, come ad esempio quello in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:BrowserWindow"

\end_inset

, si intuisce la propensione di Coypu per la definizione di metodi che rappresen
tino le normali interazioni di un'utente con il browser durante la navigazione
 web e siano il più intuitivi possibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[When(@"navigo verso ""(.*)""")]
\end_layout

\begin_layout Plain Layout

public void QuandoNavigoVerso(string pageName){
\end_layout

\begin_layout Plain Layout

	Assert.True(browser.FindLink(pageName).Exists());             	browser.ClickLink(pa
geName);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:Coypu Click"

\end_inset

Navigazione tramite un collegamento in Coypu.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inoltre Coypu organizza la libreria in maniera che le funzionalità utilizzate
 di frequente siano facilmente accessibili.
 Ad esempio per utilizzare un collegamento presente nella pagina per navigare
 all'interno del sito è sufficiente utilizzare il metodo 
\begin_inset Quotes eld
\end_inset

ClickLink
\begin_inset Quotes erd
\end_inset

 esistente all'interno della classe 
\begin_inset Quotes eld
\end_inset

BrowserWindow
\begin_inset Quotes erd
\end_inset

 che rappresenta la sessione di navigazione ed è quindi già istanziata al
 momento dell'esecuzione dei test, come illustrato in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Coypu Click"

\end_inset

.
\end_layout

\begin_layout Standard
Inoltre il metodo 
\begin_inset Quotes eld
\end_inset

ClickLink
\begin_inset Quotes erd
\end_inset

 effettua il click dell'elemento in funzione del testo che appare e non
 di un selettore CSS o XPath, facilitando la definizione di test che mantengono
 la stessa prospettiva di un utente.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

FindLink
\begin_inset Quotes erd
\end_inset

 permette la ricerca all'interno di un DOM di un collegamento in funzione
 del testo fornito come parametro.
 Il metodo restituisce un'istanza di 
\begin_inset Quotes eld
\end_inset

ElementScope
\begin_inset Quotes erd
\end_inset

 che rappresenta un tag presente nel DOM In maniera simile a Capybara, sono
 presenti numerose proprietà per ottenere informazioni sull'elemento ed
 i metodi per eseguire le azioni.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Al fine di semplificare la definizione dei test, Coypu include in tutte
 le funzionalità che analizzano il DOM un meccanismo di attesa implicito.
 Assumere che ogni elemento possa essere il risultato di un'operazione asincrona
, permette all'utente di definire test più semplici e mantenibili.
 Come definito nel metodo 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Creazione-della-sessione."

\end_inset

, che rappresenta la creazione e configurazione di una nuova sessione per
 la verifica di uno scenario, è possibile impostare sia il valore di attesa
 massimo che la frequenza di polling desiderata.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una carenza riscontrata nelle prime fasi di sviluppo è l'assenza di documentazio
ne soddisfacente.
 Nonostante in Coypu sia facile intuire il funzionamento della libreria
 leggendo la segnatura dei metodi, la definizione di qualche esempio ne
 semplificherebbe l'utilizzo.
\end_layout

\begin_layout Paragraph
Definire asserzioni con NUnit
\end_layout

\begin_layout Standard
NUnit è una libreria per la definizione di unit-test in C# nata dal porting
 di JUnit, attualmente alla versione 2.6 e il cui sviluppo è svolto in maniera
 separata dalla versione Java.
\end_layout

\begin_layout Standard
Nonostante i due progetti non siano più sviluppati dallo stesso team, utilizzand
o le asserzioni di NUnit è facile riconoscere l'origine comune.
 Ad esempio nel successivo passo in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:NUnit-AreEqual"

\end_inset

, sono utilizzati i metodi 
\begin_inset Quotes eld
\end_inset

AssertThat
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

AreEqual
\begin_inset Quotes erd
\end_inset

, che rispettivamente verificano la presenza di un elemento con identificatore
 HTML 
\begin_inset Quotes eld
\end_inset

logo
\begin_inset Quotes erd
\end_inset

 ed effettuano un confronto sul titolo della pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Then(@"posso tornare alla pagina iniziale")]
\end_layout

\begin_layout Plain Layout

public void AlloraPossoTornareAllaPaginaIniziale(){
\end_layout

\begin_layout Plain Layout

	var logoLink = browser.FindId("logo");
\end_layout

\begin_layout Plain Layout

	Assert.That(logoLink.Exists());
\end_layout

\begin_layout Plain Layout

	logoLink.Click();
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("CSBlog", browser.Title);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout

\begin_inset CommandInset label
LatexCommand label
name "lis:NUnit-AreEqual"

\end_inset

NUnit AreEqual
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uno degli obbiettivi degli autori di NUnit è di definire dei metodi che,
 attraverso la propria segnatura, descrivano il proprio funzionamento e
 siano facilmente leggibili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Assert.That(myString, Is.EqualTo("Hello"));
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:EqualTo"

\end_inset

Un possibile uso dell'asserzione 
\begin_inset Quotes eld
\end_inset

That
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo 
\begin_inset Quotes eld
\end_inset

That
\begin_inset Quotes erd
\end_inset

 nell'esempio in listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:EqualTo"

\end_inset

, è utilizzato per verificare un valore booleano, in generale però è utilizzato
 per la sua caratteristica di accettare parametri 
\begin_inset Quotes eld
\end_inset

IConstraint
\begin_inset Quotes erd
\end_inset

.
 Questa interfaccia definisce un insieme di metodi per rappresentare una
 condizione e, oltre alle classi di vincoli fornite dalla libreria come
 mostrato nell'esempio, permette la definizione di vincoli personalizzati.
 In Coypu è presente una classe 
\begin_inset Quotes eld
\end_inset

Shows
\begin_inset Quotes erd
\end_inset

 che implementa diverse condizioni e aumenta la leggibilità delle asserzioni,
 come si può vedere in listato .
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Assert.That(footer, Shows.Css("img"));
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Shows"

\end_inset

Uso del tipo 
\begin_inset Quotes eld
\end_inset

Shows
\begin_inset Quotes erd
\end_inset

 di Coypu.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduzione del CSS
\end_layout

\begin_layout Standard
I metodi presenti nella libreria di Coypu non includono le funzionalità
 per leggere le proprietà di stile degli elementi presenti nel DOM di una
 pagina.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Feature: Introducendo il CSS
\end_layout

\begin_layout Plain Layout

Per rendere l'esperienza di navigazione gradevole
\end_layout

\begin_layout Plain Layout

Come Lettore
\end_layout

\begin_layout Plain Layout

Vorrei che il sito esponesse una grafica omogenea
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:02x00 Introducendo il CSS"

\end_inset

Seconda funzionalità per CSBlog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella funzionalità corrente dovrebbero essere verificati alcuni scenari
 relativi all'aspetto della pagina, in particolare gli effetti cromatici
 descritti nei precedenti capitoli e altre proprietà legate alla corretta
 visualizzazione degli elementi.
\end_layout

\begin_layout Standard
Nonostante gli sforzi dell'autore e degli sviluppatori, che frequentemente
 propongono le loro pull-request su GitHub, Coypu non può mantenere il livello
 di sviluppo di Selenium.
 Per fornire comunque pieno supporto ai propri utenti è possibile sfruttare
 la libreria nativa, utilizzata dalle stesse funzionalità di Coypu, come
 mostrato nel passo del listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Uso-delle-funzionalità"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"l'intestazione ha un colore di sfondo")]
\end_layout

\begin_layout Plain Layout

public void DatoLIntestazioneHaUnColoreDiSfondo(){
\end_layout

\begin_layout Plain Layout

	var selenium = ((OpenQA.Selenium.Remote.RemoteWebDriver)browser.Native);
\end_layout

\begin_layout Plain Layout

	var color = selenium.FindElementById("header").GetCssValue("background-color");
\end_layout

\begin_layout Plain Layout

	Assert.NotNull(color);
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual("rgba(46, 47, 48, 1)", color);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Uso-delle-funzionalità"

\end_inset

Uso delle funzionalità native di Selenium.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel metodo è descritto l'utilizzo delle funzionalità di Selenium ed in particola
re l'invocazione del metodo 
\begin_inset Quotes eld
\end_inset

GetCssValue
\begin_inset Quotes erd
\end_inset

 per ottenere la rappresentazione 
\begin_inset Quotes eld
\end_inset

rgba
\begin_inset Quotes erd
\end_inset

 del colore di sfondo dell'intestazione.
\end_layout

\begin_layout Standard
La versione per C# di Selenium è estremamente simile a quella per Java,
 sintassi permettendo; per questo motivo non è stata completata l'implementazion
e degli scenari per la funzionalità corrente.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Definizione del modello
\end_layout

\begin_layout Standard
Nella sezione sono descritte le componenti di MVC5 che permettono la gestione
 delle entità attraverso CSBlog e lo sviluppo dei relativi test di accettazione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Gestione dei post
\end_layout

\begin_layout Plain Layout

	Come Autore
\end_layout

\begin_layout Plain Layout

	Vorrei poter inserire, leggere, modificare e rimuovere dei post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter documentare la tesi
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:03x00 Modello"

\end_inset

Funzionalità dell'iterazione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dipendenze
\end_layout

\begin_layout Standard
Anche per i test in CSBlog è necessario provvedere alla regressione del
 modello, rimuovendo dal database le entità create per verificare uno scenario.
 Come descritto nelle sezioni precedenti, con Specflow e Coypu sono stati
 definiti due hook per la creazione e rilascio della sessione del browser,
 che assicurano l'esecuzione dei test in nuove finestre e la rimozione di
 ogni cookie e sessione HTTP relativi a precedenti azioni.
\end_layout

\begin_layout Standard
Per completare il processo di regressione è necessario provvedere a rimuovere
 anche eventuali post creati negli scenari.
 La libreria di testing prevede l'utilizzo del tag 
\begin_inset Quotes eld
\end_inset

@clear
\begin_inset Quotes erd
\end_inset

 per individuare le funzionalità o gli scenari che introducono ma non eliminano
 nuovi contenuti sul blog.
\end_layout

\begin_layout Standard
Nel successivo listato è mostrato l'intera callback eseguita alla conclusione
 degli scenari, indipendentemente dal risultato delle asserzioni.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[AfterScenario]
\end_layout

\begin_layout Plain Layout

public void AfterScenario(){
\end_layout

\begin_layout Plain Layout

	if(ScenarioContext.Current.ScenarioInfo.Tags.Contains("clear") || FeatureContext.Cur
rent.FeatureInfo.Tags.Contains("clear")){
\end_layout

\begin_layout Plain Layout

		login();
\end_layout

\begin_layout Plain Layout

		string LoremIpsumTitle = "Lorem Ipsum";
\end_layout

\begin_layout Plain Layout

		string xpathQuery = String.Format("//div[@class = 'post'][p/a[contains(text(),'
{0}')]]", LoremIpsumTitle);
\end_layout

\begin_layout Plain Layout

		browser.Visit("/");
\end_layout

\begin_layout Plain Layout

		foreach (var post in browser.FindAllXPath(xpathQuery)) {
\end_layout

\begin_layout Plain Layout

			post.FindCss(".remove_post_button").Click();
\end_layout

\begin_layout Plain Layout

			browser.ClickButton("Confermi la rimozione?");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	_browser.Dispose();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Callback relativa alla terminazione degli scenari.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'attributo 
\begin_inset Quotes eld
\end_inset

AfterScenario
\begin_inset Quotes erd
\end_inset

 accetta come parametri un numero variabile di stringhe rappresentanti i
 tag per specificare per quali scenari debba essere eseguito il metodo.
 In Cucumber l'ordine di esecuzione degli hook coincide con l'ordine di
 registrazione dei metodi, mentre in Cucumber-JVM, che sfrutta il meccanismo
 delle annotazioni, è possibile definire un attributo per indicare la priorità
 di ciascuna callback.
\end_layout

\begin_layout Standard
Al contrario in Specflow, non è possibile specificare alcun ordinamento
 ed invece di definire due callback, rispettivamente per la rimozione di
 eventuali post presenti nel blog e la conclusione della sessione di test,
 è necessario all'interno di un generico hook verificare manualmente la
 presenza del tag 
\begin_inset Quotes eld
\end_inset

@clear
\begin_inset Quotes erd
\end_inset

 per la funzionalità o lo scenario corrente ed eventualmente effettuare
 la rimozione dei post.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per implementare gli hook in SpecFlow è necessario utilizzare gli attributi
 per associare le callback agli eventi e implementare i metodi all'interno
 di classi annotate con l'attributo 
\begin_inset Quotes eld
\end_inset

Binding
\begin_inset Quotes erd
\end_inset

, come per la definizione delle classi contenenti i passi.
\end_layout

\begin_layout Subsection
Gestione dei form
\end_layout

\begin_layout Standard
Nella sottosezione corrente è descritta l'implementazione delle componenti
 necessarie per l'implementare le funzionalità per la creazione di un nuovo
 post.
 Come specificato nell'introduzione, VS permette la generazione dei controlli,
 attraverso un wizard di configurazione, e delle viste corrispondenti.
\end_layout

\begin_layout Standard
Lo sviluppo si è svolto in maniera veloce, se paragonato a Spring, potendo
 sfruttare una struttura già esistente e dovendo esclusivamente personalizzarne
 il comportamento.
\end_layout

\begin_layout Subsubsection*
I controlli
\end_layout

\begin_layout Standard
Ad ogni componente è associato un controllo ed una collezione di azioni
 eseguibili, nei seguenti frammenti di codice sono mostrate le implementazione
 delle azioni per la creazione dei post.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class PostController : Controller { 	private CSBlogEntities db =
 new CSBlogEntities();
\end_layout

\begin_layout Plain Layout

	public ActionResult Create(){
\end_layout

\begin_layout Plain Layout

		if (!isAuthorized())
\end_layout

\begin_layout Plain Layout

			return redirectToLoginPage();
\end_layout

\begin_layout Plain Layout

		return View();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	/*..*/
\begin_inset Caption Standard

\begin_layout Plain Layout
Frammento di codice contente l'azione 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 per la visualizzazione della relativa vista.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come in RoR, sono presenti due metodi 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 per disaccoppiare la gestione della vista per la creazione di un nuovo
 post e la gestione della persistenza dell'oggetto definito attraverso l'interfa
ccia dell'applicazione nel modello.
\end_layout

\begin_layout Standard
Il ritorno di tipo 
\begin_inset Quotes eld
\end_inset

View
\begin_inset Quotes erd
\end_inset

, istanziato senza specificare parametri, risolve la richiesta visualizzando
 la vista 
\begin_inset Quotes eld
\end_inset

/Post/Create.cshtml
\begin_inset Quotes erd
\end_inset

, il cui nome coincide con l'identificatore dell'azione.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// POST: /Post/Create
\end_layout

\begin_layout Plain Layout

[HttpPost]
\end_layout

\begin_layout Plain Layout

[ValidateAntiForgeryToken]
\end_layout

\begin_layout Plain Layout

public ActionResult Create([Bind(Include = "title,body")] Post post){
\end_layout

\begin_layout Plain Layout

	if (!isAuthorized())
\end_layout

\begin_layout Plain Layout

		return redirectToLoginPage();
\end_layout

\begin_layout Plain Layout

	if (ModelState.IsValid){
\end_layout

\begin_layout Plain Layout

		post.id = Guid.NewGuid();
\end_layout

\begin_layout Plain Layout

		post.createdAt = post.updatedAt = DateTime.Now;
\end_layout

\begin_layout Plain Layout

		post.authorId = (Guid)Session["author_id"];
\end_layout

\begin_layout Plain Layout

		db.Posts.Add(post);
\end_layout

\begin_layout Plain Layout

		db.SaveChanges();
\end_layout

\begin_layout Plain Layout

		TempData["notice"] = String.Format("Il post '{0}' è stato creato con successo.",
 post.title);
\end_layout

\begin_layout Plain Layout

		return RedirectToAction("Details", new { post.id });
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return View(post);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:MVC5 Azione Persistenza Create"

\end_inset

Frammento di codice contente l'azione 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 persistenza del nuovo oggetto creato.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante la creazione di nuovi post sia stata suddivisa in due azioni,
 il metodo 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 è piuttosto articolato.
 Di seguito sono descritte le principali funzionalità:
\end_layout

\begin_layout Itemize
l'espressione booleana 
\begin_inset Quotes eld
\end_inset

ModelState.IsValid
\begin_inset Quotes erd
\end_inset

 verifica che i vincoli definiti a livello di logica dell'entità siano soddisfat
ti e si possa procedere nell'esecuzione delle istruzione per rendere persistenti
 i dati inseriti dall'utente;
\end_layout

\begin_layout Itemize
l'attributo 
\begin_inset Quotes eld
\end_inset

ValidateAntiForgeryToken
\begin_inset Quotes erd
\end_inset

 protegge l'applicazione, ed in particolare le pagine che permettono la
 definizione di nuovi contenuti, da attacchi di over-posting e dalla forgiatura
 di richieste cross-site.
 Il processo per implementare la sicurezza dei form è abbastanza semplice
 e consiste con la generazione di un valore unico all'interno del form durante
 la visita della pagina e la copia del valore all'interno di un cookie HTTP
 creato ad-hoc, al momento dell'invio dei dati inseriti è verificato da
 MVC5 l'uguaglianza dei due valori eventualmente permettendo l'operazione;
\end_layout

\begin_layout Itemize
l'attributo 
\begin_inset Quotes eld
\end_inset

Bind
\begin_inset Quotes erd
\end_inset

 del parametro 
\begin_inset Quotes eld
\end_inset

post
\begin_inset Quotes erd
\end_inset

 specifica quali campi del form devono essere utilizzati per inizializzare
 l'oggetto, gli attributi della classe 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 comprendono anche altre informazioni che sono però inizializzate secondo
 la logica dell'applicazione;
\end_layout

\begin_layout Itemize
la proprietà 
\begin_inset Quotes eld
\end_inset

Session
\begin_inset Quotes erd
\end_inset

 permette l'accesso ai valori presenti nella corrente sessione HTTP,
\begin_inset space ~
\end_inset

in cui è mantenuto un riferimento all'identificatore dell'utente che ha
 effettuato l'autenticazione;
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

db.Posts.Add
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

db.SaveChanges
\begin_inset Quotes erd
\end_inset

 aggiungono l'oggetto al modello ed effettuano la persistenza delle modifiche.
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

RedirectToAction
\begin_inset Quotes erd
\end_inset

 restituisce un'istanza di tipo 
\begin_inset Quotes eld
\end_inset

RedirectToRouteResult
\begin_inset Quotes erd
\end_inset

 per effettuare la ridirezione della richiesta dopo aver creato il post.
 Combinando l'uso della ridirezione con il dizionario 
\begin_inset Quotes eld
\end_inset

TempData
\begin_inset Quotes erd
\end_inset

 è possibile fornire alla vista, che verrà visualizzata al termine dell'azione
 corrente, delle espressioni il cui valore sarà mantenuto per una sola richiesta
 HTTP all'interno della sessione;
\end_layout

\begin_layout Itemize
Nel caso in cui la validazione degli attributi del post non sia andata a
 buon fine, il post restituisce un riferimento alla vista 
\begin_inset Quotes eld
\end_inset

Create
\begin_inset Quotes erd
\end_inset

 fornendo lo stesso parametro ricevuto in input per inizializzare i campi
 del form;
\end_layout

\begin_layout Standard
Come in Spring, in cui è possibile sfruttare i parametri di tipo 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

 per passare degli oggetti alla vista, in MVC5 è disponibile la proprietà
 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

ViewBag
\begin_inset Quotes erd
\end_inset

 presente nella super classe 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

.
 Il tipo 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

 in C# posticipa le operazioni di type-checking normalmente eseguite a compile
 time al momento dell'esecuzione, semplificando l'utilizzo delle proprietà
 come in questo caso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ViewBag.message = "Hello ViewBag";
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Esempio di utilizzo della proprietà 
\begin_inset Quotes eld
\end_inset

ViewBag
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel listato è inizializzato con una stringa l'attributo dinamico 
\begin_inset Quotes eld
\end_inset

message
\begin_inset Quotes erd
\end_inset

, che sarà utilizzabile nelle viste in Razor.
\end_layout

\begin_layout Subsubsection*
Le viste
\end_layout

\begin_layout Standard
Dopo aver mostrato i controlli per la creazione di nuovi post, è ora descritta
 la vista per la creazione di nuovi post.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@model Blog.Models.Post
\end_layout

\begin_layout Plain Layout

@{
\end_layout

\begin_layout Plain Layout

	ViewBag.PageTitle = ViewBag.Title = "Crea un post";
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@using (Html.BeginForm()){
\end_layout

\begin_layout Plain Layout

@Html.AntiForgeryToken()
\end_layout

\begin_layout Plain Layout

<div class="form-horizontal">
\end_layout

\begin_layout Plain Layout

	@Html.ValidationSummary(true)
\end_layout

\begin_layout Plain Layout

	<div class="form_actions">
\end_layout

\begin_layout Plain Layout

		<input alt="Scrivi un nuovo post" id="submit" src="@Url.Content("~/Images/save_
48.png")"                    type="image" value="Create" />
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

	<p id="form_title">
\end_layout

\begin_layout Plain Layout

		Scrivi un nuovo post
\end_layout

\begin_layout Plain Layout

	</p>
\end_layout

\begin_layout Plain Layout

	<div class="form-group">
\end_layout

\begin_layout Plain Layout

		@Html.LabelFor(model => model.title, new { @class = "control-label" })
\end_layout

\begin_layout Plain Layout

		<div>
\end_layout

\begin_layout Plain Layout

			@Html.EditorFor(model => model.title)
\end_layout

\begin_layout Plain Layout

			<div class="error_explanation">
\end_layout

\begin_layout Plain Layout

				@Html.ValidationMessageFor(model => model.title)
\end_layout

\begin_layout Plain Layout

			</div>
\end_layout

\begin_layout Plain Layout

		</div>
\end_layout

\begin_layout Plain Layout

	</div>
\end_layout

\begin_layout Plain Layout

	<!-- ..
 -->
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In MVC, tramite le funzionalità di Razor è possibile tipare le proprie viste
 indicando, tramite la sintassi 
\begin_inset Quotes eld
\end_inset

@model
\begin_inset Quotes erd
\end_inset

, quale l'entità rappresentata dalla pagina corrente.
 Nella classe 
\begin_inset Quotes eld
\end_inset

Controller
\begin_inset Quotes erd
\end_inset

 sono presenti le funzionalità per istanziare degli oggetti di tipo 
\begin_inset Quotes eld
\end_inset

ViewResult
\begin_inset Quotes erd
\end_inset

 fornendo un istanza di 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

 che rappresenterà il modello, come mostrato nel listato 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:MVC5 Azione Persistenza Create"

\end_inset

 in caso di fallimento della validazione.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nella vista sono utilizzate diverse funzionalità di Razor:
\end_layout

\begin_layout Itemize
nella parte iniziale della vista sono inizializzati alcuni valori della
 proprietà 
\begin_inset Quotes eld
\end_inset

ViewBag
\begin_inset Quotes erd
\end_inset

 utilizzati all'interno della vista rappresentante il layout per impostare
 il titolo della pagina e dell'intestazione di CSBlog;
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

BeginForm
\begin_inset Quotes erd
\end_inset

, della classe 
\begin_inset Quotes eld
\end_inset

FormExtensions
\begin_inset Quotes erd
\end_inset

 di Razor, genera il codice HTML relativo all'elemento 
\begin_inset Quotes eld
\end_inset

form
\begin_inset Quotes erd
\end_inset

 e permette di utilizzare altri metodi per la definizione delle varie componenti
 del form;
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

ValidationSummary
\begin_inset Quotes erd
\end_inset

 restituisce le informazioni sulla validazione, nel caso in cui la vista
 attuale sia visualizzata come conseguenza del fallimento delle operazioni
 di persistenza;
\end_layout

\begin_layout Itemize
i metodi 
\begin_inset Quotes eld
\end_inset

LabelFor
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

EditorFor
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

TextAreaFor
\begin_inset Quotes erd
\end_inset

 generano gli elementi di input del form e i relativi 
\begin_inset Quotes eld
\end_inset

label
\begin_inset Quotes erd
\end_inset

 HTML;
\end_layout

\begin_layout Itemize
il metodo 
\begin_inset Quotes eld
\end_inset

ValidationMessageFor
\begin_inset Quotes erd
\end_inset

 ritorna i messaggi d'errore che descrivono i problemi riscontrati durante
 la validazione dell'entità, opportunamente formattati in HTML;
\end_layout

\begin_layout Subsubsection*
Gestione degli errori nei form
\end_layout

\begin_layout Standard
Utilizzando gli attributi dell'EF è possibile definire dei vincoli sugli
 attributi delle entità.
 Nel successivo listato è mostrato un frammento di codice relativo alla
 proprietà 
\begin_inset Quotes eld
\end_inset

title
\begin_inset Quotes erd
\end_inset

 dell'entità 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Required(ErrorMessage = "Titolo mancante.")]
\end_layout

\begin_layout Plain Layout

[StringLength(100, MinimumLength = 5, ErrorMessage = "Il titolo deve essere
 compreso fra 5 e 100 caratteri.")]
\end_layout

\begin_layout Plain Layout

[Remote("CheckForDuplication", "Post", AdditionalFields = "id")]
\end_layout

\begin_layout Plain Layout

[Display(Name = "Titolo", Description = "Inserisci in questo campo il titolo
 che vuoi dare al tuo articolo.")]
\end_layout

\begin_layout Plain Layout

public string title { get; set; }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gli attributi 
\begin_inset Quotes eld
\end_inset

Required
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

StringLength
\begin_inset Quotes erd
\end_inset

 effettuano la verifica del valore della stringa e invalidano l'oggetto
 nel caso il titolo sia mancante, troppo corto o troppo lungo; è anche possibile
 associare a ciascun attributo un messaggio d'errore personalizzato che
 rappresenta il testo mostrato all'interno della vista.
\end_layout

\begin_layout Standard
Per effettuare operazioni di validazione come la verifica d'unicità del
 titolo, non è possibile sfruttare gli attributi già definiti in EF.
 Per verificare la presenza di altri post con il titolo simile all'interno
 del blog è effettuata una richiesta HTTP asincrona tramite JQuery, definita
 tramite l'attributo 
\begin_inset Quotes eld
\end_inset

Remote
\begin_inset Quotes erd
\end_inset

 ed i parametri 
\begin_inset Quotes eld
\end_inset

CheckForDuplication
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

Post
\begin_inset Quotes erd
\end_inset

 e 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 che rispettivamente rappresentano l'azione e il controllo che gestiranno
 la richiesta e il parametro aggiuntivo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
La verifica dell'unicità del titolo del post è effettuata sia alla creazione
 che alla modifica di un post, il parametro aggiuntivo 
\begin_inset Quotes eld
\end_inset

id
\begin_inset Quotes erd
\end_inset

 può assumere valore nullo ed è utilizzato per associare il titolo ad un
 eventuale post esistente.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Nel listato successivo, utilizzando LINQ per accedere al modello e JSon
 per definire il risultato dell'azione, è verificato in funzione dei parametri
 la presenza di eventuali post con titolo simili.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[HttpGet]
\end_layout

\begin_layout Plain Layout

public JsonResult CheckForDuplication(Guid? id, string title){
\end_layout

\begin_layout Plain Layout

	var post = db.Posts.Where(p => p.title.Equals(title, StringComparison.CurrentCulture
IgnoreCase)).FirstOrDefault();
\end_layout

\begin_layout Plain Layout

	if (post != null && (id == null || !post.id.Equals(id)))
\end_layout

\begin_layout Plain Layout

		return Json("Il titolo è già presente.", JsonRequestBehavior.AllowGet);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return Json(true, JsonRequestBehavior.AllowGet);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Azione per la verifica dell'unicità del titolo dei post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
L'azione restituisce un valore serializzato tramite JSon, una stringa contenente
 il messaggio in caso di fallimento della validazione, oppure il valore
 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 se il titolo è utilizzabile.
\end_layout

\begin_layout Subsubsection*
Implementazione dei test
\end_layout

\begin_layout Standard
Oltre alle funzionalità per la navigazione, la classe 
\begin_inset Quotes eld
\end_inset

BrowserSession
\begin_inset Quotes erd
\end_inset

 di Coypu fornisce le funzionalità per la gestione dei form e la selezione
 degli elementi del DOM in funzione del tipo e del testo mostrato.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

[When(@"mi autentico come ""(.*)""")]
\end_layout

\begin_layout Plain Layout

public void DatoMiAutenticoCome(string email){
\end_layout

\begin_layout Plain Layout

	string password = "password";
\end_layout

\begin_layout Plain Layout

	browser.ClickLink("Login");
\end_layout

\begin_layout Plain Layout

	browser.FillIn("Email").With(email);
\end_layout

\begin_layout Plain Layout

	browser.FillIn("Password").With(password);
\end_layout

\begin_layout Plain Layout

	browser.ClickButton("Login");
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Login su CSBlog tramite Coypu.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rispetto a Selenium, il DSL di Coypu è più semplice e facilmente utilizzabile;
 inoltre è evidente la propensione della libreria a favorire la definizione
 di selettori in funzione del testo mostrato dai vari elementi.
\end_layout

\begin_layout Standard
Queste pratiche permettono la definizione di test leggibili e di semplice
 comprensione, semplificando la manutenzione del codice.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

protected ElementScope findPostByTitle(String title) {
\end_layout

\begin_layout Plain Layout

	return browser.FindAllCss(".post").First(p => p.FindLink(title, new Options
 { TextPrecision = TextPrecision.Substring }).Exists());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Definizione di un selettore tramite i metodi di Coypu.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il metodo del listato precedente definisce una funzionalità ausiliaria per
 ricercare all'interno del DOM un post, contenuto all'interno di un 
\begin_inset Quotes eld
\end_inset

div
\begin_inset Quotes erd
\end_inset

 con attributo di 
\begin_inset Quotes eld
\end_inset

class
\begin_inset Quotes erd
\end_inset

 uguale a 
\begin_inset Quotes eld
\end_inset

post
\begin_inset Quotes erd
\end_inset

, il cui titolo, rappresentato da un collegamento, contenga parte del testo
 indicato dal parametro.
\end_layout

\begin_layout Standard
Il metodo è una funzionalità utile per individuare il l'elemento HTML che
 contiene le informazioni visualizzate per un certo post, il cui risultato
 è utilizzato per effettuare ulteriori accessi all'HTML interno.
\end_layout

\begin_layout Standard
Nelle versioni in Ruby e Java, lo stesso metodo è stato definito utilizzando
 un selettore ed un'espressione XPath.
 Con Coypu e le funzionalità dell'interfaccia 
\begin_inset Quotes eld
\end_inset

IEnumerable
\begin_inset Quotes erd
\end_inset

, che permettono l'uso di funzioni, è possibile definire query articolate
 ma allo stesso tempo comprensibili.
 Inoltre la definizione di selettori attraverso una concatenazione di metodi
 riduce la fragilità dei metodi semplificando le manutenibilità del codice
 e permette la verifica durante la compilazione rispetto ad una query XPath
 rappresentata in una stringa.
\end_layout

\begin_layout Subsubsection*
Selettori
\end_layout

\begin_layout Standard
In Coypu sono implementati una buona varietà di metodi per l'implementazione
 di funzionalità per la definizione di selettori ed in generale effettuare
 ricerche all'interno del DOM.
 Oltre i metodi specifici per un tipo di elemento, come 
\begin_inset Quotes eld
\end_inset

FindLink
\begin_inset Quotes erd
\end_inset

 già mostrato in precedenza, sono presenti anche funzionalità più simili
 a quelle viste per Selenium.
\end_layout

\begin_layout Standard
Di seguito sono proposti alcuni esempi e frammenti dei passi contenti alcuni
 dei metodi esistenti nella libreria.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

browser.FindCss(".post_title a", text: title).Exists();
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Esempio del metodo 
\begin_inset Quotes eld
\end_inset

FindCss
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In maniera simile a Capybara, ed in particolare ai metodi del modulo 
\begin_inset Quotes eld
\end_inset

Finders
\begin_inset Quotes erd
\end_inset

, nel metodo 
\begin_inset Quotes eld
\end_inset

FindCSS
\begin_inset Quotes erd
\end_inset

 è possibile specificare delle stringhe o delle espressioni regolari oltre
 alle regole del CSS.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

protected ElementScope header {get{return browser.FindId("header");}}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Esempio del metodo 
\begin_inset Quotes eld
\end_inset

FindId
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oltre alle funzionalità classiche delle librerie di automazione web, come
 il metodo 
\begin_inset Quotes eld
\end_inset

FindId
\begin_inset Quotes erd
\end_inset

, Coypu cerca di fornire delle funzionalità ulteriori tramite parametri
 opzionali o implementando metodi derivati come 
\begin_inset Quotes eld
\end_inset

FindIdEndingWith
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void DatoIlPostNonELeggibileSuCSBlog(string title){
\end_layout

\begin_layout Plain Layout

	browser.Visit("/");
\end_layout

\begin_layout Plain Layout

	var posts = browser.FindAllCss(".post");
\end_layout

\begin_layout Plain Layout

	foreach (var post in posts) {
\end_layout

\begin_layout Plain Layout

		Assert.That(!post.FindLink(title).Exists());
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Esempio del metodo 
\begin_inset Quotes eld
\end_inset

FindAllCss
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A differenza di Capybara, Coypu non restituisce errore nel caso in cui la
 venga utilizzato un metodo per individuare un singolo elemento ed al contrario
 siano presenti più potenziali risultati, ma restituisce il primo elemento
 incontrato.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Per gestire collezioni di elementi sono disponibili metodi come 
\begin_inset Quotes eld
\end_inset

FindAllCss
\begin_inset Quotes erd
\end_inset

; rispetto ai metodi che restituiscono un singolo risultato, i metodi che
 ricercano tutti i potenziali riscontri all'interno della pagina non applicano
 strategie di attesa per eventuali elementi asincroni, bensì restituiscono
 la collezione di elementi presenti al momento dell'invocazione; per modificare
 il comportamento è possibile definire un predicato per descrivere lo stato
 atteso.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Then(@"l_intestazione è posizionata all_inizio")]
\end_layout

\begin_layout Plain Layout

public void AlloraLInizio(){
\end_layout

\begin_layout Plain Layout

	var first = browser.FindXPath("//body/*[1]");
\end_layout

\begin_layout Plain Layout

	Assert.True(first.Exists());
\end_layout

\begin_layout Plain Layout

	Assert.True(header.Exists());
\end_layout

\begin_layout Plain Layout

	Assert.AreEqual(first.Id, header.Id);
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Esempio del metodo 
\begin_inset Quotes eld
\end_inset

FindXPath
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante la libreria propenda per l'utilizzo di funzionalità ad alto livello,
 per favorire la leggibilità dei test, è anche possibile definire i seletori
 tramite espressioni XPath.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

protected ElementScope FindNotice(string noticeMessage){
\end_layout

\begin_layout Plain Layout

	var notice = browser.FindId("notice", new Options { TextPrecision= TextPrecision.
Exact});
\end_layout

\begin_layout Plain Layout

	Assert.That(notice.Exists());
\end_layout

\begin_layout Plain Layout

	return notice;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In alcune parti della libreria si può notare la forte ispirazione che Capybara
 ha dato al progetto, ad esempio i metodi permettono l'uso di un parametro
 
\begin_inset Quotes eld
\end_inset

Options,
\begin_inset Quotes erd
\end_inset

 che ricorda l'uso del dizionario come parametro opzionale in Ruby.
\end_layout

\begin_layout Standard
Le istanze della classe 
\begin_inset Quotes eld
\end_inset

Options
\begin_inset Quotes erd
\end_inset

 permettono di modificare il comportamento dei metodi, specificando la strategia
 di attesa e di polling, il tipo di confronto sulle stringhe da utilizzare,
 la cardinalità attesa e molti altri parametri.
\end_layout

\begin_layout Subsection
Debug con Specflow
\end_layout

\begin_layout Standard
Durante lo sviluppo di CSBlog con VS sono state individuate alcune difficoltà
 nell'applicare la tecnica dell'ATDD a causa dell'impossibilità di eseguire
 il debug dei test.
 All'interno dell'ambiente di sviluppo è possibile eseguire la propria applicazi
one sia in modalità debug classica, in cui VS monitora l'esecuzione ed eventualm
ente gestisce e segnala gli errori, oppure è possibile procedere all'esecuzione
 semplice.
\end_layout

\begin_layout Standard
Dai tentativi fatti su VS, per qualsiasi sia il tipo di esecuzione dell'applicaz
ione sembra che non sia possibile eseguire i propri test di accettazione
 in modalità debug, perché è consentito che venga eseguito al più un solo
 processo per ogni istanza di VS.
\end_layout

\begin_layout Standard
Creando un secondo progetto contenente esclusivamente i test ed aprendo
 due istanze di VS, una per lo sviluppo ed una per il testing, si dovrebbe
 evitare i conflitti durante l'esecuzione, introducendo però possibili rallentam
enti nel sistema.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Login & Autorizzazione
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap6
\end_layout

\begin_layout Plain Layout

Funzionalità: Autenticazione su SBlog
\end_layout

\begin_layout Plain Layout

	Come Autore di SBlog
\end_layout

\begin_layout Plain Layout

	Vorrei che alcune operazioni sensibili siano permesse previa autenticazione
\end_layout

\begin_layout Plain Layout

	Per poter garantire l'autenticità dei contenuti
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Autenticazione in CSBlog.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come per le funzionalità riguardanti l'analisi del CSS e delle proprietà
 estetiche dei nodi dell'HTML, Coypu non implementa metodi specifici per
 la gestione dei cookie e delle sessioni.
\end_layout

\begin_layout Standard
E' comunque possibile utilizzare le funzionalità native per effettuare operazion
i sui cookie e le sessioni HTTP come già descritto nel capitolo su SBlog.
\end_layout

\begin_layout Subsection
Accesso ai singoli attributi
\end_layout

\begin_layout Standard
La classe 
\begin_inset Quotes eld
\end_inset

ElementScope
\begin_inset Quotes erd
\end_inset

 di Coypu ridefinisce il comportamento dell'operatore 
\begin_inset Quotes eld
\end_inset

[ ]
\begin_inset Quotes erd
\end_inset

: come in Capybara, è possibile accedere alle singole proprietà indicando
 tramite una stringa l'identificatore desiderato.
 Accedere alle proprietà di un elemento HTML come se fosse un array associativo
 presenta alcuni vantaggi: la sintassi è facilmente leggibile e comprensibile,
 inoltre, dal punto di vista dell'implementazione, è facilmente estendibile
 nel caso il W3C prevedesse delle variazioni nell'HTML, come è ad esempio
 accaduto per la versione HTML5.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Asincronia
\end_layout

\begin_layout Standard
Coypu gestisce gli elementi della pagina con lo stesso principio di Capybara,
 ogni elemento può potenzialmente essere asincrono, preferendo la definizione
 di una strategia di ricerca globale tramite attese e polling rispetto alla
 definizione di asserzioni sullo stato degli elementi, perché difficili
 da esprimere, implementare e mantenere.
\end_layout

\begin_layout Subsection
JavaScript
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Funzionalità: Easter Egging
\end_layout

\begin_layout Plain Layout

	Come Sviluppatore
\end_layout

\begin_layout Plain Layout

	Vorrei che nel blog fosse presente un mio logo
\end_layout

\begin_layout Plain Layout

	Per firmare il mio lavoro
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Contesto:
\end_layout

\begin_layout Plain Layout

	Dato apro CSBlog
\end_layout

\begin_layout Plain Layout

  Scenario: EasterEgg
\end_layout

\begin_layout Plain Layout

	Dato non è presente il logo nell'intestazione
\end_layout

\begin_layout Plain Layout

	Quando clicco sull'area del pié di pagina
\end_layout

\begin_layout Plain Layout

	Allora è presente il logo
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:05bx00 EasterEgg"

\end_inset

Introduzione di un breve script Javascript.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nei successi listati è mostrata l'implementazione dello scenario 
\begin_inset Quotes eld
\end_inset

EasterEgg
\begin_inset Quotes erd
\end_inset

.
 Rispetto alle attese esplicite di Selenium e a Capybara che sfrutta il
 metodo 
\begin_inset Quotes eld
\end_inset

synchronize
\begin_inset Quotes erd
\end_inset

 per verificare il completamento delle operazioni asincrone, l'implementazione
 è nettamente più compatta e leggibile; inoltre non è presente alcuna particolar
ità rispetto ai test descritti nelle precedenti sessioni che suggerisca
 che il piè di pagina implementi un comportamento asincrono.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Given(@"non è presente il logo nell'intestazione")]
\end_layout

\begin_layout Plain Layout

public void DatoNonEPresenteIlLogoNellIntestazione(){
\end_layout

\begin_layout Plain Layout

	Assert.That(footer, Shows.No.Css("img"));
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Pre-condizione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[When(@"clicco sull'area del pié di pagina")]
\end_layout

\begin_layout Plain Layout

public void QuandoCliccoSullAreaDelPieDiPagina(){
\end_layout

\begin_layout Plain Layout

	footer.Click();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Evento.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Then(@"è presente il logo")]
\end_layout

\begin_layout Plain Layout

public void AlloraEPresenteIlLogo(){
\end_layout

\begin_layout Plain Layout

	var footer = base.footer;
\end_layout

\begin_layout Plain Layout

	Assert.That(footer, Shows.Css("img"));
\end_layout

\begin_layout Plain Layout

	Assert.That(footer.FindId("woodstock").Exists());
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Asserzione.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scenari sull'auto-completamento con JQuery UI
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

@cap5
\end_layout

\begin_layout Plain Layout

Funzionalità: Ricerca fra i post
\end_layout

\begin_layout Plain Layout

	Come Lettore
\end_layout

\begin_layout Plain Layout

	Vorrei poter ricercare i post su RBlog
\end_layout

\begin_layout Plain Layout

	Per poter navigare fra i contenuti più velocemente
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario sulla ricerca nei post.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella funzionalità corrente è verificato il widget per l'auto-complemento
 del menu della ricerca, implementato tramite JQuery UI ed una chiamata
 AJAX.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Scenario: Autocompletamento della ricerca
\end_layout

\begin_layout Plain Layout

	Dato nell'intestazione è presente la barra di ricerca
\end_layout

\begin_layout Plain Layout

	Dato il post "Lorem Ipsum" esiste
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "lor" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora viene proposto il post "Lorem Ipsum"
\end_layout

\begin_layout Plain Layout

	Quando inserisco il testo "xyz" da ricercare
\end_layout

\begin_layout Plain Layout

	Allora non è proposto alcun post
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Scenario riguardante l'auto-completamento della ricerca.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nei successivi listati sono incluse le implementazioni dei passi che verificano
 la presenza del menù a tendina per il campo 
\begin_inset Quotes eld
\end_inset

input
\begin_inset Quotes erd
\end_inset

 della ricerca.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Then(@"viene proposto il post ""(.*)""")]
\end_layout

\begin_layout Plain Layout

public void AlloraVienePropostoIlPost(string title){
\end_layout

\begin_layout Plain Layout

	var suggestion = browser.FindCss(".ui-menu-item", title);
\end_layout

\begin_layout Plain Layout

	Assert.That(suggestion.Exists());
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica della presenza di un post nei suggerimenti.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Coypu anche per uno scenario più complesso, in quanto questa operazione
 asincrona ha maggior latenza rispetto alla risoluzione della chiamata Javascrip
t dello scenario 
\begin_inset Quotes eld
\end_inset

EasterEgg
\begin_inset Quotes erd
\end_inset

, non necessità di introdurre istruzioni ad-hoc.
 Inoltre Coypu è coerente nell'implementazione delle proprie funzionalità
 e restituisce solo elementi effettivamente visibili nella pagina
\begin_inset Foot
status open

\begin_layout Plain Layout
Tramite la configurazione della sessione di navigazione, è possibile richiedere
 che siano individuati anche gli elementi non visibili.
\end_layout

\end_inset

, al contrario utilizzando Selenium per questo stesso test è stato necessario
 verificare l'effettiva visualizzazione dell'elemento 
\begin_inset Quotes eld
\end_inset

ui-menu-item
\begin_inset Quotes erd
\end_inset

 tramite il metodo 
\begin_inset Quotes eld
\end_inset

isDisplayed
\begin_inset Quotes erd
\end_inset

 dell'interfaccia 
\begin_inset Quotes eld
\end_inset

WebElement
\begin_inset Quotes erd
\end_inset

 a causa del comportamento particolare del widget.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[Then(@"non è proposto alcun post")]
\end_layout

\begin_layout Plain Layout

public void AlloraNonEPropostoAlcunPost(){
\end_layout

\begin_layout Plain Layout

	Assert.That(browser, Shows.No.Css(".ui-menu-item"));
\end_layout

\begin_layout Plain Layout

}
\begin_inset Caption Standard

\begin_layout Plain Layout
Verifica dell'assenza di suggerimenti.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il widget per l'auto-completamento, probabilmente per minimizzare il numero
 di operazioni di modifica del DOM, applica un meccanismo paragonabile al
 caching.
 Invece di rimuovere le opzioni proposte dalla pagina, che corrispondono
 ai punti di una lista numerata in HTML, quando il focus è spostato su un
 altro elemento della pagina, JQuery UI rende non visibile l'intera lista
 e ne mantiene gli elementi nel DOM.
\end_layout

\begin_layout Standard
Quando sarà effettuata una nuova ricerca all'interno della pagina, il widget
 provvederà a correggere la cardinalità della lista e sostituire il testo
 degli elementi con i nuovi valori.
\end_layout

\end_body
\end_document
